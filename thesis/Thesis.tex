\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\usepackage{marvosym}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command

\usepackage{proof} % \infer command

\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction

% allow breaks in align and equation (a new page for example) 
\allowdisplaybreaks

\usepackage{amsthm}

\theoremstyle{plain} % default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}% [section] 
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example} % [section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% Custom commands

\newcommand*{\thmref}[1]{\hyperref[thm:#1]{Theorem~\ref*{thm:#1}}} % Theorem~\ref
\newcommand*{\lemref}[1]{\hyperref[lem:#1]{Lemma~\ref*{lem:#1}}}
\newcommand*{\defref}[1]{\hyperref[defn:#1]{Definition~\ref*{defn:#1}}}
\newcommand*{\figref}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand*{\exmpref}[1]{\hyperref[exmp:#1]{Example~\ref*{exmp:#1}}}
\newcommand*{\chapterref}[1]{\hyperref[ch:#1]{Chapter~\ref*{ch:#1}}}

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{green!30!black}{#1}} % \textcolor{green!70!black} \textcolor{blue!80!black}
\newcommand*{\pathterm}[1]{\textcolor{green!40!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
% \newcommand*{\dependenttype}[1]{\textcolor{magenta!70!black}{#1}}
\newcommand*{\container}[1]{\textcolor{orange}{#1}}
\newcommand*{\containerpair}[2]{\ensuremath{\colorlet{savedleftcolor}{.}\color{orange}\left(\color{savedleftcolor}#1\,\textcolor{orange}{\mathbf{,}}\,#2\color{orange}\right)\color{savedleftcolor}}}
\newcommand*{\containerpairsimple}[2]{\containerpair{#1}{\lambda\,\_,\,#2}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\relation}[1]{\textcolor{gray!75!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constant}[1]{\textcolor{orange!60!black}{\ensuremath{\mathtt{#1}}}}

\newcommand*{\function}[1]{\textcolor{blue!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constructor}[1]{\textcolor{purple!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\destructor}[1]{\textcolor{yellow!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\typeformer}[1]{\ensuremath{\mathtt{#1}}}
\newcommand*{\functor}[1]{\ensuremath{\mathbf{\mathtt{#1}}}}

\newcommand*{\unitelem}{\constant{\star}} % \constant{tt}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

\newcommand*{\natcases}[2]{\ensuremath{\mathbb{[\hspace{-.5mm}\rangle}~\ensuremath{#1}~,~\ensuremath{#2}~\mathbb{\langle\hspace{-.5mm}]}}}

% Concatenation of paths taken from HoTT book
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\newcommand*{\sym}[1]{\ensuremath{#1^{-1}}}

% \mathord

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
  {\Huge\sf (Q)\texttt{M}-types and Coinduction in HoTT / CTT}\\[2ex]
  {\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
  \noindent\rule{\linewidth}{1mm}\\[4ex]
  \noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
    \today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

We present a construction of \texttt{M}-types from containers in a cubical type theory (CTT), We show how the containers construct a coalgebra, for which we can define a coinduction principle, making strong bisimulation imply equality. We then show constructions of \texttt{M}-types, and how they can be quotiented to construct what we call Q\texttt{M}-types. The problem with Q\texttt{M}-types is that in general assuming that we can lift function types of equivalence classes is equivalent to the axiom of choice \cite{DBLP:tt-in-tt}, but this can be solved by defining the quotienting relation and the type at the same time as a quotient inductive-inductive type (QIIT), which assuming the axiom of (countable) choice, is equal to the Q\texttt{M}-type. We conclude with some examples of how to use \texttt{M}-types and some properties. All work is formalized in Cubical Agda, and the work on defining \texttt{M}-types has been accepted to the Cubical Agda github repository.

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo[inline]{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}
I would like to thank my supervisor Bas Spitters for some enlightening discussions and quick responses and for taking the time to do weekly meetings regarding this masters thesis. I would also like to thank my fellow students, who made this challenging but fun time less lonely even in the time of the Corona pandemic.
\vspace{2ex}
\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{3} % 2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Introduction} % Everyone interested should be able to read this!
\label{ch:intro}

\section{Overview}
There has been done a lot of work on understanding and formalizing inductive types in homotopy type theory (HoTT) / cubical type theory. One such body of work is W-types, which have been shown equal to inductive types. However there has not been much work on the dual concept, namely coinductive types defined using M-types. The goal of this thesis is to get an understanding of M-types. We also want to construct examples and show properties of M-types, since we want to make the theory of M-types more accessible. A useful technique used alot in constructive mathematics is quotienting free objects, as such we will also look into what it means to quotient M-types in the setting of cubical type theory, and the problems the obvious approach encounters.
\\ \\
In the rest of this chapter we will introduce some of the background theory and notation used in the rest of the thesis. In the second chapter we construct \texttt{M}-types from containers, and define a coinduction principle for the \texttt{M}-types. In the third chapter we give some example constructions of \texttt{M}-types. In the fourth chapter we introduce quotiented \texttt{M}-types (Q\texttt{M}-types), and show equalities between these and quotient inductive-inductive types (QIITs), we show the construction of the partiality monad as an example. In the fifth and sixth chapter we go through various applications of the theory developed in the first couple chapters. Finally we conclude with a discussion of future research and improvements.

\section{Background Theory}
We start by giving some background theory / history on cubical type theory and summarize important concepts used in the rest of this thesis. \todo{Should a description of Set Theory be included}
\\ \\
We will be using \textbf{type theory} as the basis for mathematics. In type theory every term \(\term{x}\) is an element of some type \(\type{A}\), written \(\term{x} : \type{A}\). The idea in type theory is that propositions are types, so proofs boils down to showing that there exists an element of some type representing a proposition. Specifically proofs of equality becomes construction of an element of an equality type. The type theory we are working in is inspired by \textbf{Martin L\"of Type Theory (MLTT)} / Intuitionistic type Theory (ITT), which is designed on the principles of mathematical constructivism, where any existence proof must contain a witness. Meaning a proof of existence, can be converted into an algorithm that finds the element making the statement true. MLTT is built from the three finite types \(\empt\), \(\unit\) and \(\type{\mathbf{2}}\), and type constructors \(\Sigma\), \(\pi\) and \(=\). There is only a single way to make terms of \(=\)-type, and that is \(\mathtt{refl} : \prod_{a : A} (a = a)\). \todo{inductive types, universes and judgements} \todo{extensional vs intensional \url{https://ncatlab.org/nlab/show/intensional+type+theory}} \todo{find citation, currently \url{https://en.wikipedia.org/wiki/Intuitionistic_type_theory}}.
\\ \\
A constructor for a type \(\type{A}\) is a function, that takes some arguments, and returns an element \(\term{a} : \type{A}\), dually a destructor of \(\type{A}\) will return something given an element \(\term{a} : \type{A}\). Types can be defined from a set of constructors (or destructors). We can define a type \textbf{inductively} from a set of constructors, for example the natural numbers \(\mathbb{N}\), which can be defined as \(0\) or a natural number \(n\) plus one \\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.15\linewidth}
    \begin{equation}
      \vcenter{\infer{0 : \mathbb{N}}{\strut}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.20\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{succ}~n : \mathbb{N}}{n : \mathbb{N}}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
with an equivalence relation \(\relation{\sim_{\mathbb{N}}}\) defined inductively, meaning we follow the structure defined by the constructors \\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.20\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{0}}]{0 = 0}{\strut}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{succ}}]{\constructor{succ}~n~\relation{\sim_{\mathbb{N}}}~\constructor{succ}~m}{n~\relation{\sim_{\mathbb{N}}}~m}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
This relation implies equality, so if \(a~\relation{\sim_{\mathbb{N}}}~b\) then \(a = b\). Likewise there is a \textbf{coinductive} construction, where the focus is on the destructors instead of the constructors, an example is streams, which represents an infinite sequence of elements. Streams can be defined from the two destructors head (\(\destructor{hd}\)) and tail (\(\destructor{tl}\)), where head represents the first element, and tail represents the rest of the sequence. The inference rules are given as
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.225\linewidth}
    \begin{equation}
      \vcenter{\infer{\destructor{hd}~\term{s} : \type{A}}{\term{s} : \typeformer{stream}~\type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\linewidth}
    \begin{equation}
      \vcenter{\infer{\destructor{tl}~\term{s}: \typeformer{stream}~\type{A}}{\term{s} : \typeformer{stream}~\type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
we can again define an equivalence relation \(\relation{\sim_{stream}}\), but this time coinductively, focusing on the structure of the destructors instead
\begin{equation}
  \vcenter{\infer{\term{s}~\relation{\sim_{stream}}~\term{t}}{\destructor{hd}~\term{s} = \destructor{hd}~\term{t} & \destructor{tl}~\term{s}~\relation{\sim_{stream}}~\destructor{tl}~\term{t}}}
\end{equation}
This relation does not give an equality in MLTT, we just get bisimilarity meaning elements "behave" the same, but they are not equivalent. \todo{Inductive vs Coinductive definition for a set of constructors} To remedy this constraint, we will work in a type theory where the univalence axiom is holds, using such a type theory as the foundation for mathematics is called \textbf{Univalent Foundations (UF)}. The \textbf{univalence axiom} says that equality is equivalent to equivalence
\begin{equation}
  (\type{A} = \type{B}) \simeq (\type{A} \simeq \type{B})
\end{equation}
meaning if two objects are equivalent, then there is an equality between them, such that we can replace one by the other. This makes (strong) bisimilarity imply equality. The univalent foundations we will be using is \textbf{Homotopy type theory (HoTT)} \cite{hottbook}. HoTT is an intensional dependent type theory (built on MLTT) with the univalence axiom and higher inductive types. In HoTT the idenitity types form path spaces, so proofs of identity are not just \texttt{refl} as is the case in MLTT. Types are seen as "spaces", and we think of \(\term{a} : \type{A}\) as \(\term{a}\) being a point in the space \(\type{A}\), similarly functions are regarded as continuous maps from one space to another \cite{nlab:homotopy_type_theory}. One of the problems with "plain" HoTT is that the univalence axiom is not constructive, since it is an axiom. To remedy this we will be working in a \todo{.. be working implementation of hott namely ctt} \textbf{cubical type theory (CTT)} \cite{DBLP:CTT}, where the univalence axiom is not an axiom, but a statement that can actually be proven, meaning we can reduce the use of the univalence axiom, making it easier to do proofs involving the univalence axiom \cite{nlab:cubical_type_theory}. \todo{example of what computational "axioms" mean} The reason for the name cubical type theory, is because composition is defined by square, that is given three sides of a square we get the last one, see \figref{cubical-composition-square}.
\begin{figure}[h]
  \centering
  \begin{tikzcd}
    A \ar[r,"p \ct q \ct r",dashed] & B \\
    C \ar[u,"p^{-1}"] \ar[r,"q"'] & D \ar[u,"r"']
  \end{tikzcd}
  \caption{Composition square}
  \label{fig:cubical-composition-square}
\end{figure}
~\\ \\
Inductively defined data types are initial algebras, meaning that they are the smallest type, with a given set of constructors / destructors. \todo{...}... An algebra is an operator \(\functor{F}\) with some closure relation \todo{cite something}. \todo{...}... inductive types are given as the initial algebra for some functor, this can be formalized as \texttt{W}-types, dually the coinductive types that we are interested in, can be formalized as the final coalgebra \todo{final coalgebra is scary words, find something more "noob" friendly} for some functor. We will be looking at how to define some coinductive types, as \texttt{M}-types \todo{W-types, Induction , M-types, Coinduction...}, and define some bisimilarity relations for these types, showing we get equality when using homotopy type theory. We will then introduce weaker notion of bisimilarity, that does not yield equality, but can be used to construct a new type, by quotienting with the relation, giving us a type where the relation gives equality\todo{describe quotienting and its usefullness by a couple examples}. \todo{...}... When working with quotiented coinductive types. \todo{What is a monad?} \todo{...}... We define the quotiented delay monad \(\typeformer{Delay}/\relation{\sim_{weak}}\), and want to show that we can construct a partiality monad from this construction. A problem with the partiality operation \(D(-)/{\sim}_D\) is that countable choice is needed to show that it is a monad, however using QIIT types we can get around this problem, furthermore we can show that assuming countable choice, these two constructions are equal. Using the axiom of choice (AC) and the law of excluded middle (LEM), has problematic side effects, when using a constructive type theory, since AC and LEM does not have a constructive interpretation, so to maintain the computational aspects of HoTT and CTT, we try to not use these axioms \cite[Introduction]{hottbook}.
\\ \\
If you are used to working in set theory, then working in HoTT will take some getting used to. Homotopy type theory is proof relevant, which means that a there might be multiple proofs of one statement, and these proofs might not be interchangeable (equal). The reason is that types in HoTT have a H-level, describing how equality behaves. We start from (-2) with contractiable types, meaning there is an element which all other element are equal to. Then there is (-1)-types which are mere propositions or hProp, where all elements of the type are equal, but there might not be any. If the type is inhabited, then we say the proposition is true. The 0-types are the hSets, where all equalities between two elements \(x,y\) are equal. For 1-types (1-groupoids) we get equalities of equalities are equal, and then so on for homotopy \(n\)-types. Any \(n\)-type is also a \(n+1\)-type, but with trivial equalities at the \(n+1\) level. If we don't want to do proof relevant mathematics we can do propositional truncation, converting types to \(-1\)-type, meaning we ignore the difference in proofs by just look at whether a type is inhabited or not. However doing this we loose some of the reasoning power of HoTT. One of the tools we get using the full power of HoTT is \textbf{Higher order inductive types (HITs)}, where we define types with point constructors and equality constructors, an example is the propositional truncation we just described\todo{write up constructors for propositional truncation}, another useful example is set truncated quotients\todo{write up constructors for set truncated quotients}.
\\ \\
We have formalized most of \chapterref{M-types} (accepted to the cubical agda github: \url{https://github.com/agda/cubical/pull/245}) and \chapterref{M-types-examples} and some of \chapterref{QM-types} \todo{add remaing chapters} in the proof assistant / programming languge Cubical Agda. A \textbf{proof assistant} helps with verifying proofs, while making the process of making proofs interactive. \textbf{Cubical Agda} \cite{cubicalagda} is an implementation of a cubical type theory (inspired by CCHM \cite{DBLP:CCHM}) made by extending the proof assistant Agda. One of the main additions is the interval and path types. The \textbf{interval} \(\mathbb{I}\) can be thought of as elements in \([0,1]\). When working with the interval, we can only access the left and right endpoint \(\constant{i0}\) and \(\constant{i1}\) or some unspecified point in the middle \(i\), keeping with the intuition of a continuous interval. Cubical agda also generalizes transporting, given a type line \(\typeformer{A} : \mathbb{I} \rightarrow \universe{\mathcal{U}}\), and the endpoint \(\typeformer{A}~\constant{i0}\) you get a line from \(\typeformer{A}~\constant{i0}\) to \(\typeformer{A}~\constant{i1}\). \todo{Axioms of cubical Agda} \todo{Some better (intuitive) description of the interval type!!}
\\ \\
Cubical Agda has a hierarchy of universes, \(\universe{\mathcal{U}}_0, \universe{\mathcal{U}}_1, \dots\), however we will leave the index implicit and write \(\universe{\mathcal{U}}\).
\todo[inline]{Universes??}

\section{Notation}
The following is the notation / fonts used to denote specific definitions / concepts
\begin{itemize}
\item Universe \(\universe{\mathcal{U}}_i\) or \(\universe{\mathcal{U}}\)
\item Type \(\type{A} : \universe{\mathcal{U}}\)
\item A type former or dependent type \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\)
\item A term \(\term{x} : \type{A}\) or for constants \(\constant{c} : \type{A}\)
\item A function \(\function{f} : \type{A} \rightarrow \type{C}\)
\item A constructor \(\constructor{f} : \type{A} \rightarrow \type{C}\) \todo{better description, not always a function}
\item A destructor \(\destructor{f} : \type{A} \rightarrow \type{C}\) \todo{better description, not always a function}
\item A path \(\pathterm{p} : \type{A} \equiv \type{C}\), heterogeneous paths are denotes \(\equiv_p\) or if the path is clear from context \(\equiv_*\).
\item A relation \(\relation{R} : \type{A} \rightarrow \type{A} \rightarrow \universe{\mathcal{U}}\) with notation \(\term{x}~\relation{R}~\term{y}\).
\item The unit type is \(\unit\) while the empty type is \(\empt\).
\item A functor \(\functor{P}\)
\item A container is denoted as \(\container{S}\) or \(\containerpair{\type{A}}{\typeformer{B}}\)
\item A coalgebra \(\coalg{\type{C}}{\function{\gamma}}\)
\item We denote the function giving the first and second projection of a dependent pair by \(\pi_1\) and \(\pi_2\).
\end{itemize}
Furthermore we define some useful notation for casing on natural numbers.
\begin{defn}
  \begin{equation}
    \natcases{\term{x}}{\function{f}} = \lambda\,n, \begin{cases} \term{x} & n = 0 \\ \function{f}~m & n = m + 1 \end{cases}
  \end{equation}
\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{\texttt{M}-types}
\label{ch:M-types}
In this chapter we will introduce containers (aka. signatures), and use them to construct \texttt{M}-types and operations \(\function{in}\) and \(\function{out}\) on the \texttt{M}-types (\thmref{M-shift}) and showing that \(\coalg{\typeformer{M}}{\function{out}}\) is a final coalgebra (\thmref{M-type-final}). We conclude the chapter by proving a coinduction principle for \texttt{M}-types (\thmref{M-coinduction-principle}) \cite{DBLP:non-wellfounded}. \todo{Some formalization of coalgebras is missing?}

\section{Containers / Signatures}
\begin{defn}
  A Container (or signature) is a dependent pair \(\container{S} = \containerpair{\type{A}}{\typeformer{B}}\) for the types \(\type{A} : \universe{\mathcal{U}}\) and \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\).
\end{defn}
\begin{defn}
  A polynomial functor over the container \(\container{S} = \containerpair{\type{A}}{\typeformer{B}}\) is defined for types as
  \begin{equation}
    \begin{aligned}
      &\functor{P}_{\container{S}} : \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
      &\functor{P}_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \typeformer{B}(\term{a}) \rightarrow \type{X}
    \end{aligned}
  \end{equation}
  and for a function \(\function{f} : \type{X} \rightarrow \type{Y}\) as
  \begin{equation}
    \begin{aligned}
      &\functor{P}_{\container{S}}\function{f} : \functor{P}_{\container{S}}\type{X} \rightarrow \functor{P}_{\container{S}}\type{Y} \\
      &\functor{P}_{\container{S}}\function{f}(\term{a},\function{g}) = (\term{a}, \function{f} \circ \function{g}).
    \end{aligned}
  \end{equation}
\end{defn}
\begin{exmp}
  \label{exmp:stream-polyfunctor-example}
  The polynomial functor for streams over the type \(\type{A}\) is defined by the container \(\container{S} = \containerpairsimple{\type{A}}{\unit}\), we get
  \begin{equation}
    \label{eq:stream-polyfunctor-pre}
    \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X}.
  \end{equation}
  Since we are working in a logic with exponentials, we get \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\). Furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\), so \eqref{eq:stream-polyfunctor-pre} is equivalent to
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \type{A} \times \type{X}.
  \end{equation}
\end{exmp}
\noindent We now construct the \(\functor{P}_{\container{S}}\)-coalgebra for a polynomial functor \(\functor{P}_{\container{S}}\).
\begin{defn}
  A \(\functor{P}_{\container{S}}\)-coalgebra is defined as
  \begin{equation}
    \typeformer{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow \functor{P}_{\container{S}}\type{C}.
  \end{equation}
  We denote a \(\functor{P}_{\container{S}}\)-coalgebra given by \(\type{C}\) and \(\function{\gamma}\) as \(\coalg{\type{C}}{\function{\gamma}}\). Coalgebra morphisms are defined as
  \begin{equation}
    \begin{aligned}
      \cdot \Rightarrow ~\cdot &: \typeformer{Coalg}_{\container{S}} \rightarrow \typeformer{Coalg}_{\container{S}} \\
      \coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{D}}{\function{\delta}} &= \sum_{\function{f} : \type{C} \rightarrow \type{D}} \function{\delta} \circ \function{f} = \functor{P} \function{f} \circ \function{\gamma}
    \end{aligned}
  \end{equation}
\end{defn}
\noindent We can now define \texttt{M}-types.
\begin{defn}
  \label{defn:M-type-final-def}
  Given a container \(\container{S}\), we define \(\mathtt{M}\)-types as the type, making the coalgebra given by \(\typeformer{M}_{\container{S}}\) and \(\function{out} : \typeformer{M}_{\container{S}} \rightarrow \functor{P}_{\container{S}}(\typeformer{M}_{\container{S}})\) fulfill the property
  \begin{equation}
    \typeformer{Final}_{\container{S}} := \sum_{(\coalg{\type{X}}{\function{\rho}} : \mathtt{Coalg}_{\container{S}})} \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{X}}{\function{\rho}}).
  \end{equation}
  That is \(\prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\typeformer{M}_{\container{S}}}{\function{out}})\). We denote the \texttt{M}-type as \(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}\) or \(\typeformer{M}_{\container{S}}\) or just \(\typeformer{M}\) when the Container is clear from the context. When writing \(\mathtt{isContr}~\type{A}\), we mean \(\type{A}\) is of H-level \((-2)\), that is \(\sum_{\term{x} : \type{A}} \prod_{\term{y} : \type{A}} \term{y} \equiv \term{x}\) or equivalently \(\type{A} \equiv \unit\).
\end{defn}
\noindent Continuing our example we now construct streams as an \(\mathtt{M}\)-type.
\begin{exmp}
  \label{exmp:stream-M-type-example}
  We define streams over the type \(\type{A}\) as the \(\mathtt{M}\)-type over the container \(\containerpairsimple{\type{A}}{\unit}\). If we apply the polynomial functor to the \texttt{M}-type, then we get \(\functor{P}_{\containerpairsimple{\type{A}}{\unit}} \typeformer{M} = \type{A} \times \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\), illustrated in \figref{stream-M-type}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{A} & \type{A} \times \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \\
      & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[ul,"\destructor{hd}"] \ar[u,"\function{out}"'] \ar[ur,"\destructor{tl}"']
    \end{tikzcd}
    \caption{\texttt{M}-types of streams}
    \label{fig:stream-M-type}
  \end{figure}
  We will that \(\function{out}\) is an isomorphism with inverse \(\function{in} : \functor{P}_{\container{S}}(\typeformer{M}) \rightarrow \typeformer{M}\) later in this section. We now have a semantic for the rules, we would expect for streams, if we let \(\constructor{cons} = \function{in}\) and \(\typeformer{stream}~\type{A} = \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\),
  \begin{equation}
    \vcenter{\infer[\mathtt{E}_{\destructor{hd}}]{\destructor{hd}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}}
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{E}_{\destructor{tl}}]{\destructor{tl}~\term{s} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}}
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{I}_{\constructor{cons}}]{\term{\constructor{cons}}~\term{x}~\term{xs} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \typeformer{stream}~\type{A}}}
  \end{equation}
  or more precisely \(\destructor{hd} = \pi_1 \circ \function{out}\) and \(\destructor{tl} = \pi_2 \circ \function{out}\).
\end{exmp}
\begin{defn}
  We define a chain as a family of morphisms \(\function{\pi}_{(n)} : \type{X}_{n+1} \rightarrow \type{X}_{n}\), over a family of types \(\type{X}_{n}\). See \figref{x-chain}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"]
    \end{tikzcd}
    \caption{Chain of types / functions}
    \label{fig:x-chain}
  \end{figure}  
\end{defn}
\begin{lem}\label{lem:function-to-M-type-is-cone}
  For all coalgebras \(\coalg{\type{C}}{\function{\gamma}}\) for the container \(\container{S}\), we get \(\type{C} \rightarrow \typeformer{M}_{\container{S}} \equiv \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\), where \(\typeformer{Cone} = \sum_{(\function{f} : \prod_{(n : \mathbb{N})} \type{C} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{f}_{n+1} \equiv \function{f}_n\) illustrated in \figref{M-seq-cone}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"] \\
      & & \type{C} \ar[ull,"\function{f}_0"] \ar[ul,"\function{f}_1"'] \ar[u,draw=none,"\cdots" description] \ar[ur,"\function{f}_n"] \ar[urr,"\function{f}_{n+1}"'] \ar[urrr,draw=none,"\cdots"'] & 
    \end{tikzcd}
    \caption{Cone}
    \label{fig:M-seq-cone}
  \end{figure}  
  \begin{proof}
    We define an isomorphism from \(\type{C} \rightarrow \typeformer{M}_{\container{S}}\) to \(\typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\)
    \begin{align}
      &\function{fun}_{\pathterm{collapse}}~\function{f} = (\lambda\,n\,\term{z},\pi_1~(\function{f}~\term{z})~n),(\lambda\,n~i~\term{a},~\pi_2~(\function{f}~\term{a})~n~i) \\
      &\function{inv}_{\pathterm{collapse}}~(\function{u},\function{q})~\term{z} = (\lambda\,n,~\function{u}~n~\term{z}),(\lambda\,n\,i,~\function{q}~n~i~\term{z}) \\
      &\function{rinv}_{\pathterm{collapse}}~(\function{u},\function{q}) = \mathtt{refl}_{(\function{u},\function{q})} \\
      &\function{linv}_{\pathterm{collapse}}~\function{f} = \mathtt{refl}_{\function{f}}
    \end{align}
  \end{proof}
\end{lem}
\begin{lem}\label{lem:limit-collapse}
  Given \(\function{\ell} : \prod_{(n : \mathbb{N})} (\type{X}_{n} \rightarrow \type{X}_{n+1})\) and \(\term{y} : \sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) the chain collapses as the equality \(\type{\mathcal{L}} \equiv \type{X}_0\).
  \begin{proof}
    We define this collapse by the isomorphism
    \begin{align}
      &\function{fun}_{\pathterm{\mathcal{L}collapse}}~(\term{x} , \pathterm{r}) = \term{x}_0 \\
      &\function{inv}_{\pathterm{\mathcal{L}collapse}}~\term{x}_0 = (\lambda\,n,~\function{\ell}^{(n)}~\term{x}_0)~,~(\lambda\,n,~\mathtt{refl}_{(\function{\ell}^{(n+1)}\,\term{x}_0)}) \\
      &\function{rinv}_{\pathterm{\mathcal{L}collapse}}~\term{x}_0 = \mathtt{refl}_{\term{x}_0}
    \end{align}
    where \(\function{\ell}^{(n)} = \function{\ell}_n \circ \function{\ell}_{n-1} \circ \dots \circ \function{\ell}_1 \circ \function{\ell}_0\). To define \(\function{linv}_{\pathterm{\mathcal{L}collapse}}~(\term{x} , \pathterm{r})\), we first define a fiber \((\type{X} , \term{z}, \function{\ell})\) over \(\mathbb{N}\) given some \(\term{z} : \type{X}_0\). Then any element of the type \(\sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) is equal to a section over the fiber we defined. This means \(\term{y}\) is equal to a section. Since the sections are defined over \(\mathbb{N}\), which is an initial algebra for the functor \(\functor{G}\type{Y} = \unit + \type{Y}\), we get that sections are contractible, meaning \(\term{y} \equiv \function{inv}_{\mathcal{L}collapse} (\function{fun}_{\mathcal{L}collapse}~\term{y})\), since both are equal to sections over \(\mathbb{N}\).
\end{proof}
\end{lem}
\noindent We can now define the construction of \function{in} and \function{out}.
\begin{thm}
  \label{thm:M-shift}
   Given the container \(\containerpair{\type{A}}{\typeformer{B}}\) we define the equality
  \begin{equation}
    \pathterm{shift} : \type{\mathcal{L}} \equiv \functor{P}\type{\mathcal{L}}
  \end{equation}
  where \(\functor{P}\type{\mathcal{L}}\) is the limit of a shifted sequence. Then
  \begin{equation}
    \function{in} = \mathtt{transport}~\pathterm{shift}
  \end{equation}
  \begin{equation}
    \function{out} = \mathtt{transport}~(\sym{\pathterm{shift}}).
  \end{equation}
  \begin{proof}
    The proof is done using the two helper lemmas
    \begin{equation}
      \pathterm{\alpha} : \type{\mathcal{L}}^{\functor{P}} \equiv \functor{P}\type{\mathcal{L}}
    \end{equation}
    \begin{equation}
      \pathterm{\mathcal{L}unique} : \type{\mathcal{L}} \equiv \type{\mathcal{L}}^{\functor{P}}
    \end{equation}
    We define \(\pathterm{\mathcal{L}unique}\) by the ismorphism
    \begin{align}
      \function{fun}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \natcases{\unitelem}{\function{a}} , \natcases{\mathtt{refl}_{\unitelem}}{\function{b}} \\
    \function{inv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \function{a} \circ \constructor{succ}~,~\function{b} \circ \constructor{succ} \\
    \function{rinv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})} \\
    \function{linv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})}
    \end{align}
    The definition of \(\pathterm{\alpha}\) is then, 
    \begin{align}
      \type{\mathcal{L}}^{\functor{P}} &\equiv \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \\
      &\equiv \sum_{(\term{x} : \sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n)} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,{(\pi_1\,\term{x})}_n \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv_* \function{u}_n \label{eq:alpha-unfold} \\
      &\equiv \sum_{(\term{a} : \type{A})} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,a \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n \label{eq:alpha-limit-collapse} \\
      &\equiv \sum_{(\term{a} : \type{A})} \typeformer{B}~\term{a} \rightarrow \type{\mathcal{L}} \label{eq:alpha-cone}\\
      &\equiv \functor{P}\type{\mathcal{L}}
    \end{align}
    To collapse \(\sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n\) to \(\type{A}\) between \eqref{eq:alpha-unfold} and \eqref{eq:alpha-limit-collapse} we use \lemref{limit-collapse} . We use \lemref{function-to-M-type-is-cone} for the equality between \eqref{eq:alpha-limit-collapse} and \eqref{eq:alpha-cone}. The rest of the equalities are trivial. The definition of \(\pathterm{shift}\) is
    \begin{equation}
      \pathterm{shift} = \sym{\pathterm{\alpha}} \ct \pathterm{\mathcal{L}unique}.
    \end{equation}
    We furthermore get the definitions \(\function{in} = \mathtt{transport}~\pathterm{shift}\) and \(\function{out} = \mathtt{transport}~(\sym{\pathterm{shift}})\), since \function{in} and \function{out} are part of an equality relation \(\pathterm{shift}\), they are both surjective and embeddings. \todo{is surjectivity and embedding important here? Describe this where relevant instead!}
  \end{proof}
\end{thm}
\begin{thm}
  \label{thm:M-type-final}
  The \texttt{M}-type \(\typeformer{M}_{\container{S}}\) is defined as the limit for a polynomial functor \(\functor{P}_{\container{S}}\), meaning that it fulfills \defref{M-type-final-def} \(\typeformer{Final}_{\container{S}}~\mathcal{L}\).
  \begin{proof}
    So we need to show that \(\prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}})\), so we assume we are given some \(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}}\), to show \((\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}}) \equiv \unit\). We have    
    \begin{align}
      &\quad~\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}} \\
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{out} \circ \function{f} \equiv \functor{P}\function{f} \circ \function{\gamma}) \\
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{in} \circ \function{out} \circ \function{f} \equiv \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}) \\
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}) \\
    \end{align}
    we let \(\function{\psi} = \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}\), which simplifies the expression to \(\sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{\psi}~\function{f})\). We define \(e\) to be the function from right to left for the equality in \lemref{function-to-M-type-is-cone}, we then get the equality
    \begin{equation}
      \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{\psi}~\function{f}) \quad \equiv \quad \sum_{(\term{c} : \typeformer{Cone}_{\coalg{C}{\gamma}})} (\function{e}~\term{c} \equiv \function{\psi}~(\function{e}~\term{c}))
  \end{equation}
  if we define the function \(\phi : \typeformer{Cone}_{\container{S}} \rightarrow \typeformer{Cone}_{\container{S}}\) as \(\function{\phi}~(\function{u},\function{g}) = (\function{\phi}_0~\function{u},\function{\phi}_1~\function{u}~\function{g})\) where
  \begin{align}
    \function{\phi}_0~\function{u} &= \natcases{(\lambda\,\_, \unitelem)}{\functor{P}\function{f} \circ \function{\gamma} \circ \function{u}} \\
    \function{\phi}_1~\function{u}~\function{g} &= \natcases{\mathtt{funExt}~\lambda\,\_, \mathtt{refl}_{\unitelem}}{\mathtt{ap}~(\functor{P}\function{f} \circ \function{\gamma}) \circ \function{g}}
  \end{align}
  then we get the commuting square in \figref{commuting-square},
    \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \ar[d,"\phi"] \ar[r,"e"] & (\type{C} \rightarrow \type{\mathcal{L}}) \ar[d,"\psi"] \\
      \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \ar[r,"e"] & (\type{C} \rightarrow \type{\mathcal{L}})
    \end{tikzcd}
    \caption{commuting square}
    \label{fig:commuting-square}
  \end{figure}
  which says \(\function{\psi}~(\function{e}~\term{c}) = \function{e}~(\function{\phi}~\term{c})\), so we can continue the simplification
  \begin{equation}
    \sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\function{e}~\function{c} \equiv \function{e}~(\function{\phi}~\function{c}))
  \end{equation}
  We know that \(\function{e}\) is part of an equality (namely \lemref{function-to-M-type-is-cone}), so it is an embedding, that is for all \(\term{a},\term{b}\) the equality \(\function{e}~\term{a} \equiv \function{e}~\term{b}\) implies \(\term{a} \equiv \term{b}\), so we get
  \begin{align}
    &\quad~\sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\function{c} \equiv \function{\phi}~\function{c}) \\
    &\equiv \sum_{(\term{(\function{u},\function{g})} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} ((\function{u},\function{g}) \equiv (\function{\phi}_0~\function{u},\function{\phi}_1~\function{u}~\function{g})) \\
    &\equiv \sum_{(\term{(\function{u},\function{g})} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} \sum_{(\pathterm{p} : \function{u} \equiv \function{\phi}_0\,\function{u})} \function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}
  \end{align}
  We split the order of the \(\Sigma\)'s, by unfolding the definition of \(\typeformer{Cone}\).
  \begin{equation}
    \sum_{\big(\term{(\function{u},\pathterm{p})} : \sum_{(\function{u} : \prod_{(n:\mathbb{N})} \type{C} \rightarrow \type{X}_n)} \function{u} \equiv \function{\phi}_0\,\function{u}\big)} \sum_{(\function{g} : \prod_{(n:\mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n)}\function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}
  \end{equation}
  Now with the following two properties, given by \lemref{limit-collapse}, we are done
  \begin{align}
    \unit &\equiv \left(\sum_{(\function{u} : \prod_{(n:\mathbb{N})} \type{C} \rightarrow \type{X}_n)} \function{u} \equiv \function{\phi}_0\,\function{u}\right)  \\
    \unit &\equiv_{*} \left(\sum_{(\function{g} : \prod_{(n:\mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n)}\function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}\right)
  \end{align}
  since we get the type \(\sum_{\unitelem : \unit} \unit\) which is equal to \(\unit\).
  \end{proof}
\end{thm}

\section{Coinduction Principle for \texttt{M}-types}
We can now construct a coinduction principle given a bisimulation relation.
\begin{defn}
  For all coalgebras \(\coalg{\type{C}}{\function{\gamma}} : \typeformer{Coalg}_{\container{S}}\), given a relation \(\relation{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\) and a type \(\type{\overline{\mathcal{R}}} = \sum_{(\term{a} : \type{C})} \sum_{(\term{b} : \type{C})} \term{a}~\relation{\mathcal{R}}~\term{b}\), such that \(\type{\overline{\mathcal{R}}}\) and \(\function{\alpha}_{\relation{\mathcal{R}}} : \type{\overline{\mathcal{R}}} \rightarrow \functor{P}_{\container{S}}(\type{\overline{\mathcal{R}}})\) forms a \(\functor{P}\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} : \mathtt{Coalg}_{\container{S}}\), making the diagram in \figref{coalgebra-coinduction-definition} commute \todo{What does commute mean here?} (\(\Longrightarrow\) represents \(\functor{P}\)-coalgebra morphisms).
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\type{C}}{\function{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\function{\gamma}}
    \end{tikzcd}
    \caption{Bisimulation for a coalgebra}
    \label{fig:coalgebra-coinduction-definition}
  \end{figure}
\end{defn}
\begin{thm}[Coinduction principle]
  \label{thm:M-coinduction-principle}
  Given a relation \(\relation{\mathcal{R}}\), that is a bisimulation for an \texttt{M}-type, then for all \(\term{x},\term{y}\) if they are related \(\term{x}~\relation{\mathcal{R}}~\term{y}\) then they are equal \(\term{x} \equiv \term{y}\).  
  \begin{proof}
    Given a relation \(\relation{\mathcal{R}}\), that is part of a bisimulation over a final \(\functor{P}\)-coalgebra \(\coalg{\typeformer{M}}{\function{out}}:\mathtt{Coalg}_{\container{S}}\) we get the diagram in \figref{final-coalgebra-coinduction},
    \begin{figure}[h]
      \centering
      \begin{tikzcd}[row sep=huge,column sep=huge]
        \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\typeformer{M}}{\function{out}}
      \end{tikzcd}
      \caption{Bisimulation principle for final coalgebra}
      \label{fig:final-coalgebra-coinduction}
    \end{figure}
    \noindent where \(\pi_1^{\type{\overline{\mathcal{R}}}} = ~! = \pi_2^{\type{\overline{\mathcal{R}}}}\) \todo{what is \(!\)} where \(!\) is the unique mapping property (UMP) out of the final coalgebra. Given \(\term{r} : \term{x}~\relation{\mathcal{R}}~\term{y}\) we get the equation
    \begin{equation}
      \term{x} = \pi_1^{\type{\overline{\mathcal{R}}}} (\term{x}, \term{y}, \term{r}) = \pi_2^{\type{\overline{\mathcal{R}}}} (\term{x}, \term{y}, \term{r}) = \term{y}.
    \end{equation}
    \todo{What is the consequence of this?}
  \end{proof}
\end{thm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Examples of M-types}
\label{ch:M-types-examples}
In this section we show some examples of types that can be constructed as \(M\)-types, and show how their constructors can be defined. We then conclude the chapter with some general observation, and define some rules for how to construct \texttt{M}-types. \todo{Is there anything else that is show for each M-type?}

\todo{complete this section}

\section{Stream Formalization using \texttt{M}-types}
As shown in \exmpref{stream-polyfunctor-example} and \exmpref{stream-M-type-example} above, we can define streams as an \texttt{M}-type. \todo{Anything to add to this section?}

\section{ITrees as \texttt{M}-types}
Interaction trees (ITrees) \cite{DBLP:itrees} are used to model effectful behavior, where computations can interact with an external environment by events. ITrees are defined by the following constructors
\begin{equation}
  \vcenter{\infer[\mathtt{I}_{\constructor{Ret}}]{\constructor{Ret}~\term{r} : \typeformer{itree}~\typeformer{E}~\type{R}}{r : \type{R}}}
\end{equation}
\begin{equation}
  \vcenter{\infer[\mathtt{I}_{\constructor{Vis}}]{\constructor{Vis}~\term{a}~\term{f} : \typeformer{itree}~\typeformer{E}~\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \typeformer{E}~\type{A} & \term{f} : \type{A} \rightarrow \typeformer{itree}~\typeformer{E}~\type{R}}}.
\end{equation}
\begin{equation}
  \vcenter{\infer[\mathtt{E}_{\constructor{Tau}}]{\constructor{Tau}~\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}{\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}}.
\end{equation}
where \(\type{R}\) is the type for returned values, while \(\typeformer{E}\) is a dependent type for events representing external interactions.

\subsection{Delay Monad}
We start by looking at ITrees without the \(\constructor{Vis}\) constructor, this type is also know as the delay monad. It can be used to model delayed computations, either returning immediately given by the constructor \(\constructor{now} = \constructor{Ret}\), or delayed some (possibly infinite) number of steps by the constructor \(\constructor{later} = \constructor{Tau}\). We construct this type as an \texttt{M}-type.
\begin{defn}
  The  delay monad can be defined as the \texttt{M}-type for the container
  \begin{equation}
    \container{S} = \containerpair{\type{R} +\unit}{\begin{cases} \empt & \mathtt{inl}~\term{r} \\ \unit & \mathtt{inr}~\unitelem \end{cases}}
  \end{equation}
\end{defn}
\noindent The polynomial functor for this container is
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{(\term{x} : \type{R} + \unit)} \begin{cases} \empt & \term{x} = \mathtt{inl}~\term{r} \\ \unit & \term{x} = \mathtt{inr}~\unitelem \end{cases} \rightarrow \type{X},
\end{equation}
which we can simplify
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{R} \times (\empt \rightarrow \type{X}) + \type{X}.
\end{equation}
We know that \((\empt \rightarrow \type{X}) \equiv \unit\), so we can simplify further to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R}
\end{equation}
meaning we get diagram in \figref{delay-monad}.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\constructor{now}"'] \ar[r,"\texttt{inl}"] & \type{R} + \typeformer{M} \ar[d,"\function{in}"'] & \typeformer{M} \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{later}"] \\
    & \typeformer{M}
  \end{tikzcd}
  \caption{Delay monad}
  \label{fig:delay-monad}
\end{figure}
\noindent We can define the constructors \(\constructor{now}\) and \(\constructor{later}\) using \(\function{in}\) function for \texttt{M}-types, together with the injections \(\mathtt{inl}\) and \(\mathtt{inr}\).

\subsection{Tree}
Now lets look at the example, where we remove the \(\constructor{Tau}\) constructor. This gives us a type of tree, with leaves given by \(\constructor{Ret}\), and nodes given by \(\constructor{Vis}\) branching based on some type \(\type{A}\), for an event \(\term{a} : \typeformer{E}~\type{A}\). 
\begin{defn}
  We can define \(\type{R}\)-valued \(\typeformer{E}\)-event trees as the \texttt{M}-type defined by the container
  \begin{equation}
    \container{S} = \containerpair{\type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} \typeformer{E}~\type{A}}{\begin{cases}\empt & \mathtt{inl}~\term{r} \\ \type{A} & \mathtt{inr}~(\type{A},\term{e})\end{cases}}.
  \end{equation}
\end{defn}
\noindent The polynomial functor for this container is
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{(\term{x} : \type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} \typeformer{E}\,\type{A})} \begin{cases}\empt & \term{x} = \mathtt{inl}~\term{r} \\ \type{A} & \term{x} = \mathtt{inr}~(\type{A},\term{e})\end{cases} \rightarrow \type{X},
\end{equation}
which simplifies to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X})),
\end{equation}
and further
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X}).
\end{equation}
We get the diagram in \figref{tree-constructors} for the \(\functor{P}\)-coalgebra.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\constructor{Ret}"'] \ar[r,"\texttt{inl}"] & \type{R} + \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[d,"\function{in}"]  & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{Vis}"] \\
    & \typeformer{M}
  \end{tikzcd}
  \caption{Tree Constructors}
  \label{fig:tree-constructors}
\end{figure}
\noindent Again we can define \(\constructor{Ret}\) and \(\constructor{Vis}\) using the \(\function{in}\) function.

\subsection{ITrees}
\todo[inline]{Get the correct equivalence for ITrees (Part of project description?)}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types.
\begin{defn}
  We define the type of ITrees as the \texttt{M}-type given by the container
  \begin{equation}
    \container{S} = \containerpair{\type{R}+\unit+\sum_{\type{A}:\universe{\mathcal{U}}} (\typeformer{E}~\type{A})}{\begin{cases} \empt & \texttt{inl}~r \\ \unit & \texttt{inl}~(\texttt{inl}~\unitelem) \\ \type{A} & \texttt{inr}~(\texttt{inr}~(\type{A},\term{e})) \end{cases}}.
  \end{equation}
\end{defn}
\noindent The (reduced) polynomial functor for this container is
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{R} + \type{X} + \sum_{(\type{A} : \universe{\mathcal{U}})} (\typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X}))
\end{equation}
Giving us the diagram in \figref{ITree-constructors}, from which the constructors of the type can be defined using \(\function{in}\).
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[ddrr,"\constructor{Ret}"'] \ar[r,"\texttt{inl}\,\circ\,\texttt{inr}"] & \typeformer{M} + \type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} (\typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})) \ar[ddr,"\function{in}"] & & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[ll,"\texttt{inr}"'] \ar[ddl,"\constructor{Vis}"] \\
    & & \typeformer{M} \ar[ul,"\texttt{inl}\,\circ\,\texttt{inl}"'] \ar[d,"\constructor{Tau}"'] \\
    & & \typeformer{M}
  \end{tikzcd}
  \caption{ITree constructors}
  \label{fig:ITree-constructors}
\end{figure}

\section{Automaton}
An automaton is defined as a set of state \(\type{V}\) and an alphabet \(\type{\alpha}\) and a transition function \(\function{\delta} : \type{V} \rightarrow \type{\alpha} \rightarrow \type{V}\). This gives us the diagram in \figref{automaton}
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{V} \times (\type{V} \rightarrow \type{\alpha} \rightarrow \type{V}) \ar[dr,"build"'] \ar[r] & M & M \ar[dl,"step"] \ar[l] \\
    & M \ar[u]
  \end{tikzcd}
  \caption{automaton}
  \label{fig:automaton}
\end{figure}
\todo{Complete section about automaton}

\section{General rules for constructing \texttt{M}-types}
We want to create a calculus for defining coinductive types as \texttt{M}-types. We would like to be able to define a type that has a given set of constructor / destructors rules. If we for example is given the rule
\begin{equation}
  \vcenter{\infer{\constructor{ret}~a : \type{T}}{\term{a} : \type{A}}}
\end{equation}
we get that it corresponds to the M-type for the container \(\containerpairsimple{\type{A}}{\empt}\), while if we have something that produces an element of it self as
\begin{equation}
  \vcenter{\infer{\destructor{tl}~\term{a} : \type{T}}{\term{a} : \type{T}}}
\end{equation}
the container is \(\containerpairsimple{\unit}{\unit}\) \todo{why give some arguments or illustation showing these reasonings}. If we want a type with both these rules, then we just take the disjoint union of the two containers
\begin{equation}
  \containerpair{\type{A} + \unit}{\begin{cases} \empt & \mathtt{inl}~\term{a} \\ \unit & \mathtt{inr}~\unitelem \end{cases}}
\end{equation}
which is the delay type. We can also define some more involved constructors, that build on the type itself
\begin{equation}
  \vcenter{\infer{\constructor{node}~\term{a} : \type{T}}{\term{a} : \type{A} \rightarrow \type{T}}}
\end{equation}
has container \(\containerpair{\unit}{\type{A}}\). We can types with a given destructor
\begin{equation}
  \vcenter{\infer{\destructor{hd}~\term{a} : \type{A}}{\term{a} : \type{T}}}
\end{equation}
has container \(\containerpairsimple{\type{A}}{\empt}\), but this is the same as for \(\constructor{ret}\), and we do not always want both. The difference is how they are added to other constructors / destructors. Destructors are easily added together, take for example \(\destructor{hd}\) and \(\destructor{tl}\), \(\containerpairsimple{\type{A}}{\unit}\). In general adding containers \(\containerpair{\type{A}}{\typeformer{B}}\) and \(\containerpair{\type{C}}{\typeformer{D}}\) for two constructors together is done by
\begin{equation}
  \containerpair{\type{A} + \type{C}}{ \begin{cases} \typeformer{B}~\term{a} & \mathtt{inl}~\term{a} \\ \typeformer{D}~\term{c} & \mathtt{inr}~\term{c} \end{cases}}
\end{equation}
whereas adding containers for two destructors is done by \todo{Is this correct? Seems correct..}
\begin{equation}
  \containerpairsimple{\type{A} \times \type{C}}{\lambda\,(\term{a},\term{c}),~\typeformer{B}~\term{a} + \typeformer{D}~\term{c}}  
\end{equation}
however combining destructors and constructors is not as simple. Anything type \(\type{T}\) that is defined using a record (except higher inductive types), will also be definable as an \texttt{M}-type. Given a record, which is a list of fields \(\term{f}_1 : \type{F}_1,\term{f}_2 : \type{F}_2,\dots,\term{f}_n : \type{F}_n\), we can construct the \texttt{M}-types by the container
\begin{equation}
  \containerpairsimple{\type{F}_1 \times \type{F}_2 \times \dots \times \type{F}_n}{\empt}
\end{equation}
where each destructor \(\destructor{d_n} : \type{T} \rightarrow \type{F_n}\) for the field \(\term{f}_n\) will be defined as \(\destructor{d_n}~\term{t} = \pi_n~(\function{out}~\term{t})\). However fields in a coinductive container may depend on previous defined fields, as given by the general list of fields \(\term{f}_1 : \type{F}_1,\term{f}_2 : \typeformer{F}_2,\cdots,\term{f}_n : \typeformer{F}_n\), where each field depends on all the previous once, this can be defined by the container
\begin{equation}
  \containerpairsimple{\sum_{(\term{f}_1 : \type{F}_1)} \sum_{(\term{f_2} : \typeformer{F}_2)} \cdots \sum_{(\term{f}_{n-1} : \typeformer{F}_{n-1})}\typeformer{F}_n}{\empt}
\end{equation}
however, if any of the destructors/fields are non dependent, then the can be added as a product (\(\times\)) instead of a dependent product (\(\Sigma\)). Furthermore the fields may construct an element of the type of the record \(\type{T}\), however anything after that field cannot on it, since it will break the strictness requirements of the record / coinductive type. As an example let \(\type{f}_1\) be a type and \(\function{f_2}\) be the function with type \(\typeformer{F}_2 = \type{f}_1 \rightarrow (\type{f}_1 \rightarrow \type{A}) \rightarrow \mathtt{M}\), which by currying is equal to \(\type{f}_1 \times (\type{f}_1 \rightarrow \type{A}) \rightarrow \mathtt{M}\), we can then define by the container
\begin{equation}
  \containerpair{\sum_{(\type{f}_1 : \universe{\mathcal{U}})} \left(\unit \times \sum_{(\term{f}_3 : \typeformer{F}_3)} \cdots \sum_{(\term{f}_{n-1} : \typeformer{F}_{n-1})}\typeformer{F}_n\right)}{\lambda\,(\type{f}_1,\unitelem,\term{f}_3,\dots),\typeformer{F}_2}
\end{equation}
where \(\typeformer{F}_2\) have been moved to the last part of the container, we can even leave out the "\(\unit \times\)" from the container. The types of the field can also be dependent \(\typeformer{F_2} = (\term{x} : \type{f}_1) \rightarrow \typeformer{B}~\term{x} \rightarrow \mathtt{M}\), but again by currying we can get \(\typeformer{F_2} : \sum_{(\term{x} : \type{f}_1)} \typeformer{B}~\term{x} \rightarrow \mathtt{M}\) which is defined by the container
\begin{equation}
  \containerpair{\sum_{(\type{f}_1 : \universe{\mathcal{U}})} \sum_{(\term{f}_3 : \typeformer{F_3})} \cdots \sum_{(\term{f}_{n-1} : \typeformer{F_{n-1}})}\typeformer{F_n}}{\lambda\,(\type{f}_1,\term{f}_3,\dots),\sum_{\term{x} : \type{f}_1} (\typeformer{B}~\term{x})}
\end{equation}
so we would also expect that a type defined as a (coinductive) record is equal to the version defined as a \texttt{M}-type. \todo{which is the case, proof needed!}
\\ \\
But we run into problems if ... \todo{Problem cases} \todo{What differes from W and M types for closure of constructors / destructors?}

\section{Wacky \texttt{M}-type}
We end this chapter by showing of some wacky \texttt{M}-type, that utilizes the definition of the \texttt{M}-type to the fullest.
\begin{defn}
  We define a wacky \texttt{M}-type by the following container
  \begin{equation}
    \containerpair{\mathbb{N} + \mathbb{N}}{\begin{cases} \mathbb{N} & \mathtt{inl}~0 \\ \empt & \mathtt{inl}~\term{x} \land \term{x}~\text{is odd} \\ \empt & \mathtt{inr}~\term{x} \land \term{x}~\text{is even} \\ \unit & o.w. \end{cases}}
  \end{equation}
\end{defn}
this container gives the \texttt{M}-type and constructors / destructors shown in \figref{wacky-m-type}
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \mathbb{N} \ar[dr,"\constructor{odd}"',very near start] \ar[r,"\mathtt{inl} (2n+1)"] & M & \mathbb{N} \times M \ar[dl,"\destructor{step}",very near start] \ar[l,"o.w."] \\
    \mathbb{N} \ar[r,"\constructor{even}"'] \ar[ur,"\mathtt{inr}(2n)",very near start] & M \ar[u] & (\mathbb{N} \rightarrow M) \ar[l,"\constructor{inl\text{-}zero}"] \ar[ul,"\mathtt{inl}~0 \times f"',very near start]
  \end{tikzcd}
  \caption{wacky \texttt{M}-type}
  \label{fig:wacky-m-type}
\end{figure}
The type can be interpreted as a stream of coproducts of natural numbers, that terminates whenever it is the left injection and even, or the right injection and odd, and whenever the left injection is zero, it splits in a branches indexed by the natural numbers.
\\ \\
This show that we can define coinductive types, with rather complex structure.
\todo[inline]{define a wacky M-type showing some of the use of M-types / complexity}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Q\texttt{M}-types}
In this chapter we will introduce quotients, and show how to construct quotiented \texttt{M}-types which we call Q\texttt{M}-types. We show you can be constructed a QIIT that is equal to the Q\texttt{M}-type assuming axiom of choice. \todo{better introduction to chapter, and reference to main points}

\section{Quotienting and Constructors}
A very useful way to construct a specific type, is by constructing the "free" such type, and then quotienting with a relation. We can define quotiented types by using the higher inductive type defined by the constructors\\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.2\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{[}\,x\,\constructor{]} : \type{A} / \relation{\mathcal{R}}}{\term{x} : \type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.3\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{eq/}~\term{x}~\term{y}~\term{r} : \term{x} \equiv \term{y}}{\term{x}, \term{y} : \type{A} / \relation{\mathcal{R}} & \term{r} : \term{x}~\relation{\mathcal{R}}~\term{y}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{squash/} :\texttt{isSet}~(\type{A} / \relation{R})}{\strut}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
with recursor and eliminator defined as follows.
\begin{defn}[Recursor for quotient]
  \label{defn:quotient-recursor}
  For all elements \(\term{x}, \term{y} : \type{A}\), functions \(\function{f} : \type{A} \rightarrow \type{B}\) and relations \(\function{g} : \term{x}~\relation{R}~\term{y} \rightarrow \function{f}~\term{x} \equiv \function{f}~\term{y}\), then if \(\type{B}\) is a set, we get a function from \(\type{A} / \relation{R}\) to \(\type{B}\), defined by case as
  \begin{equation}
    \label{eq:quotient-recursor}
    \begin{aligned}
      &\function{rec}~\constructor{[}\,\term{a}\,\constructor{]} = \function{f}~\term{a} \\
      &\function{rec}~(\constructor{eq/}~\_~\_~\term{r}~i) = \function{g}~\term{r}~i \\
      &\function{rec}~(\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \term{B_{set}}~(\function{rec}~\term{a})~(\function{rec}~\term{b})~(\mathtt{ap}~\function{rec}~\pathterm{p})~(\mathtt{ap}~\function{rec}~\pathterm{q})~i~j
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}[Propositional eliminator for quotient]
  \label{defn:propositional-elimination-quotient}
  Given a proposition \(\typeformer{P} : \type{A} / \relation{R} \rightarrow \universe{\mathcal{U}}\) for quotients, that fulfills \(\function{P_{prop}} : \prod_{(\term{x} : \type{A} / \relation{R})} \typeformer{isProp}~(\typeformer{P}~\term{x})\), then if \(\function{f} : \prod_{(\term{a} : \type{A})} \typeformer{P}~\constructor{[}\,\term{a}\,\constructor{]}\) we get a function from \(\term{x} : \type{A} / \relation{R}\) to \(\typeformer{P}~\term{x}\), defined as
  \begin{equation}
    \begin{aligned}
      &\function{elimProp}~\constructor{[}\,\term{a}\,\constructor{]} = \function{f}~\term{a}\\
      &\function{elimProp}~(\constructor{eq/}~\term{a}~\term{b}~i) = \function{P_{prop}}~(\function{elimProp}~\term{a})~(\function{elimProp}~\term{b})~(\constructor{eq/}~\term{a}~\term{b})~i \\
      &\function{elimProp}~(\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \\
      &\qquad\function{isSet{\rightarrow}isSetDep}~(\function{isProp{\rightarrow}isSet} \circ \function{P_{prop}}) \\
      &\qquad\quad (\function{elimProp}~\term{a})~(\function{elimProp}~\term{b})~(\mathtt{ap}~\function{elimProp}~p)~(\mathtt{ap}~\function{elimProp}~q)\\
      &\qquad\quad (\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q})~i~j
    \end{aligned}
  \end{equation}
  where \(\function{isSet{\rightarrow}isSetDep}\) takes a function \(\prod_{\term{a} : \type{A}} \function{isSet}~(\typeformer{B}~\term{a})\) to the dependent version \(\function{isSetDep}~\type{A}~\typeformer{B}\). Using this eliminator we can to do propositional elimination of a quotient, by supplying the base case \(\typeformer{P}~\constructor{[}\,\term{a}\,\constructor{]}\).
\end{defn}
\noindent We can now construct some more interesting data types, by set quotienting \texttt{M}-types, which we call Q\texttt{M}-types, some examples follow in the following section. \todo{preserves the H-level} \todo{we cannot always lift the constructors of \texttt{M}-type to the quotiented type}

\section{Q\texttt{M}-types and Quotient inductive-inductive types (QIITs)}
In this section we will show some examples of quotiented \texttt{M}-types, and alternative ways of defining an equal type, but using quotient inductive-inductive types instead. A quotient inductive-inductive type (QIIT) is a type defined at the same time as a relation over that type. Furthermore QIITs are set truncated. We belive that every QM-types is equal (under the axiom of choice) to a QITT, however QIITs are more general than our Q\texttt{M}-types, so we cannot expect every QIIT to have a corresponding Q\texttt{M}-type. \todo{Go into more details!} % QIITs are HIITs that are set truncated. 

\subsection{Multiset}
In this subsection we define infinite trees, where the order of subtrees does not matter also known as multisets \cite{DBLP:QIIT}\cite{DBLP:tt-in-tt}\cite{DBLP:Constructing-QIITs}.
\begin{defn}
  We define \(\type{X}\)-valued \(\mathbb{N}\)-branching trees \(\typeformer{T}~\type{X}\) as the \texttt{M}-type defined by the container
  \begin{equation}
    \left(\type{X}+\unit, \begin{cases} \empt & \mathtt{inl}~\term{x} \\ \mathbb{N} & \mathtt{inr}~\unitelem \end{cases}\right)
  \end{equation}
\end{defn}
\noindent For which we get the constructors\\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.25\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{leaf}~\term{x} : \typeformer{T}~\type{X}}{\term{x} : \type{X}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{node}~\function{f} : \typeformer{T}~\type{X}}{\function{f} : \mathbb{N} \rightarrow \type{T}~\type{X}}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
We want to define trees where the permutation does not matter, that is multisets, we do this by ensuring the following rule is true
\begin{equation}
  \vcenter{\infer[\constructor{perm}]{\constructor{node}~\function{f} \equiv \constructor{node}~(\function{f} \circ \function{g})}{\function{f} : \mathbb{N} \rightarrow \typeformer{T}~\type{X} & \function{g} : \mathbb{N} \rightarrow \mathbb{N} & \mathtt{isIso}~\function{g}}}
\end{equation}
One way to define this type is as the QM-type given by quotienting \(\typeformer{T}~\type{X}\) by the relation \(\relation{\sim_T}\) defined by the constructors
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{leaf}}]{\constructor{leaf}~\term{x}~\relation{\sim}~\constructor{leaf}~\term{y}}{\term{x} \equiv \term{y}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{node}}]{\constructor{node}~\function{f}~\relation{\sim}~\constructor{node}~\function{g}}{\prod_{(n : \mathbb{N})} \function{f}~n~\relation{\sim}~\function{g}~n}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
\begin{equation}
  \vcenter{\infer[\constructor{\sim_{perm}}]{\constructor{node}~\function{f} \equiv \constructor{node}~(\function{f} \circ \function{g})}{\function{f} : \mathbb{N} \rightarrow \typeformer{T}~\type{X} & \function{g} : \mathbb{N} \rightarrow \mathbb{N} & \mathtt{isIso}~\function{g}}}
\end{equation}
Again we have the problem that we cannot lift the \(\constructor{node}\) to the quotiented type, without the use of the axiom of choice. However we can define multisets as a QIIT \(\typeformer{MS}~\type{X}\), with the constructors \(\constructor{leaf}, \constructor{node},\constructor{perm}\) and set quotiented \(\constructor{MS\text{-}isSet}\). These two ways of constructing a type for multisets are equal assuming the axiom of (countable) choice.
\begin{defn}
  There is a function from \(\typeformer{T}~\type{X}\) to \(\typeformer{MS}~\type{X}\)
  \begin{equation}
    \begin{aligned}
      &\function{T{\rightarrow}MS}~(\constructor{leaf}_{\typeformer{T}}~\term{x}) = \constructor{leaf}_{\typeformer{MS}}~\term{x} \\
      &\function{T{\rightarrow}MS}~(\constructor{node}_{\typeformer{T}}~\function{f}) = \constructor{node}_{\typeformer{MS}}~(\function{T{\rightarrow}MS} \circ \function{f})
    \end{aligned}
  \end{equation}
\end{defn}
This function takes weakly bisimilar objects to equal once.
\begin{lem}
  If \(\term{x}, \term{y} : \typeformer{T}~\type{X}\) are weakly bisimilar \(p : \term{x}~\relation{\sim_{T}}~\term{y}\) then \(\function{T{\rightarrow}MS}~\term{x} \equiv \function{T{\rightarrow}MS}~\term{y}\).
  \begin{proof}
    We do the proof by casing on the weak bisimilarity.
    \begin{equation}
      \begin{aligned}
        &\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}~(\constructor{\sim_{leaf}}~\pathterm{p}) = \mathtt{ap}~\constructor{leaf}_{\typeformer{MS}}~\pathterm{p} \\
        &\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}~(\constructor{\sim_{node}}~\function{k}) = \mathtt{ap}~\constructor{node}_{\typeformer{MS}}~(\mathtt{funExt}~(\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}} \circ \function{k})) \\
        &\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}~(\constructor{\sim_{perm}}~\function{f}~\function{g}~\term{e}) = \constructor{perm}~(\function{T{\rightarrow}MS} \circ \function{f})~\function{g}~\term{e}
      \end{aligned}
    \end{equation}
  \end{proof}
\end{lem}
\noindent With this lemma, we can lift the function \(\function{T{\rightarrow}MS}\) to the quotient.
\begin{defn}
  There is a function \(\function{T/{\sim}{\rightarrow}MS}\) from \(\typeformer{T}~\type{X}/\relation{\sim_{T}}\) to \(\typeformer{MS}~\type{X}\), defined using the recursor for quotients defined in \defref{quotient-recursor}, with \(\function{f} = \function{T{\rightarrow}MS}\) and \(\function{g} = \function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}\) and \(\typeformer{MS}\) is a set by \(\constructor{MS\text{-}isSet}\)
\end{defn}
\begin{lem}
  \label{lem:weak-bisim-to-eq-multiset}
  Given an equality \(\function{T{\rightarrow}MS}~\term{x} \equiv \function{T{\rightarrow}MS}~\term{y}\) then \(\term{x}~\relation{\sim_{T}}~\term{y}\).
  \begin{proof}
    If \(x\) and \(y\) are leafs with values \(a\) and \(b\) then \(a \equiv b\) by the injectivity of the constructor \(\constructor{leaf}_{\typeformer{MS}}\), making a bisimilarity using \(\sim_{leaf}\). If \(x\) and \(y\) are nodes defined by functions \(f\) and \(g\), then by the injectivity of the constructor \(\constructor{node}_{\typeformer{MS}}\), we get \(\prod_{(n : \mathbb{N})} \function{f}~n \equiv \function{g}~n\) and by induction we get \(\prod_{(n : \mathbb{N})} \function{f}~n~\relation{\sim_{T}}~\function{g}~n\), making us able to use \(\constructor{\sim_{node}}\) to construct the bisimilarity. We do not get any other equalities, since \(\constructor{leaf}_{\typeformer{MS}}\) and \(\constructor{node}_{\typeformer{MS}}\) are disjoint.
  \end{proof}
\end{lem}
\begin{lem}
  The function \(\function{T/{\sim}{\rightarrow}MS}\) is injective, meaning \(\function{T/{\sim}{\rightarrow}MS}~\ter{x} \equiv \function{T/{\sim}{\rightarrow}MS}~\term{y}\) implies \(\term{x} \equiv \term{y}\).
  \begin{proof}
    We show injectivity by doing propositional elimination defined in \defref{propositional-elimination-quotient}, with
    \begin{equation}
      \typeformer{P} = (\lambda\,\term{x},~\function{T/{\sim}{\rightarrow}MS}~\term{x} \equiv \function{T/{\sim}{\rightarrow}MS}~\term{y} \rightarrow \term{x} \equiv \term{y})
    \end{equation}
    which is a proposition for all \(\term{x}\) by \(\function{P_{prop}} = \lambda\,\term{x},~\function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\term{x}~\term{y})\). We do it twice, first for \(\term{x}\) and then for \(\term{y}\) where we define \(\typeformer{P}\) and \(\function{P_{prop}}\) similarly, but with \(x = \constructor{[}\,a\,\constructor{]}\) since it has already been propositionally eliminated. 
    \begin{equation}
      \begin{aligned}
        &\function{elimProp}~(\lambda\,\term{a},~\function{elimProp} (\lambda\,\term{b},~\constructor{eq/}~\term{a}~\term{b} \circ \function{T{\rightarrow}MS\text{-}{\equiv}{\rightarrow}{\sim}}~\term{a}~\term{b})~\term{y})~\term{x}
      \end{aligned}
    \end{equation}
    where \(\function{T{\rightarrow}MS\text{-}{\equiv}{\rightarrow}{\sim}}\) is \lemref{weak-bisim-to-eq-multiset}.
  \end{proof}
\end{lem}
\begin{lem}
  The function \(\function{T/{\sim}{\rightarrow}MS}\) is surjective \((\prod_{(\term{b} : \typeformer{MS})}, \| \Sigma_{(\term{x} : \typeformer{T})}~\function{T/{\sim}{\rightarrow}MS}~\term{x} \equiv \term{b} \|)\), assuming the axiom of choice.
  \begin{proof}
    We only need to look at the point constructors of \(\typeformer{MS}\). For the leaf case, we have the simple equality \(\function{T/{\sim}{\rightarrow}MS}~\constructor{[}\,\constructor{leaf}_{\typeformer{T}}~\term{x}\,\constructor{]} \equiv \constructor{leaf}_{\typeformer{MS}}~\term{x}\). For the node case with \(\constructor{node}~\function{f}\) then by induction, surjection of \(\constructor{[}\,\cdot\,\constructor{]}\) and the axiom of choice, we get \(\function{g} : \mathbb{N} \rightarrow \typeformer{T}~\type{X}\) such that \(\prod_{(n : \mathbb{N})} \,\function{T/{\sim}{\rightarrow}MS}~\constructor{[}\,\function{g}~n\,\constructor{]} \equiv \function{f}~n\), making \(\function{T/{\sim}{\rightarrow}MS}~\constructor{[}\,\constructor{node}~\function{g}\,\constructor{]} \equiv \constructor{node}~\function{f}\).
  \end{proof}
\end{lem}
\begin{thm}
  The is an equality between the types \(\typeformer{T}~\type{X}/\relation{\sim_{T}}\) and \(\typeformer{MS}~\type{X}\), assuming the axoim of choice.
  \begin{proof}
    Since the function \(\function{T/{\sim}{\rightarrow}MS}\) is injective and surjective, it becomes an equality.
  \end{proof}
\end{thm}

\subsection{Partiality monad}
In this subsection we will define the partiality monad (see below) and show that (assuming the axiom of countable choice) the delay monad quotiented by weak bisimilarity.
\begin{defn}[Partiality Monad]
  A simple example of a quotient inductive-inductive type is the partiality monad \((-)_\bot\) over a type \(\type{R}\), defined by the constructors\\[-9mm]
  \begin{center}
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\type{R}_\bot : \universe{\mathcal{U}}}{\strut}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\bot} : \type{R}_\bot}{\strut}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\eta}~\term{a} : \type{R}_\bot}{\term{a} : \type{R}}}
      \end{equation}
    \end{minipage}
  \end{center}
  and a relation \((\cdot~\relation{\sqsubseteq_{\bot}}~\cdot)\) indexed twice over \(\type{R}_\bot\), with properties\\[-9mm] \todo{Should I define what it means to be an ordering relation separately, and just say the relation here is an instance of that? (Generalize?)}
  \begin{center}
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\bigsqcup}~(\function{s},\function{b}) : \type{R}_\bot}{\function{s} : \mathbb{N} \rightarrow \type{R}_\bot & \function{b} : \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\function{s}_{n+1} }}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\alpha_{\bot}}~\term{p}~\term{q} : \term{x} \equiv \term{y}}{\term{x},\term{y} : \type{R}_\bot & \term{p} : \term{x}~\relation{\sqsubseteq_{\bot}}~\term{y} & \term{q} : \term{y}~\relation{\sqsubseteq_{\bot}}~\term{x}}}
      \end{equation}
    \end{minipage}
  \end{center}
  \strut\\[-15mm]
  \begin{center}
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sqsubseteq_{refl}}]{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{x}}{\term{x} : \type{R}_\bot}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.35\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sqsubseteq_{trans}}]{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{z}}{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{y} & \term{y}~\relation{\sqsubseteq_{\bot}}~\term{z}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sqsubseteq_{never}}]{\constructor{\bot}~\relation{\sqsubseteq_{\bot}}~\term{x}}{\term{x} : \type{R}_\bot}}
      \end{equation}
    \end{minipage}
  \end{center}
  \strut\\[-15mm]
  \begin{center}
    \hfill
    \begin{minipage}{0.50\linewidth}
      \begin{equation}
        \vcenter{\infer{\prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\bigsqcup(\function{s},\function{b})}{\function{s} : \mathbb{N} \rightarrow \type{R}_\bot & \function{b} : \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\function{s}_{n+1} }}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\linewidth}
      \begin{equation}
        \vcenter{\infer{\bigsqcup(\function{s},\function{b})~\relation{\sqsubseteq_{\bot}}~\term{x}}{\prod_{(n:\mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\term{x}}}
      \end{equation}
    \end{minipage}
  \end{center}
  and finally set truncated
  \begin{equation}
    \vcenter{\infer[\constructor{(-)_\bot\text{-}isSet}]{\term{p} \equiv \term{q}}{\term{p} , \term{q} : \term{x}~\relation{\sqsubseteq_{\bot}}~\term{y}}}
  \end{equation}
\end{defn}

\subsubsection{Delay monad to Sequences}
\todo{introduction to subsection}
\begin{defn}
  We define
  \begin{equation}
    \typeformer{Seq}_{\type{R}} = \sum_{(\function{s} : \mathbb{N} \rightarrow \type{R} + \unit)} \function{isMon}~\function{s}
  \end{equation}
  where
  \begin{equation}
    \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} (\function{s}_n \equiv \function{s}_{n+1})  + ((\function{s}_n \equiv \mathtt{inr}~\unitelem) \times (\function{s}_{n+1} \not\equiv \mathtt{inr}~\unitelem))
  \end{equation}
  meaning a sequences is \(\mathtt{inr}~\unitelem\) until it reaches a point where it switches to \(\mathtt{inl}~\term{r}\) for some value \(\term{r}\). There are also the special cases of already terminated, meaning only \(\mathtt{inl}~\term{r}\) and never teminating meaning only \(\mathtt{inr}~\unitelem\).
\end{defn}
\noindent For each index in a sequence, the element at that index \(\function{s}_n\) is either not terminated \(\function{s}_n \equiv \mathtt{inr}~\unitelem\), which we denote as \(\function{s}_n \uparrow_{\type{R} + \unit}\), or it is terminated \(\function{s}_n \equiv \mathtt{inl}~\term{r}\) with some value \(r\), denoted by \(\function{s}_n \downarrow_{\type{R} + \unit} \term{r}\) or just \(\function{s}_n \downarrow_{\type{R} + \unit}\) to mean \(\function{s}_n \not\equiv \mathtt{inr}~\unitelem\). Thus we can write \(\function{isMon}\) as
\begin{equation}
  \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} (\function{s}_n \equiv \function{s}_{n+1})  + ((\function{s}_n \uparrow_{\type{R} + \unit}) \times (\function{s}_{n+1} \downarrow_{\type{R} + \unit}))
\end{equation}
We also introduce notation for the two special cases of sequences given above
\begin{equation}
  \function{now}_{Seq}~\term{r} = (\lambda\,\_, \mathtt{inl}~\term{r}) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl})
\end{equation}
\begin{equation}
  \constant{never}_{Seq} = (\lambda\,\_, \mathtt{inr}~\unitelem) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl})
\end{equation}
\todo[inline]{Some comment about decidable equivalence needed to show that \(\function{s}_{n+1} \not\equiv \mathtt{inr}~\unitelem\)}
\begin{defn}
  We can shift a sequence \((\function{s},\function{q})\) by inserting an element (and an equality) \((\term{z_s},\term{z_q})\) at \(n = 0\),
  \begin{equation}
    \function{shift}~(\function{s} , \function{q})~(\term{z_s} , \term{z_q}) = \begin{cases} \term{z_s} & n = 0 \\ \function{s}_m & n = m + 1 \end{cases} , \begin{cases} \term{z_q} & n = 0\\ \function{q}_m & n = m + 1 \end{cases},
  \end{equation}
\end{defn}
\begin{defn}
  We can unshift a sequence by removing the first element of the sequence
  \begin{equation}
    \begin{aligned}
      \function{unshift}&~(\function{s} , \function{q}) = \function{s} \circ \constructor{succ} , \function{q} \circ \constructor{succ}.
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  The function
  \begin{equation}
    \function{shift\text{-}unshift}~(\function{s},\function{q}) = \function{shift}~(\function{unshift}~(\function{s},\function{q}))~(\function{s}_0,\function{q}_0)
  \end{equation}
  is equal to the identity function.
  \begin{proof}
    Unshifting a value followed by a shift, where we reintroduce the value we just remove, gives the sequence we started  with.
  \end{proof}
\end{lem}
\begin{lem}
  The function
  \begin{equation}
    \function{unshift\text{-}shift}~(\function{s},\function{q})=\function{unshift}~(\function{shift}~(\function{s},\function{q})~\_)
  \end{equation}
  is equal to the identity function.
  \begin{proof}
    If we shift followed by an unshift, we just introduce a value to instantly remove it, meaning the value does not matter.
  \end{proof}
\end{lem}
\noindent We now define an equivalence between \(\typeformer{delay}~\type{R}\) and \(\typeformer{Seq}_{\type{R}}\), where \(\constructor{later}\) are equivalent to shifts, and \(\constructor{now}~\term{r}\) is equivalent terminated sequence with value \(\term{r}\). We do this by defining equivalence functions, and the left and right identities.
\begin{lem}[\(\constant{inl{\not\equiv}inr}\)]
  For any two elements \(\term{x} = \mathtt{inl}~\term{a}\) and \(\term{y} = \mathtt{inr}~\term{b}\) then \(\term{x} \not\equiv \term{y}\).
  \begin{proof}
    The constructors \texttt{inl} and \texttt{inr} are disjoint, so there does not exists a path between them, meaning constructing one is a contradiction.
  \end{proof}
\end{lem}
\begin{defn}
  We define a function from \(\typeformer{Delay}~\type{R}\) to \(\typeformer{Seq}_{\type{R}}\)
  \begin{equation}
    \begin{aligned}
      \function{Delay{\rightarrow}Seq}&~(\constructor{now}~\term{r}) = \function{now}_{Seq}~\term{r} \\
      \function{Delay{\rightarrow}Seq}&~(\constructor{later}~\term{x}) = \\[-3mm]
      & \strut\hspace{-8mm}\function{shift}~(\function{Delay{\rightarrow}Seq}~\term{x})~\left(\mathtt{inr}~\unitelem , \begin{cases} \mathtt{inr}~(\mathtt{refl} , \constant{inl{\not\equiv}inr}) & \term{x} = \constructor{now}~\_ \\ \mathtt{inl}~\mathtt{refl} & \term{x} = \constructor{later}~\_ \end{cases}\right)
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  We define function from \(\typeformer{Seq}_{\type{R}}\) to \(\typeformer{Delay}~\type{R}\)
    \begin{equation}
      \begin{aligned}
        \function{Seq{\rightarrow}Delay}&~(\function{s} , \function{q}) = \begin{cases} \constructor{now}~\term{r} & \function{s}_0 = \mathtt{inl}~\term{r} \\ \constructor{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s} , \function{q}))) & \function{s}_0 = \mathtt{inr}~\unitelem \end{cases}
      \end{aligned}
    \end{equation}
\end{defn}
\begin{thm}
  The type \(\typeformer{Seq}_{\type{R}}\) is equal to \(\typeformer{Delay}~\type{R}\)
  \begin{proof}  
    We define right and left identity, saying that for any sequence \((\function{s},\function{q})\), we get
    \begin{equation}
      \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{s},\function{q})) \equiv (\function{s},\function{q})
    \end{equation}
    defined by cases analysis on \(\function{s}_0\), if \(\function{s}_0 = \mathtt{inl}~\term{r}\) then we need to show
    \begin{equation}
      \function{now}_{Seq}~\term{r} \equiv (\function{s},\function{q})
    \end{equation}
    This is true, since \((\function{s},\function{q})\) is a monotone sequence and \(\mathtt{inl}~\term{r}\) is the top element of the order, then all elements of the sequence are \(\mathtt{inl}~\term{r}\). If \(\function{s}_0 = \mathtt{inr}~\unitelem\) then, we need to show
    \begin{equation}
      \function{shift}~(\function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s},\function{q}))))~(\mathtt{inr}~\unitelem,\_) \equiv (\function{s},\function{q})
    \end{equation}
    by the induction hypothesis we get
    \begin{equation}
      \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s},\function{q}))) \equiv \function{unshift}~(\function{s},\function{q})
    \end{equation}
    since shift and unshift are inverse, we get the needed equality.
    \todo[inline]{Shift takes two arguemnts, either clarify that its shift' that inserts inr tt or ...}
    For the left identity, we need to show that for any delay monad \(\term{t}\) we get
    \begin{equation}
      \function{Seq{\rightarrow}Delay}~(\function{Delay{\rightarrow}Seq}~\term{t}) \equiv \term{t}
    \end{equation}
    defined by case analysis on \(\term{t}\), if \(\term{t} = \constructor{now}~a\) then the equality is \(\mathtt{refl}\). If \(\term{t} = \constructor{later}~\term{x}\) then we need to show
    \begin{equation}
      \constructor{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{shift}~(\function{Delay{\rightarrow}Seq}~x))) \equiv \constructor{later}~x
    \end{equation}
    By unshift and shift being inverse, and the induction hypothesis we get the wanted equality. Since we are able to define a left and right identity function, we get the wanted equality.
  \end{proof}
\end{thm}
\begin{cor}
  The types \(\typeformer{Delay}/\sim\) and \(\typeformer{Seq}/\sim\) are equal.
  \begin{proof}
    We show that if \(a~\relation{\sim_{delay}}~b\) then \(\function{Delay{\rightarrow}Seq}~a~\relation{\sim_{Seq}}~\function{Delay{\rightarrow}Seq}~b\), \todo{Show this}
    \\ \\
    and we show if \(x~\relation{\sim_{Seq}}~y\) then \(\function{Seq{\rightarrow}Delay}~x~\relation{\sim_{Seq}}~\function{Seq{\rightarrow}Delay}~y\), \todo{Show this}
  \end{proof}
\end{cor}

\subsubsection{Sequence to Partiality Monad}
In this section we will show that assuming the "Axiom of Countable Choice", we get an equivalence between sequences and the partiality monad.
\begin{defn}[Sequence Termination]
  The following relations says that a sequence \((\function{s},\function{q}) : \typeformer{Seq}_{\type{R}}\) terminates with a given value \(\term{r} : \type{R}\),
  \begin{equation}
    (\function{s},\function{q})~\relation{\downarrow_{\mathtt{Seq}}}~\term{r} = \sum_{(n : \mathbb{N})} \function{s}_n \downarrow_{\type{R} + \unit} \term{r}.
  \end{equation}
\end{defn}
\begin{defn}[Sequence Ordering]
  \begin{equation}
    (\function{s},\function{q})~\relation{\sqsubseteq_{\mathtt{Seq}}}~(\function{t},\function{p}) = \prod_{(\term{a} : \type{R})} \left(\|\function{s}~\relation{\downarrow_{\mathtt{Seq}}}~\term{a}\| \rightarrow \| \function{t}~\relation{\downarrow_{\mathtt{Seq}}}~\term{a}\|\right)
  \end{equation}
  where \(\| \cdot \|\) is propositional truncation.
\end{defn}
\begin{defn} There is a conversion from \(\type{R} + \unit\) to the partiality monad \(\type{R}_\bot\)
  \begin{equation}
    \begin{aligned}
      &\function{Maybe{\rightarrow}(-)_\bot}~(\mathtt{inl}~\term{r}) = \constructor{\eta}~\term{r} \\
      &\function{Maybe{\rightarrow}(-)_\bot}~(\mathtt{inr}~\unitelem) = \constructor{\bot}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}[Maybe Ordering]
  \label{eq:maybe-order}
  Given some \(x,y : \type{R} + \unit\), the ordering relation is defined as
  \begin{equation}
    \term{x}~\relation{\sqsubseteq_{\type{R} + \unit}}~\term{y} = (\term{x} \equiv \term{y}) + ((\term{x}  \downarrow_{\type{R} + \unit}) \times (\term{y} \uparrow_{\type{R} + \unit}))
  \end{equation}
\end{defn}
\noindent This ordering definition is basically \(\function{isMon}\) at a specific index, so we can again rewrite \(\function{isMon}\) as
\begin{equation}
  \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\type{R} + \unit}}~\function{s}_{n+1}
\end{equation}
This rewriting confirms that if \(\function{isMon}~\function{s}\), then \(\function{s}\) is monotone, and therefore a sequence of partial values\todo{there exists non-monotone sequences, it just follows our definition of a sequence.}.
\begin{lem}
  The function \(\function{Maybe{\rightarrow}(-)_\bot}\) is monotone, that is, if \(\term{x}~\relation{\sqsubseteq_{\type{A} + \unit}}~\term{y}\), for some \(\term{x}\) and \(\term{y}\), then \((\function{Maybe{\rightarrow}(-)_\bot}~\term{x})~\relation{\sqsubseteq_{\bot}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{y})\).
  \begin{proof}
    We do the proof by case.
    \begin{equation}
      \begin{aligned}
        &\function{Maybe{\rightarrow}(-)_\bot\text{-}mono}~(\function{inl}~\pathterm{p}) = \\[-1mm]
        &\qquad\qquad \mathtt{subst}~(\lambda\,\term{a},~\function{Maybe{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Maybe{\rightarrow}(-)_\bot}~\term{a})~\pathterm{p}~(\constructor{\sqsubseteq_{refl}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{x})) \\[1mm]
        &\function{Maybe{\rightarrow}(-)_\bot\text{-}mono}~(\function{inr}~(\pathterm{p}, \_)) = \\[-1mm]
        &\qquad\qquad \mathtt{subst}~(\lambda\,\term{a},~\function{Maybe{\rightarrow}(-)_\bot}~\term{a}~\relation{\sqsubseteq_{\bot}}~\function{Maybe{\rightarrow}(-)_\bot}~\term{y})~\sym{\pathterm{p}}~(\constructor{\sqsubseteq_{never}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{y}))
      \end{aligned}
    \end{equation}
  \end{proof}
\end{lem}
\begin{defn}
  There is a function taking a sequence to an increasing sequence \todo{What is an increasing sequence ??, this is not defined anywhere!!}
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}incSeq} \\
      &\function{Seq{\rightarrow}incSeq}~(\function{g} , \function{q}) = \function{Maybe{\rightarrow}(-)_\bot} \circ \function{g} , \function{Maybe{\rightarrow}(-)_\bot\text{-}mono} \circ \function{q}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  There is a function taking a sequence to the partiality monad
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}(-)_\bot} : \typeformer{Seq}_{\type{A}} \rightarrow \type{A}_{\bot} \\
      &\function{Seq{\rightarrow}(-)_\bot}~(\function{g},\function{q}) = \bigsqcup \circ~\function{Seq{\rightarrow}incSeq}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  The function \(\function{Seq{\rightarrow}(-)_\bot}\) is monotone. 
  \begin{equation}
    \function{Seq{\rightarrow}(-)_\bot\text{-}mono} : \typeformer{isSet} \type{A} \rightarrow (\term{x}~\term{y} : \typeformer{Seq}_{\type{A}}) \rightarrow \term{x}~\relation{\sqsubseteq_{seq}}~\term{y} \rightarrow \function{Seq{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}
\end{equation}
  \begin{proof}
    Given two sequences, if one is smaller than the another, then the least upper bounds of each sequence respect the ordering. \todo{should this be formalized entirely, or should there just be a comment about monotonicity? Does not seem relevant? (There is alot of work here..)}
  \end{proof}
\end{lem}
\begin{lem}
  If two sequences \(\term{x},\term{y}\) are weakly bisimular, then \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\)
  \begin{proof}
    \todo{describe instead of proof term!}
    \begin{equation}
      \begin{aligned}
        &\function{Seq{\rightarrow}(-)_\bot\text{-}{\approx}{\rightarrow}{\equiv}}~\term{A_{set}}~\term{x}~\term{y}~(\term{p} , \term{q}) = \\
        &\qquad\qquad\qquad\constructor{\alpha_{\bot}}~(\function{Seq{\rightarrow}(-)_\bot\text{-}mono}~\term{A_{set}}~\term{x}~\term{y}~\term{p})~(\function{Seq{\rightarrow}(-)_\bot\text{-}mono}~\term{A_{set}}~\term{y}~\term{x}~\term{q})
      \end{aligned}
    \end{equation}
  \end{proof}
\end{lem}
\noindent The recursor for quotients \defref{quotient-recursor} allows us to lift the function \(\function{Seq{\rightarrow}(-)_\bot}\) to the quotient
\begin{defn}
  \label{eq:QuotientedSeqToPartialityMonad}
  We can define a function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) from \(\typeformer{Seq}_{\type{A}}\) to \(\type{A}_{\bot}\), where \(\term{A_{set}} : \typeformer{isSet}~\type{A}\) as
  \begin{equation}
    \function{Seq/{\sim}{\rightarrow}(-)_\bot} = \function{rec}~\function{Seq{\rightarrow}(-)_\bot}~(\function{Seq{\rightarrow}(-)_\bot\text{-}{\approx}{\rightarrow}{\equiv}}~\term{A_{set}})~\constructor{(-)_\bot\text{-}isSet}
  \end{equation} 
\end{defn}
\begin{lem}
  \label{eq:injectivity-lemma}
  Given two sequences \(\term{s}\) and \(\term{t}\), if \(\function{Seq{\rightarrow}(-)_\bot}~\term{s} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{t}\), then \(\term{s}~\relation{\sim_{seq}}~\term{t}\).
  \begin{proof}
    We can reduce the burden of the proof, since
    \begin{equation}
      \term{s}~\relation{\sim_{seq}}~\term{t} = \left(\prod_{(\term{r} : \type{R})} \| \term{x}~\relation{\downarrow_{seq}}~\term{r} \| \rightarrow \| \term{y}~\relation{\downarrow_{seq}}~\term{r} \|\right) \times \left(\prod_{(\term{r} : \type{R})} \| \term{y}~\relation{\downarrow_{seq}}~\term{r} \| \rightarrow \| \term{x}~\relation{\downarrow_{seq}}~\term{r} \|\right)
    \end{equation}
    so we can just show one part and get the other by symmetry. We assume \(\| \term{x}~\relation{\downarrow_{seq}}~\term{r} \|\), to show \(\| \term{y}~\relation{\downarrow_{seq}}~\term{r} \|\). By the mapping property of propositional truncation, we reduce the proof to defining a function \(\term{x}~\relation{\downarrow_{seq}}~\term{r} \rightarrow \term{y}~\relation{\downarrow_{seq}}~\term{r}\). Since \(\term{x}~\relation{\downarrow_{seq}}~\term{r}\), then \(\constructor{\eta}~\term{r}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{x}\), but we have assumed \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\), so we get \(\constructor{\eta}~\term{r}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}\), and thereby \(\term{y}~\relation{\downarrow_{seq}}~\term{r}\).
  \end{proof}
\end{lem}
\begin{lem}
  The function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is injective.
  \begin{proof}
    We use propositional elimination of quotients \defref{propositional-elimination-quotient} \todo{Should this be formalized?} to show the injectivity, meaning for all \(\term{x}~\term{y} : \typeformer{Seq}_{\type{R}} / \relation{\sim_{seq}}\) we get \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{y} \rightarrow \term{x} \equiv \term{y}\). We start by eliminating \(\term{x}\), followed by elimination of \(y\), this gives us the proof term \todo{Convert to text, instead of a proof term!?}
    \begin{equation}
      \begin{aligned}
        &\function{elimProp} \\
        &\quad (\lambda\,\term{a},~\function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{a} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{y} \rightarrow \term{a} \equiv \term{y}) \\
        &\quad (\lambda\,\term{a},~\function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\term{a}~\term{y})) \\
        &\quad (\lambda\,\term{a},~\function{elimProp} \\
        &\qquad\qquad\quad (\lambda\,\term{b},~\function{Seq{\rightarrow}(-)_\bot}~\term{a} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{b} \rightarrow \constructor{[}\,\term{a}\,\constructor{]} \equiv \term{b}) \\
        &\qquad\qquad\quad (\lambda\,\term{b},~\function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\constructor{[}\,\term{a}\,\constructor{]}~\term{b})) \\
        &\qquad\qquad\quad (\lambda\,\term{b},~(\constructor{eq/}~\term{a}~\term{b}) \circ (\function{Seq{\rightarrow}(-)_\bot\text{-}isInjective}~\term{a}~\term{b})) \\
        &\qquad\qquad\quad y) \\
        &\quad x
      \end{aligned}
    \end{equation}
    where \(\function{Seq{\rightarrow}(-)_\bot\text{-}isInjective}\) is \eqref{eq:injectivity-lemma}, 
  \end{proof}
\end{lem}
\begin{lem}
  \label{eq:constant-sequence-equality}
  For all constant sequences \(\term{s}\), where all elements have the same value \(\term{v}\), we get \(\function{Seq{\rightarrow}(-)_\bot}~\term{s} \equiv \function{Maybe{\rightarrow}(-)_\bot}~\term{v}\).
  \begin{proof}
    The left side of the equality reduces to \(\function{Maybe{\rightarrow}(-)_\bot}\) applied on the least upper bound of the constant sequence, which is exactly the right hand side of the equality.
  \end{proof}
\end{lem}
\begin{lem}
  Assuming countable choice, the function \(\function{Seq{\rightarrow}(-)_\bot}\) is surjective
  \todo[inline]{describe countable choice (and why it is needed!)}
  \begin{proof}
    We do the proof by case \todo{describe what it means to do the surjective proof by case!} on \(\type{R}_{\bot}\), if it is \(\constructor{\eta}~r\) or \(\constructor{never}\), we convert them to the sequences \(\function{now}_{seq}~\term{r}\) and \(\constant{never}_{seq}\) respectively, then we are done by \eqref{eq:constant-sequence-equality}. For the least upper bound \(\constructor{\bigsqcup} (\function{s},\function{b})\), we translate to the (increasing) sequence, defined by \((\function{s},\function{b})\) \todo{more precise description!}. \todo{Complete the rest of the proof!}
  \end{proof}
\end{lem}
\begin{lem}
  Assuming countable choice, the function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is surjective
  \begin{proof}
    \todo{Complete proof}
  \end{proof}
\end{lem}
\begin{thm}
  Assuming countable choice, we get an equivalence between sequences and the partiality monad.
  \begin{proof}
 The function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is injective and surjective assuming countable choice, meaning we get an equivalence, since we are working in hSets.
\end{proof}
\end{thm}

\todo[inline]{Building the weak bisimulation on the M-type as a M-type - Is this possible? Yes! Should it be included?}
\todo[inline]{Building the Partiality Monad as a limit (Dialgebra?) - Is this possible?}

\section{QM-types}
\label{ch:QM-types}
We want to define what a Q\texttt{M}-type means in general, we draw inspiration from QW-types \cite{DBLP:Constructing-QIITs}, quotient containers \cite{DBLP:quotient-container} and the LEAN paper "Data types as quotients of polynomial functors" \cite{DBLP:QM-lean}. From what we have seen in the previous section, equality construction between QM-types and QIITs are given as
\begin{itemize}
\item A function \function{QM{\rightarrow}QIIT} from QM to QIIT
\item A proof \(\function{QM{\rightarrow}QIIT\text{-}{\sim}{\rightarrow}{\equiv}}\) that \(\term{x}~\relation{\sim_{QM}}~\term{y}\) implies \(\function{QM{\rightarrow}QIIT}~\term{x} \equiv \function{QM{\rightarrow}QIIT}~\term{y}\)
\item Lifting \(\function{QM{\rightarrow}QIIT}\) to \(\function{QM/{\sim}{\rightarrow}QIIT}\) using the quotient recursor with \(\function{QM{\rightarrow}QIIT\text{-}{\sim}{\rightarrow}{\equiv}}\) and \(\constructor{QIIT\text{-}isSet}\)
\item Showing injectivity by using propositional elimination of the quotient together with the inverse of \(\function{QM{\rightarrow}QIIT\text{-}{\sim}{\rightarrow}{\equiv}}\), namely \(\function{QM{\rightarrow}QIIT\text{-}injective}\) saying that \(\function{QM{\rightarrow}QIIT}~\term{x} \equiv \function{QM{\rightarrow}QIIT}~\term{y}\) implies \(\term{x}~\relation{\sim_{QM}}~\term{y}\).
\item Lastly we show surjectivity by induction using the eliminator of QIIT and the axiom of choice. Another thing that comes into play is the surjectivity of \(\constructor{[}\,\cdot\,\constructor{]}\).
\end{itemize}
Lets try this strategy in general, lets say we are given an \texttt{M}-type and weak bisimulation \(\sim_{M}\) on that type. We then define a QIIT with all the constructors of the M-type, given as 

\todo[inline]{Cofree Coalgebra / Dialgebra -- Is this relevant? }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Properties of M-types?}
\section{Closure properties of \texttt{M}-types}
We want to show that \texttt{M}-types are closed under simple operations, we start by looking at the product.
\subsection{Product of \texttt{M}-types}
We start with containers and work up to \texttt{M}-types.
\begin{defn}
  The product of two containers is defined as \cite{ContainerRules}
  \begin{equation}
    \containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}} \equiv \containerpair{\type{A} \times \type{C}}{\lambda\,(\term{a} , \term{c}), \typeformer{B}~\term{a} \times \typeformer{D}~\term{c}}.
  \end{equation}
\end{defn}
\noindent We can lift this rule, through the diagram in \figref{container-products}, used to define \texttt{M}-types.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{A} & \type{A} \times \type{C} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \type{C} \\
    \functor{P} (\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}) \ar[u,"\pi_1"'] & \functor{P}(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}) \ar[l] \ar[r] \ar[u,"\pi_1"'] & \functor{P} (\typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}}) \ar[u,"\pi_1"'] \\
    \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}} \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] & \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}} \ar[l] \ar[r] \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] & \typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}} \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] \\
    {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^n~\unit \ar[d,"\function{\pi}_{(n)}"] & {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \ar[l] \ar[r] \ar[d,"\function{\pi}_{(n)}"] & {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \ar[d,"\function{\pi}_{(n)}"] \\
    \vdots \ar[d,"\function{\pi}_{(1)}"] & \vdots \ar[d,"\function{\pi}_{(1)}"] & \vdots \ar[d,"\function{\pi}_{(1)}"] \\
    \functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}~\unit \ar[d,"\function{\pi}_{(0)}"] & \functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}~\unit \ar[l] \ar[r] \ar[d,"\function{\pi}_{(0)}"] & \functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}~\unit \ar[d,"\function{\pi}_{(0)}"] \\
    \unit & \unit \ar[l,"\texttt{refl}"] \ar[r,"\texttt{refl}"'] & \unit
  \end{tikzcd}
  \caption{Diagram for products of chains}
  \label{fig:container-products}
\end{figure}
\begin{thm}
  For any \(n : \mathbb{N}\) the following is true
  \begin{equation}
    {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^n~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^n~\unit. \label{eq:polynomial-functor-product}
  \end{equation}
  
  \begin{proof}
    We do induction on \(n\), for \(n = 0\), we have \(\unit \times \unit \equiv \unit\). For \(n = m + 1\), we may assume
    \begin{equation}
      {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit,
    \end{equation}
    in the following
    \begin{align}
      &~ {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^{m+1}~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^{m+1}~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\typeformer{B}}} ({\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit) \times \functor{P}_{\containerpair{\type{C}}{\typeformer{D}}} ({\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} : \type{A}} \typeformer{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times \sum_{\term{c} : \type{C}} \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} (\typeformer{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit) \times (\typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \typeformer{B}~\term{a} \times \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \typeformer{B}~\term{a} \times \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}} ({\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^{m+1}~\unit
    \end{align}
    taking the limit of \eqref{eq:polynomial-functor-product} we get
  \begin{equation}
    \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}} \times \typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}.
  \end{equation}
  \end{proof}
\end{thm}
\begin{exmp}
  \label{exmp:stream-zip-exmp}
  For streams we get
  \begin{equation}
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit}} \times \typeformer{M}_{\containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit} \times \containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{stream}~(\type{A} \times \type{B}) \label{eq:zip-equality}
  \end{equation}
  as expected. Transporting along \eqref{eq:zip-equality} gives us a definition for \function{zip}.
\end{exmp}

\subsection{Co-product}
\todo[inline]{Coproducts?}

\subsection{...}
\todo[inline]{The rest of the closures defined in "Categories of Containers" \cite{ContainerRules}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{TODO: \texttt{M}-types}
\section{TODO: Place these subsections}
\todo[inline]{What makes a relation a bisimulation? Is bisim and equality equal.}
\subsection{Identity Bisimulation}
Lets start with a simple example of a bisimulation namely the one given by the identity relation for any \texttt{M}-type.
\begin{lem}
  The identity relation \((\cdot \equiv \cdot)\) is a bisimulation for any final coalgebra \(\coalg{\typeformer{M}_{\container{S}}}{\function{out}}\) defined over an \texttt{M}-type.
  
  \begin{proof}
  We first define the function
  \begin{equation}
    \begin{aligned}
      \function{\alpha}_{\equiv} &: \type{\overline{\equiv}} \rightarrow \functor{P}(\type{\overline{\equiv}}) \\
      \function{\alpha}_{\equiv} (x , y) &:= \pi_1~(\function{out}~x)~,~(\lambda\,b, (\pi_2~(\function{out}~x)~b \,,\, \texttt{refl}_{(\pi_2\,(\function{out}\,x)\,b)}))
    \end{aligned}
  \end{equation}
  and the two projections
  \begin{align}
    \pi_1^{\type{\overline{\equiv}}} &= (\pi_1 , \texttt{funExt}~\lambda\,(a,b,r), \texttt{refl}_{\function{out}\,a}) \\
    \pi_2^{\type{\overline{\equiv}}} &= (\pi_2 , \texttt{funExt}~\lambda\,(a,b,r), \texttt{cong}_{\function{out}}~(\sym{r})).
  \end{align}
  This defines the bisimulation, given by the diagram in \figref{id-bisim}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\equiv}}}{\function{\alpha}_{\equiv}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\equiv}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\equiv}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Identity bisimulation}
    \label{fig:id-bisim}
  \end{figure}
\end{proof}
\end{lem}
\subsection{Bisimulation of Streams}
\todo[inline]{TODO}
\subsection{Bisimulation of Delay Monad}
We want to define a strong bisimulation relation \(\relation{\sim_{delay}}\) for the delay monad, 
\begin{defn}
  The relation \(\relation{\sim_{delay}}\) is defined by the following rules
  \begin{equation}
    \vcenter{\infer[\mathtt{now}{\sim}]{\function{now}~\term{r}~\relation{\sim_{delay}}~\function{now}~\term{r} : \universe{\mathcal{U}}}{\type{R} : \universe{U} & \term{r} : \type{R}}}
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{later}{\sim}]{\function{later}~\term{t}~\relation{\sim_{delay}}~\function{later}~\term{u} : \universe{\mathcal{U}}}{\type{R} : \universe{\mathcal{U}} & \term{t} : \typeformer{delay}~\type{R} & \term{u} : \typeformer{delay}~\type{R} & \term{t}~\relation{\sim_{delay}}~\term{u} : \universe{\mathcal{U}}}}
  \end{equation}
\end{defn}
\begin{thm}
  The relation \(\relation{\sim_{delay}}\) is a bisimulation for \(\typeformer{delay}~\type{R}\).
  \begin{proof}
    First we define the function
    \begin{equation}
      \begin{aligned}
        \function{\alpha}_{\relation{\sim_{delay}}} &: \type{\overline{\sim_{delay}}} \rightarrow \functor{P} (\type{\overline{\sim_{delay}}}) \\
        \function{\alpha}_{\relation{\sim_{delay}}}~(\term{a} , \term{b} , \mathtt{now}{\sim}~\term{r}) &:= (\mathtt{inr}~\term{r} , \lambda\,(\,)) \\
        \function{\alpha}_{\relation{\sim_{delay}}}~(\term{a} , \term{b} , \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}) &:= (\mathtt{inl}~\unitelem , \lambda\,\_, (\term{x} , \term{y} , \term{q}))
      \end{aligned}
    \end{equation}
    then we define the projections
      \begin{align}
        \pi_1^{\type{\overline{\sim_{delay}}}} &= \left( \pi_1 ~~ , ~~ \texttt{funExt}~\lambda\,(\term{a},\term{b},p), \begin{cases} (\mathtt{inr}~\term{r} , \lambda\,(\,)) & p = \mathtt{now}{\sim}~\term{r} \\ (\mathtt{inl}~\unitelem , \lambda\,\_, x) & p = \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}\end{cases} \right) \\
        \pi_2^{\type{\overline{\sim_{delay}}}} &= \left( \pi_2 ~~ , ~~ \texttt{funExt}~\lambda\,(\term{a},\term{b},p), \begin{cases} (\mathtt{inr}~\term{r} , \lambda\,(\,)) & p = \mathtt{now}{\sim}~\term{r} \\ (\mathtt{inl}~\unitelem , \lambda\,\_, y) & p = \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}\end{cases} \right) \\
      \end{align}
      This defines the bisimulation, given by the diagram in \figref{delay-strong-bisim}.
      \begin{figure}[h]
        \centering
        \begin{tikzcd}[column sep = large]
          \coalg{\typeformer{delay}~\type{R}}{\function{out}} & \coalg{\type{\overline{\sim_{\texttt{delay}}}}}{\function{\alpha}_{\relation{\sim_{delay}}}} \ar[l,Rightarrow,"\pi_1^{\type{\overline{\sim_{delay}}}}"'] \ar[r,Rightarrow,"\pi_2^{\type{\overline{\sim_{delay}}}}"] & \coalg{\typeformer{delay}~\type{R}}{\function{out}}
        \end{tikzcd}
        \caption{Strong bisimulation for delay monad}
        \label{fig:delay-strong-bisim}
      \end{figure}
  \end{proof}
\end{thm}

\subsection{Bisimulation of ITrees}
We define our bisimulation coalgebra from the strong bisimulation relation \(\mathcal{R}\), defined by the following rules.
\begin{equation}
  \vcenter{\infer[\mathtt{EqRet}]{\mathtt{Ret}~\term{a} \cong \mathtt{Ret}~\term{b}}{\term{a},\term{b} : \type{R} & \term{a} \equiv_{\type{R}} \term{b}}}
\end{equation}
\begin{equation}
  \vcenter{\infer[\mathtt{EqTau}]{\mathtt{Tau}~\term{t} \cong \mathtt{Tau}~\term{u}}{\term{t},\term{u} : \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}}
\end{equation}
\begin{equation}
  \vcenter{\infer[\mathtt{EqVis}]{\mathtt{Vis}~\term{e}~\term{k_1} \cong \mathtt{Tau}~\term{e}~\term{k_2}}{\type{A} : \universe{\mathcal{U}} & \term{e} : \typeformer{E}~\type{A} & \term{k_1},\term{k_2} : \type{A} \rightarrow \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}}
\end{equation}
Now we just need to define \(\term{\alpha}_{\relation{\mathcal{R}}}\) \todo[inline]{define the \(\alpha_{\relation{R}}\) function}. Now we have a bisimulation relation, which is equivalent to equality, using what we showed in the previous section.

\subsection{Zip Function}
We want the diagram in \figref{zip-computation-rules} to commute,
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    & A \times B & \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[ur,"\destructor{hd} \times \destructor{hd}"'] \ar[rr,"\function{zip}"] \ar[d,"\destructor{tl} \times \destructor{tl}"] & & \typeformer{stream}~(\type{A} \times \type{B}) \ar[ul,"\destructor{hd}"] \ar[d,"\destructor{tl}"] \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[rr,"\function{zip}"] & & \typeformer{stream}~(\type{A} \times \type{B})
  \end{tikzcd}
  \caption{TODO}
  \label{fig:zip-computation-rules}
\end{figure}
meaning we get the computation rules
\begin{equation}
  (\destructor{hd} \times \destructor{hd}) \equiv \destructor{hd} \circ \function{zip}
\end{equation}
\begin{equation}
  \function{zip} \circ (\destructor{tl} \times \destructor{tl}) \equiv \destructor{tl} \circ \function{zip}
\end{equation}
we can define the zip function as we did in the end of the last section. Another way to define the zip function is more directly, using the following lifting property of \texttt{M}-types
\begin{equation}
  \begin{aligned}
    &\function{lift_M}~\left(x : \prod_{n : \mathbb{N}} (\type{A} \rightarrow {\functor{P}_{\container{S}}}^n~\unit)\right)~\left(u : \prod_{n : \mathbb{N}} (\type{A} \rightarrow \pi_n (x_{n+1} a) \equiv x_n a)\right) (a : \type{A}) : \function{M}~\container{S} := \\
    &\qquad\qquad (\lambda\,n, x~n~a) , (\lambda\,n~i, p~n~a~i).
  \end{aligned} \label{eq:M-lift}
\end{equation}
To use this definition, we first define some helper functions
\begin{equation}
  \function{zip}_{X}~n~(x , y) = \begin{cases} \unit & \mathtt{if}~n = 0 \\ (\destructor{hd}~x , \destructor{hd}~y) , (\lambda\,\_, \function{zip}_{X}~m~(\destructor{tl}~x,\destructor{tl}~y)) , & \mathtt{if}~n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{zip}_{\pi}~n~(x , y) = \begin{cases} \function{refl} & \mathtt{if}~n = 0 \\ \lambda\,i,(\destructor{hd}~x , \destructor{hd}~y) , (\lambda\,\_, \function{zip}_{\pi}~m~(\destructor{tl}~x,\destructor{tl}~y)~i) , & \mathtt{if}~n = m + 1 \end{cases},
\end{equation}
we can then define
\begin{equation}
  \function{zip}_{lift}~(x , y) := \function{lift_M}~\function{zip}_X~\function{zip}~(x,y).
\end{equation}
\subsubsection{Equality of Zip Definitions}
We would expect that the two definitions for zip are equal
\begin{align}
  \texttt{transport}_{?}~a &\equiv \function{zip}_{lift}~a \\
                           &\equiv \function{lift_M}~\function{zip}_X~\function{zip}_\pi~(x,y) \\
                           &\equiv (\lambda\,n, \function{zip}_X~n~(x,y)) , (\lambda\,n~i, \function{zip}_\pi~n~(x,y)~i)
\end{align}
zero case \(X\)
\begin{equation}
  \function{zip}_X~0~(x,y) \equiv \unit
\end{equation}
Successor case \(X\)
\begin{align} 
  \function{zip}_X~(m+1)~(x,y) &\equiv (\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\destructor{tl}~x,\destructor{tl}~y)) \\
                               &\equiv (\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_, {?}~(\destructor{tl}~a)) \\
                               &\equiv (\destructor{hd}~(\texttt{transport}_{?} a)),(\lambda\,\_, \texttt{transport}_{?} (\destructor{tl}~a)) \\
                               &\equiv \mathtt{transport}_?~a \\
\end{align}
Zero case \(\pi\): \((\lambda\,i, \function{zip}_\pi~0~(x,y)~i \equiv refl)\).
\begin{align}
  &\equiv () , (\lambda\,i, \function{zip}_\pi~0~(x,y)~i) \\
  &\equiv \unit , \function{refl} \\
\end{align}
successor case
\begin{align}
  &\equiv (\function{zip}_X~(m+1)~(x,y)) , (\lambda\,i, \function{zip}_\pi~(m+1)~(x,y)~i) \\
  &\equiv ((\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\destructor{tl}~x,\destructor{tl}~y))) , (\lambda\,i, (\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_,\function{zip}_\pi~m~(\destructor{tl}~x,\destructor{tl}~y)~i))
\end{align}
\todo[inline]{Complete this proof}

\subsection{Examples of Fixed Points}
\subsubsection{Zeros}
Let us try to define the zero stream, we do this by lifting the functions
\begin{equation}
  \function{const_X}~(n : \mathbb{N})~(c : \mathbb{N})  := \begin{cases} \unit & n = 0 \\ (c , \lambda\,\_, \function{const_X}~m~c) & n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{const_\pi}~(n : \mathbb{N})~(c : \mathbb{N}) := \begin{cases} \mathtt{refl} & n = 0 \\ \lambda\,i,(c , \lambda\,\_, \function{const_\pi}~m~c~i) & n = m + 1 \end{cases}
\end{equation}
to get the definition of zero stream
\begin{equation}
  \mathtt{zeros} := \function{lift_M}~\function{const_X}~\function{const_\pi}~0.
\end{equation}
We want to show that we get the expected properties, such as
\begin{align}
  \destructor{hd}~\mathtt{zeros} &\equiv 0 \\
  \destructor{tl}~\mathtt{zeros} &\equiv \mathtt{zeros}
\end{align}

\subsubsection{Spin}
We want to define spin, as being the fixed point \(\mathtt{spin} = \mathtt{later}~\mathtt{spin}\), so that is again a final coalgebra, but of a \texttt{M}-type (which is a final coalgebra)

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \function{spin} \ar[d,"\function{later}"] \\
    \function{later}~\function{spin}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Since it is final, it also must be unique, meaning that there is just one program that spins forever, without returning a value, meaning every other program must return a value. If we just


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Conclusion}
\label{ch:conclusion}

\todo[inline]{conclude on the problem statement from the introduction}


\section{Future Work}
We have not proof the equality between types defined as (coinducitve) records and M-types.
\\ \\
All the work done here, should generalize to indexed M-types, which would be nice to have formalized.
\\ \\
Define the weak bisimilarity relations as \texttt{M}-types, since these are also coindcutve types. However this seems to need something more general than "Index M-types"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}
% \todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\appendix

\chapter{Additions to the Cubical Agda Library}
% Should be in the appendix ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{The Technical Details}

\todo[inline]{\dots}

\end{document}

% read / cite : QUOTIENT INDUCTIVE-INDUCTIVE TYPES (https://arxiv.org/pdf/1612.02346.pdf)
% Compare lean paper to this body of work.
% read / cite : Quotiented containers
% [Abbott et al. 2005]
% if a type theory has W-types [Abbott et al.2005], then it has allinductive types
% read / cite : Constructing Quotient Inductive-Inductive Types (https://akaposi.github.io/finitaryqiit.pdf)
% tt in tt, http://www.cs.nott.ac.uk/~psztxa/publ/tt-in-tt.pdf
% http://cs.ioc.ee/ewscs/2017/studsess/veltri-slides.pdf

% Buzz words / key words:
% generalised algebraic theory
% non-well founded set
% inductive definition (also equalities)

% read up on "synthetic" homotopy theory

% On academic writing : https://oac.cdlib.org/findaid/ark:/13030/kt287035zn/entire_text/
% Mathematical Writing (CS 209) Videorecordings (V0174). Dept. of Special Collections and University Archives, Stanford University Libraries, Stanford, Calif.
% http://askarov.net/on-writing-and-presenting.html
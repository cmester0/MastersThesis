\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command
\usepackage{proof} % \infer command
\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction

% Custom commands

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{blue!80!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
\newcommand*{\container}[1]{\textcolor{red}{#1}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf M-types and Coinduction in HoTT and Cubical Type Theory}\\[2ex]
{\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
\today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo[inline]{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo[inline]{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo[inline]{\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

\todo[inline]{motivate and explain the problem to be addressed}

\todo[inline]{example of a citation: \cite{amin2018}}
\todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{M-types}
\label{ch:m-types}

\section{Containers / Signatures}
A Container (or Signature) is a pair \(\container{S} = (\type{A},\type{B})\) of types \(\vdash \type{A} : \universe{\mathcal{U}}\) and \(\term{a} : \type{A} \vdash \type{B}(\term{a}) : \universe{\mathcal{U}}\). From a container we can define a polynomial functor, defined for objects (types) as
\begin{equation}
  \begin{aligned}
    P_{\container{S}} &: \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
    P(\type{X}) := P_{\container{S}}(\type{X}) &= \sum_{\term{a} : \type{A}} \type{B}(\term{a}) \rightarrow \type{X}
  \end{aligned}
\end{equation}
and for a function \(\term{f} : \type{X} \rightarrow \type{Y}\) as
\begin{equation}
  \begin{aligned}
    P\term{f} &: P\type{X} \rightarrow P\type{Y} \\
    P\term{f}(\term{a},\term{g}) &= (a, \term{f} \circ \term{g})
  \end{aligned}
\end{equation}
As an example lets look at type for streams over the type \(A\), defined using the container \(\container{S} = (\type{A},\unit)\), applying the polynomial functor we get
\begin{equation}
  P_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X}
\end{equation}
since we are working in a Category with exponentials we get \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\), furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\) here, so this will be equivalent to the definition
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{A} \times \type{X}
\end{equation}
Now we define the coalgebra for this functor with type
\begin{equation}
  \mathtt{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow P\type{C}
\end{equation}
and morphisms
\begin{equation}
  \begin{aligned}
    \_\Rightarrow\_ &: \mathtt{Coalg}_{\container{S}} \rightarrow \mathtt{Coalg}_{\container{S}} \\
    (\type{C},\term{\gamma}) \Rightarrow (\type{D},\term{\delta}) &= \sum_{\term{f} : \type{C} \rightarrow \type{D}} \term{\delta} \circ \term{f} = P \term{f} \circ \term{\gamma}
  \end{aligned}
\end{equation}
\(\mathtt{M}\)-types can now be defined from a container \(\container{S}\) as the type \(\type{\mathtt{M}}\) such that \((\type{\mathtt{M}},\term{\mathtt{out}} : \type{\mathtt{M}} \rightarrow P_{\container{S}}\type{\mathtt{M}})\) fulfills the property
\begin{equation}
  \mathtt{Final}_{\container{S}} := \sum_{(\type{X},\term{\rho}) : \mathtt{Coalg}_{\container{S}}} \prod_{{(\type{C},\term{\term{\gamma}}) : \mathtt{Coalg}_{\container{S}}}} \mathtt{isContr}((\type{C},\term{\gamma}) \Rightarrow (\type{X},\term{\rho}))
\end{equation}
that is \(\prod_{(\type{C},\term{\gamma}) : \mathtt{Coalg}_{\container{S}}} \mathtt{isContr}((C,\gamma) \Rightarrow (\type{\mathtt{M}},\term{\mathtt{out}}))\). We denote this construction of the type \(\type{\texttt{M}}\), as \(\texttt{M}(\type{A},\type{B})\) or \(\texttt{M}\container{S}\).
\\ \\
If we continue our example for streams this will give us the \(\mathtt{M}\)-type, we can see that \(P_{\container{S}}(\type{\mathtt{M}}) = \type{A} \times \type{\mathtt{M}}\), meaning we have the following diagram,
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{A} & \type{A} \times \type{\mathtt{M}} \ar[l,"\term{\pi_1}"'] \ar[r,"\term{\pi_2}"] & \type{\mathtt{M}} \\
    & \type{\texttt{M}} \ar[ul,"\term{\texttt{hd}}"] \ar[u,"\term{\texttt{out}}"'] \ar[ur,"\term{\texttt{tl}}"']
  \end{tikzcd}
  \caption{M-types of streams}
\end{figure}
where \texttt{out} is an isomorphism (because of the finality of the coalgebra), with inverse \(\mathtt{in} : P_{\container{S}}\type{\mathtt{M}} \rightarrow \type{\mathtt{M}}\). We now have a semantic for the rules we would expect for streams, if we let \(\mathtt{cons} = \mathtt{in}\) and \(\mathtt{Stream}~\type{A} = \mathtt{M}(\type{A},\unit)\),
\begin{equation}
  \infer[\mathtt{E}_{\mathtt{hd}}]{\term{\mathtt{hd}}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \mathtt{Stream}~\type{A}}
\end{equation}
\begin{equation}
  \infer[\mathtt{E}_{\mathtt{tl}}]{\term{\mathtt{tl}}~\term{s} : \mathtt{Stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \mathtt{Stream}~\type{A}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_{\mathtt{cons}}]{\term{\mathtt{cons}}~\term{x}~\term{xs} : \mathtt{Stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \mathtt{Stream}~\type{A}}
\end{equation}

\section{ITrees as \texttt{M}-types}
We want the following rules for ITrees
\begin{equation}
  \infer [\mathtt{I}_\mathtt{Ret}]{\mathtt{Ret}~\term{r} : \mathtt{itree}~\type{E}~\type{R}}{r : \type{R}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_\mathtt{Vis}]{\mathtt{Vis}~\term{a}~\term{f} : \mathtt{itree}~\type{E}~\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \type{E}~\type{A} & \term{f} : \type{A} \rightarrow \texttt{itree}~\type{E}~\type{R}}.
\end{equation}
Elimination rules
\begin{equation}
  \infer[\mathtt{E}_\mathtt{Tau}]{\mathtt{Tau}~\term{t} : \mathtt{itree}~\type{E}~\type{R}}{\term{t} : \mathtt{itree}~\type{E}~\type{R}}.
\end{equation}

\subsection{Delay Monad}
We start by looking at \texttt{itree}s without the \texttt{Vis} constructor, this type is also know as the delay monad \todo{check this statement}. We say this type is given by \(\container{S} = (\unit + \type{R},\lambda \{ \texttt{inl}~\_ \rightarrow \unit~;~\texttt{inr}~\_ \rightarrow \empt \})\) equal to \(\mathtt{M}\container{S}\), we then get the polynomial functor
\begin{equation}
  P_{\container{S}}(\type{X}) = \sum_{\term{x} : \unit + \type{R}} \lambda \{ \texttt{inl}~\_ \rightarrow \unit ; \texttt{inr}~\_ \rightarrow \empt\}~\term{x} \rightarrow \type{X}
\end{equation}
This type is equal to the type:
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{X} + \type{R} \times (\empt \rightarrow \type{X})
\end{equation}
we know that \(\empt \rightarrow \type{X} \equiv \unit\), so we can further reduce to
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{X} + \type{R}
\end{equation}
meaning we get the following diagram.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\term{\texttt{now}}"'] \ar[r,"\term{\texttt{inl}}"] & \type{R} + \type{\mathtt{M}}  & \type{\mathtt{M}} \ar[l,"\term{\texttt{inr}}"'] \ar[dl,"\term{\texttt{later}}"] \\
    & \type{\texttt{M}} \ar[u,"\term{\texttt{out}}"']
  \end{tikzcd}
  \caption{Delay monad}
\end{figure}
What this diagram says is that we can define the operations \(\term{\mathtt{now}}\) and \(\term{\mathtt{later}}\) using \(\term{\mathtt{in}} = \term{\mathtt{out}}^{-1}\) together with the injections \(\term{\mathtt{inl}}\) and \(\term{\mathtt{inr}}\). \todo{(Later = Tau, Ret = Now)}

\subsection{Tree}
Now lets look at the example where we remove the \(\mathtt{Tau}\) constructor. We let
\begin{equation}
\container{S} = \left(\type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A}~,~\lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \} \right).
\end{equation}
This will give us the polynomial functor:
\begin{equation}
  P_{\container{S}}(\type{X}) = \sum_{\term{x} : \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A}} \lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \}~\term{x} \rightarrow \type{X}
\end{equation}
which simplifies to
\begin{equation}
  P_{\container{S}}(\type{X}) = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{X}))
\end{equation}
and further
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{X})
\end{equation}

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\term{\texttt{Ret}}"'] \ar[r,"\term{\texttt{inl}}"] & \type{R} + \sum_{\type{A} : \universe{U}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{\mathtt{M}})  & \sum_{\type{A} : \universe{U}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{\mathtt{M}}) \ar[l,"\term{\texttt{inr}}"'] \ar[dl,"\term{\texttt{Vis}}"] \\
    & \type{\texttt{M}} \ar[u,"\term{\texttt{out}}"]
  \end{tikzcd}
  \caption{TODO: ???}
\end{figure}
\noindent Again we can define \texttt{Ret} and \texttt{Vis} using the \texttt{in} functor.

\subsection{ITrees}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types. We define ITrees by the container:
\begin{equation}
  \container{S} = \left( \unit+\type{R}+\sum_{\type{A}:\universe{\mathcal{U}}} (\type{E}~\type{A}) ~~,~~ \lambda\left\{ \texttt{inl}~(\texttt{inl}~\_) \rightarrow \unit ~;~ \texttt{inl}~(\texttt{inr}~\_) \rightarrow \empt ~;~ \texttt{inr} (\type{A},\_)  \rightarrow \type{A} \right\} \right)
\end{equation}
Then the (reduced) polynomial functor becomes
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{X} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} ((\type{E}~\type{A}) \times (\type{A} \rightarrow \type{X}))
\end{equation}
Giving us the diagram
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[ddrr,"\term{\texttt{Ret}}"'] \ar[r,"\term{\texttt{inl}}\,\circ\,\term{\texttt{inr}}"] & \type{\texttt{M}} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} (\type{E}~\type{A} \times (\type{A} \rightarrow \type{\texttt{M}})) & & \sum_{\type{A} : \universe{U}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{\mathtt{M}}) \ar[ll,"\term{\texttt{inr}}"'] \ar[ddl,"\term{\texttt{Vis}}"] \\
    & & \type{\texttt{M}} \ar[ul,"\term{\texttt{inl}}\,\circ\,\term{\texttt{inl}}"'] \ar[d,"\term{\texttt{Tau}}"'] \\
    & & \type{\texttt{M}} \ar[uul,"\term{\texttt{out}}"]
  \end{tikzcd}
  \caption{TODO: ???}
\end{figure}

\section{Co-induction Principle for M-types}
We can now construct a bisimulation: forall coalgebras \(\coalg{\type{C}}{\term{\gamma}} : \mathtt{Coalg}_{\container{S}}\), if we have a relation \(\term{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\), and a type \(\type{\overline{\mathcal{R}}} = \sum_{\term{a} : \type{C}} \sum_{\term{b} : \type{C}} \term{\mathcal{R}}~\term{a}~\term{b}\), such that \(\type{\overline{\mathcal{R}}}\) and \(\term{\alpha}_{\type{\overline{\mathcal{R}}}} : \type{\overline{\mathcal{R}}} \rightarrow P(\type{\overline{\mathcal{R}}})\) makes a \(P\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\type{\overline{\mathcal{R}}}}} : \mathtt{Coalg}_{\container{S}}\), such that the following diagram commutes (where \(\Rightarrow\) are \(P\)-coalgebra morphisms).

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \coalg{\type{C}}{\term{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\type{\overline{\mathcal{R}}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\term{\gamma}}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Furthermore for any bisimulation over a final \(P\)-coalgebra \(\coalg{\type{\mathtt{M}}}{\term{\mathtt{out}}}:\mathtt{Coalg}_{\container{S}}\) we have the following diagram,

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \coalg{\type{\texttt{M}}}{\term{\texttt{out}}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\type{\overline{\mathcal{R}}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{\texttt{M}}}{\term{\texttt{out}}}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent where \(\pi_1^{\type{\overline{\mathcal{R}}}} = ~! = \pi_2^{\type{\overline{\mathcal{R}}}}\), which means given \(\term{r} : \term{\mathcal{R}}(\term{m},\term{m'})\) we get \(\term{m} = \pi_1^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \pi_2^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \term{m'}\).
\\ \\
We want to define a co-induction principle from any bisimulation relation over a final coalgebra, that is if \(\term{R}\) gives a bisimulation, then it is true that
\begin{equation}
  \term{R} \equiv \term{\equiv}
\end{equation}
meaning we can use the relation \(\term{R}\), to show that two things of an \texttt{M}-type are equivalent. So we want to construct an isomorphism between \(\term{R}\) and the equivalence relation \(\equiv\), to do this we must construct functions
\begin{align}
  \term{p} &: \term{R} \rightarrow \term{\equiv} \\
  \term{q} &: \term{\equiv} \rightarrow \term{R}
\end{align}
and relations
\begin{align}
  \term{\alpha} &: \term{p} \circ \term{q} \equiv \term{\mathtt{id}_{\equiv}} \\
  \term{\beta} &: \term{q} \circ \term{p} \equiv \term{\mathtt{id}_{R}}
\end{align}
\todo[inline]{Complete the construction of equality from any bisimulation relation over an M-type}

\subsection{Bisimulation of ITrees}
We define our bisimulation coalgebra from the strong bisimulation relation \(\mathcal{R}\), defined by the following rules.
\begin{equation}
  \infer[\mathtt{EqRet}]{\mathtt{Ret}~\term{a} \cong \mathtt{Ret}~\term{b}}{\term{a},\term{b} : \type{R} & \term{a} \equiv_{\type{R}} \term{b}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqTau}]{\mathtt{Tau}~\term{t} \cong \mathtt{Tau}~\term{u}}{\term{t},\term{u} : \mathtt{itree}~\type{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqVis}]{\mathtt{Vis}~\term{e}~\term{k_1} \cong \mathtt{Tau}~\term{e}~\term{k_2}}{\type{A} : \universe{\mathcal{U}} & \term{e} : \type{E}~\type{A} & \term{k_1},\term{k_2} : \type{A} \rightarrow \mathtt{itree}~\type{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
Now we just need to define \(\term{\alpha}_{\type{\overline{\mathcal{R}}}}\) \todo{define the \(\alpha_{\overline{R}}\) function}. Now we have a bisimulation relation, which is equivalent to equality, using what we showed in the previous section.

\section{Examples of fixed points}
We want to define spin, as being the fixed point \(\mathtt{spin} = \mathtt{later}~\mathtt{spin}\), so that is again a final coalgebra, but of a M-type (which is a final coalgebra)

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \term{\texttt{spin}} \ar[d,"\term{\texttt{later}}"] \\
    \term{\texttt{later}}~\term{\texttt{spin}}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Since it is final, it also must be unique, meaning that there is just one program that spins forever, without returning a value, meaning every other program must return a value. If we just

\section{Quotient M-type}
Since we know that M-types preserves the H-level, we can use set-truncated quotients, to define quotient M-types, for examples we can define weak bisimulation of the delay monad as
\[\]

\section{Bisimulation}
We want to define a bisimulation principle for M-types

\section{Closure properties of M-types}
We define the product of two containers
\begin{equation}
  \container{(A,B)} \times \container{(C,D)} \equiv \container{( A \times C , \lambda (a , c), B a \times D c)},
\end{equation}
we can lift this rule, through the following diagram, used to define M-types

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    A & A \times C \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & C \\
    P (M_{(A , B)}) \ar[u,"fst"] & P(M_{(A \times C , B \times D)}) \ar[u,"fst"] & P (M_{(C , D)}) \ar[u,"fst"'] \\
    M_{(A , B)} \ar[u,"out"] \ar[d,"\pi_!"] & M_{(A \times C , B \times D)} \ar[u,"out"] \ar[d,"\pi_!"] & M_{(C , D)} \ar[u,"out"] \ar[d,"\pi_!"] \\
    {P_{\container{(A,B)}}}^n~\unit \ar[d,"\pi_n"] & {P_{\container{(A,B)} \times \container{(C,D)}}}^n~\unit \ar[l] \ar[r] \ar[d,"\pi_n"] & {P_{\container{(C,D)}}}^n~\unit \ar[d,"\pi_n"] \\
    \vdots \ar[d,"\pi_1"] & \vdots \ar[d,"\pi_1"] & \vdots \ar[d,"\pi_1"] \\
    P_{\container{(A,B)}}~\unit \ar[d,"\pi_0"] & P_{\container{(A,B)} \times \container{(C,D)}}~\unit \ar[l] \ar[r] \ar[d,"\pi_0"] & P_{\container{(C,D)}}~\unit \ar[d,"\pi_0"] \\
    \unit & \unit \ar[l] \ar[r] & \unit
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent We now prove that
\begin{equation}
  {P_{\container{(A,B)}}}^n~\unit \times {P_{\container{(C,D)}}}^n~\unit \equiv {P_{\container{(A,B)} \times \container{(C,D)}}}^n~\unit,
\end{equation}
by induction on \(n\). For \(n = 0\), we have \(\unit \times \unit \equiv \unit\). For \(n = m + 1\), we may assume
\begin{equation}
{P_{\container{(A,B)}}}^m~\unit \times {P_{\container{(C,D)}}}^m~\unit \equiv {P_{\container{(A,B)} \times \container{(C,D)}}}^m~\unit,
\end{equation}
and show 
\begin{align}
  &~ {P_{\container{(A,B)}}}^{m+1}~\unit \times {P_{\container{(C,D)}}}^{m+1}~\unit \\
   \equiv&~ P_{\container{(A,B)}} ({P_{\container{(A,B)}}}^m~\unit) \times P_{\container{(C,D)}} ({P_{\container{(C,D)}}}^m~\unit) \\
   \equiv&~ \sum_{\term{a} : \type{A}} \type{B}~\term{a} \rightarrow {P_{\container{(A,B)}}}^m~\unit \times \sum_{\term{c} : \type{C}} \type{D}~\term{c} \rightarrow {P_{\container{(C,D)}}}^m~\unit \\
  \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} (\type{B}~\term{a} \rightarrow {P_{\container{(A,B)}}}^m~\unit) \times (\type{D}~\term{c} \rightarrow {P_{\container{(C,D)}}}^m~\unit) \\
  \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \type{B}~\term{a} \times \type{D}~\term{c} \rightarrow {P_{\container{(A,B)}}}^m~\unit \times {P_{\container{(C,D)}}}^m~\unit \\
  \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \type{B}~\term{a} \times \type{D}~\term{c} \rightarrow {P_{\container{(A,B)} \times \container{(C,D)}}}^m~\unit \\
  \equiv&~ P_{\container{(A,B)} \times \container{(C,D)}} ({P_{\container{(A,B)} \times \container{(C,D)}}}^m~\unit) \\
  \equiv&~ {P_{\container{(A,B)} \times \container{(C,D)}}}^{m+1}~\unit
\end{align}
taking the limit we get
\begin{equation}
  M_{\container{(A,B)}} \times M_{\container{(C,D)}} \equiv M_{\container{(A,B)} \times \container{(C,D)}}
\end{equation}
as an example hereof lets look at the definition for streams, where we actually get
\begin{equation}
  stream~A \times stream~B \equiv stream~(A \times B)
\end{equation}
as expected, transporting along this gives us the definition for zip.

\subsection{Closure under products}
The product of two M-types is again an M-type

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \unit \ar[r] & P_{\container{S_0}}~\unit \ar[r] & \dots \ar[r] & P_{\container{S_0}}^n~\unit \ar[r] & \dots \\
    \unit \times \unit \ar[u] \ar[d] \ar[r] & P_{\container{S_0}}~\unit \times P_{\container{S_1}}~\unit \ar[u] \ar[d] \ar[r] & \dots \ar[r] & P_{\container{S_0}}^n~\unit \times P_{\container{S_1}}^n~\unit \ar[u] \ar[d] \ar[r] & \dots \\
    \unit \ar[r] & P_{\container{S_1}}~\unit \ar[r] & \dots \ar[r] & P_{\container{S_1}}^n~\unit \ar[r] & \dots
  \end{tikzcd}
  \caption{TODO}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \unit \ar[r] & P_{\container{S_0} \times \container{S_1}}~\unit \ar[r] & \dots \ar[r] & P_{\container{S_0} \times \container{S_1}}^n~\unit \ar[r] & \dots \\
  \end{tikzcd}
  \caption{TODO}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    & A \times B & \\
    Stream A \times Stream B \ar[ur,"hd \times hd"'] \ar[rr,"zip"] \ar[d,"tl \times tl"] & & Stream (A \times B) \ar[ul,"hd"] \ar[d,"tl"] \\
    Stream A \times Stream B \ar[rr,"zip"] & & Stream (A \times B)
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent From this we get the computation rules
\begin{equation}
  hd \times hd \equiv hd \circ zip
\end{equation}
\begin{equation}
  zip \circ tl \times tl \equiv tl \circ zip
\end{equation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Additions to the Cubical Agda Library}
\section{Lemma 10}
\texttt{M}-types are part of a final coalgebra, formally \(\forall\,\container{S}~\coalg{\type{C}}{\term{\gamma}}, (\coalg{\type{C}}{\term{\gamma}} \Rightarrow \coalg{\type{\mathtt{M}}}{\term{\mathtt{out}}}) \equiv \unit\)
\begin{align}
  U &\equiv \sum_{f : C \rightarrow \mathcal{L}} \mathtt{out} \circ f \equiv \mathtt{step}~f \\
    &\equiv \sum_{f : C \rightarrow \mathcal{L}} \mathtt{in} \circ \mathtt{out} \circ f \equiv \mathtt{in} \circ \mathtt{step}~f\\
    &\equiv \sum_{f : C \rightarrow \mathcal{L}} f \equiv \mathtt{in} \circ \mathtt{step}~f\\
    &\equiv \sum_{f : C \rightarrow \mathcal{L}} f \equiv \Psi~f\\
    &\equiv \sum_{c : Cone} e~c \equiv \Psi~(e~c)\\
    &\equiv \sum_{c : Cone} e~c \equiv e~(\phi~c) \\
    &\equiv \sum_{c : Cone} c \equiv \phi~c \\
    &\equiv \sum_{(u,q) : Cone} (u , q) \equiv (\phi_0~u , \phi_1~u~q) \\
    &\equiv \sum_{(u,q) : Cone} \sum_{p : u \equiv \phi_0~u} q \equiv_{\lambda i, Cone_1 (p~i)} \phi_1~u~q \\
    &\equiv \sum_{(u,p) : \sum_{u : Cone_0} u \equiv \phi_0~u} \sum_{q : Cone_1~u} q \equiv_{\lambda i, Cone_1 (p~i)} \phi_1~u~q \\
    &\equiv \sum_{q : Cone_1 u_0} q \equiv_{\lambda i, Cone_1 (funExt~p_0~i)} \phi_1~u_0~q \\
    &\vdots \\
    &\equiv \unit
\end{align}

\section{Missing postulates}
\subsubsection{Combine}
For all \(\term{X} : \type{\mathbb{N}} \rightarrow \universe{U}\) and \(p : \prod_{n : \type{\mathbb{N}}} \term{X}~(n + 1) \rightarrow \term{X}~n \rightarrow \universe{U}\)
\begin{align}
  &~\sum_{\term{x_0} : \type{X_0}} \sum_{\term{y} : \prod_{\term{n} : \type{\mathbb{N}}} \type{X_{n+1}}} (\term{p}~\type{y_0}~\type{x_0}) \times \left(\prod_{\term{n} : \type{\mathbb{N}}} \term{p}~\type{y_{n + 1}}~\type{y_n}\right) \\
  \equiv&~\sum_{\term{x_0} : \type{X_0}} \sum_{\term{y} : \prod_{\term{n} : \type{\mathbb{N}}} \type{X_{n+1}}} (\term{p}~\type{y_0}~\type{x_0}) \times \left(\prod_{\term{n} : \type{\mathbb{N}}} \term{p}~\type{y_{n + 1}}~\type{y_n}\right) \\
  \equiv&~\sum_{\term{x} : \prod_{\term{n} : \type{\mathbb{N}}} \rightarrow \type{X_n}} (\term{p}~\type{x_1}~\type{x_0}) \times \left(\prod_{\term{n} : \type{\mathbb{N}}} → \term{p}~\type{x_{n+2}}~\type{x_{n+1}}\right)
\end{align}

\chapter{Conclusion}
\label{ch:conclusion}

\todo[inline]{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo[inline]{\dots}

\end{document}


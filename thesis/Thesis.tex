\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}
% \newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command
\usepackage{proof} % \infer command
\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction

% Custom commands

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{blue!80!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
\newcommand*{\container}[1]{\textcolor{red}{#1}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Higher Order Categorical Semantics}\\[2ex]
{\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
\today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo[inline]{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo[inline]{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo[inline]{\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

\todo[inline]{motivate and explain the problem to be addressed}

\todo[inline]{example of a citation: \cite{amin2018}}
\todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{M-types}
\label{ch:m-types}

\section{Containers / Signatures}
A Container (or Signature) is a pair \(\container{S} = (\type{A},\type{B})\) of types \(\vdash \type{A} : \universe{\mathcal{U}}\) and \(\term{a} : \type{A} \vdash \type{B}(\term{a}) : \universe{\mathcal{U}}\). From a container we can define a polynomial functor, defined for objects (types) as
\begin{equation}
  \begin{aligned}
    P_{\container{S}} &: \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
    P(\type{X}) := P_{\container{S}}(\type{X}) &= \sum_{\term{a} : \type{A}} \type{B}(\term{a}) \rightarrow \type{X}
  \end{aligned}
\end{equation}
and for a function \(\term{f} : \type{X} \rightarrow \type{Y}\) as
\begin{equation}
  \begin{aligned}
    P\term{f} &: P\type{X} \rightarrow P\type{Y} \\
    P\term{f}(\term{a},\term{g}) &= (a, \term{f} \circ \term{g})
  \end{aligned}
\end{equation}
As an example lets look at type for streams over the type \(A\), defined using the container \(\container{S} = (\type{A},\unit)\), applying the polynomial functor we get
\begin{equation}
  P_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X}
\end{equation}
since we are working in a Category with exponentials we get \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\), furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\) here, so this will be equivalent to the definition
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{A} \times \type{X}
\end{equation}
Now we define the coalgebra for this functor with type
\begin{equation}
  \mathtt{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow P\type{C}
\end{equation}
and morphisms
\begin{equation}
  \begin{aligned}
    \_\Rightarrow\_ &: \mathtt{Coalg}_{\container{S}} \rightarrow \mathtt{Coalg}_{\container{S}} \\
    (\type{C},\term{\gamma}) \Rightarrow (\type{D},\term{\delta}) &= \sum_{\term{f} : \type{C} \rightarrow \type{D}} \term{\delta} \circ \term{f} = P \term{f} \circ \term{\gamma}
  \end{aligned}
\end{equation}
\(\mathtt{M}\)-types can now be defined from a container \(\container{S}\) as the type \(\type{\mathtt{M}}\) such that \((\type{\mathtt{M}},\term{\mathtt{out}} : \type{\mathtt{M}} \rightarrow P_{\container{S}}\type{\mathtt{M}})\) fulfills the property
\begin{equation}
  \mathtt{Final}_{\container{S}} := \sum_{(\type{X},\term{\rho}) : \mathtt{Coalg}_{\container{S}}} \prod_{{(\type{C},\term{\term{\gamma}}) : \mathtt{Coalg}_{\container{S}}}} \mathtt{isContr}((\type{C},\term{\gamma}) \Rightarrow (\type{X},\term{\rho}))
\end{equation}
that is \(\prod_{(\type{C},\term{\gamma}) : \mathtt{Coalg}_{\container{S}}} \mathtt{isContr}((C,\gamma) \Rightarrow (\type{\mathtt{M}},\term{\mathtt{out}}))\). We denote this construction of the type \(\type{\texttt{M}}\), as \(\texttt{M}(\type{A},\type{B})\) or \(\texttt{M}\container{S}\).
\\ \\
If we continue our example for streams this will give us the \(\mathtt{M}\)-type, we can see that \(P_{\container{S}}(\type{\mathtt{M}}) = \type{A} \times \type{\mathtt{M}}\), meaning we have the following diagram,
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{A} & \type{A} \times \type{\mathtt{M}} \ar[l,"\term{\pi_1}"'] \ar[r,"\term{\pi_2}"] & \type{\mathtt{M}} \\
    & \type{\texttt{M}} \ar[ul,"\term{\texttt{hd}}"] \ar[u,"\term{\texttt{out}}"'] \ar[ur,"\term{\texttt{tl}}"']
  \end{tikzcd}
  \caption{M-types of streams}
\end{figure}
where \texttt{out} is an isomorphism (because of the finality of the coalgebra), with inverse \(\mathtt{in} : P_{\container{S}}\type{\mathtt{M}} \rightarrow \type{\mathtt{M}}\). We now have a semantic for the rules we would expect for streams, if we let \(\mathtt{cons} = \mathtt{in}\) and \(\mathtt{Stream}~\type{A} = \mathtt{M}(\type{A},\unit)\),
\begin{equation}
  \infer[\mathtt{E}_{\mathtt{hd}}]{\term{\mathtt{hd}}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \mathtt{Stream}~\type{A}}
\end{equation}
\begin{equation}
  \infer[\mathtt{E}_{\mathtt{tl}}]{\term{\mathtt{tl}}~\term{s} : \mathtt{Stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \mathtt{Stream}~\type{A}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_{\mathtt{cons}}]{\term{\mathtt{cons}}~\term{x}~\term{xs} : \mathtt{Stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \mathtt{Stream}~\type{A}}
\end{equation}

\section{ITrees as \texttt{M}-types}

\subsection{Delay Monad}
We want the following rules for ITrees
\begin{equation}
  \infer [\mathtt{I}_\mathtt{Ret}]{\mathtt{Ret}~\term{r} : \mathtt{itree}~\type{E}~\type{R}}{r : \type{R}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_\mathtt{Vis}]{\mathtt{Vis}~\term{a}~\term{f} : \mathtt{itree}~\type{E}~\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \type{E}~\type{A} & \term{f} : \type{A} \rightarrow \texttt{itree}~\type{E}~\type{R}}.
\end{equation}
Elimination rules
\begin{equation}
  \infer[\mathtt{E}_\mathtt{Tau}]{\mathtt{Tau}~\term{t} : \mathtt{itree}~\type{E}~\type{R}}{\term{t} : \mathtt{itree}~\type{E}~\type{R}}.
\end{equation}
We start by looking at \texttt{itree}s without the \texttt{Vis} constructor, this type is also know as the delay monad \todo{check this statement}. We say this type is given by \(\container{S} = (\unit + \type{R},\lambda \{ \texttt{inl}~\_ \rightarrow \unit~;~\texttt{inr}~\_ \rightarrow \empt \})\) equal to \(\mathtt{M}\container{S}\), we then get the polynomial functor
\begin{equation}
  P_{\container{S}}(\type{X}) = \sum_{\term{x} : \unit + \type{R}} \lambda \{ \texttt{inl}~\_ \rightarrow \unit ; \texttt{inr}~\_ \rightarrow \empt\}~\term{x} \rightarrow \type{X}
\end{equation}
This type is equal to the type:
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{X} + \type{R} \times (\empt \rightarrow \type{X})
\end{equation}
we know that \(\empt \rightarrow \type{X} \equiv \unit\), so we can further reduce to
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{X} + \type{R}
\end{equation}
meaning we get the following diagram.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\term{\texttt{now}}"'] \ar[r,"\term{\texttt{inl}}"] & \type{R} + \type{\mathtt{M}}  & \type{\mathtt{M}} \ar[l,"\term{\texttt{inr}}"'] \ar[dl,"\term{\texttt{later}}"] \\
    & \type{\texttt{M}} \ar[u,"\term{\texttt{out}}"']
  \end{tikzcd}
  \caption{Delay monad}
\end{figure}
What this diagram says is that we can define the operations \(\term{\mathtt{now}}\) and \(\term{\mathtt{later}}\) using \(\term{\mathtt{in}} = \term{\mathtt{out}}^{-1}\) together with the injections \(\term{\mathtt{inl}}\) and \(\term{\mathtt{inr}}\). \todo{(Later = Tau, Ret = Now)}

\subsection{Tree}
Now lets look at the example where we remove the \(\mathtt{Tau}\) constructor. We let
\begin{equation}
\container{S} = \left(\type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A}~,~\lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \} \right).
\end{equation}
This will give us the polynomial functor:
\begin{equation}
  P_{\container{S}}(\type{X}) = \sum_{\term{x} : \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A}} \lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \}~\term{x} \rightarrow \type{X}
\end{equation}
which simplifies to
\begin{equation}
  P_{\container{S}}(\type{X}) = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{X}))
\end{equation}
and further
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{X})
\end{equation}

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\term{\texttt{Ret}}"'] \ar[r,"\term{\texttt{inl}}"] & \type{R} + \sum_{\type{A} : \universe{U}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{\mathtt{M}})  & \sum_{\type{A} : \universe{U}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{\mathtt{M}}) \ar[l,"\term{\texttt{inr}}"'] \ar[dl,"\term{\texttt{Vis}}"] \\
    & \type{\texttt{M}} \ar[u,"\term{\texttt{out}}"]
  \end{tikzcd}
  \caption{TODO: ???}
\end{figure}
\noindent Again we can define \texttt{Ret} and \texttt{Vis} using the \texttt{in} functor.

\subsection{ITrees}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types. We define ITrees by the container:
\begin{equation}
  \container{S} = \left( \unit+\type{R}+\sum_{\type{A}:\universe{\mathcal{U}}} (\type{E}~\type{A}) ~~,~~ \lambda\left\{ \texttt{inl}~(\texttt{inl}~\_) \rightarrow \unit ~;~ \texttt{inl}~(\texttt{inr}~\_) \rightarrow \empt ~;~ \texttt{inr} (\type{A},\_)  \rightarrow \type{A} \right\} \right)
\end{equation}
Then the (reduced) polynomial functor becomes
\begin{equation}
  P_{\container{S}}(\type{X}) = \type{X} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} ((\type{E}~\type{A}) \times (\type{A} \rightarrow \type{X}))
\end{equation}
Giving us the diagram
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[ddrr,"\term{\texttt{Ret}}"'] \ar[r,"\term{\texttt{inl}}\,\circ\,\term{\texttt{inr}}"] & \type{\texttt{M}} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} (\type{E}~\type{A} \times (\type{A} \rightarrow \type{\texttt{M}})) & & \sum_{\type{A} : \universe{U}} \type{E}~\type{A} \times (\type{A} \rightarrow \type{\mathtt{M}}) \ar[ll,"\term{\texttt{inr}}"'] \ar[ddl,"\term{\texttt{Vis}}"] \\
    & & \type{\texttt{M}} \ar[ul,"\term{\texttt{inl}}\,\circ\,\term{\texttt{inl}}"'] \ar[d,"\term{\texttt{Tau}}"'] \\
    & & \type{\texttt{M}} \ar[uul,"\term{\texttt{out}}"]
  \end{tikzcd}
  \caption{TODO: ???}
\end{figure}

\section{Coinduction priciple of M-types}
We can now construct a bisimulation: forall coalgebras \(\coalg{\type{C}}{\term{\gamma}} : \mathtt{Coalg}_{\container{S}}\), if we have a relation \(\term{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\), and a type \(\type{\overline{\mathcal{R}}} = \sum_{\term{a} : \type{C}} \sum_{\term{b} : \type{C}} \term{\mathcal{R}}~\term{a}~\term{b}\), such that \(\type{\overline{\mathcal{R}}}\) and \(\term{\alpha}_{\type{\overline{\mathcal{R}}}} : \type{\overline{\mathcal{R}}} \rightarrow P(\type{\overline{\mathcal{R}}})\) makes a P-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\type{\overline{\mathcal{R}}}}} : \mathtt{Coalg}_{\container{S}}\), such that the following diagram commutes (where \(\Rightarrow\) are P-coalgebra morphisms).

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \coalg{\type{C}}{\term{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\type{\overline{\mathcal{R}}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\term{\gamma}}
  \end{tikzcd}
\end{figure}
\noindent Furthermore for any bisimulation over a final P-coalgebra \(\coalg{\type{\mathtt{M}}}{\term{\mathtt{out}}}:\mathtt{Coalg}_{\container{S}}\) we have the following diagram,

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \coalg{\type{\texttt{M}}}{\term{\texttt{out}}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\type{\overline{\mathcal{R}}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{\texttt{M}}}{\term{\texttt{out}}}
  \end{tikzcd}
\end{figure}
\noindent where \(\pi_1^{\type{\overline{\mathcal{R}}}} = ~! = \pi_2^{\type{\overline{\mathcal{R}}}}\), which means given \(\term{r} : \term{\mathcal{R}}(\term{m},\term{m'})\) we get \(\term{m} = \pi_1^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \pi_2^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \term{m'}\).

% \ar[d,"\texttt{out}"{name=out1}]
% \ar[Rightarrow,from=alpha, to=out1, "(rel_1 ; \pi_1)"']

\subsection{Bisimulation of ITrees}
We define our bisimulation coalgebra from the strong bisimulation relation \(\mathcal{R}\), defined by the following rules.
\begin{equation}
  \infer[\mathtt{EqRet}]{\mathtt{Ret}~\term{a} \cong \mathtt{Ret}~\term{b}}{\term{a},\term{b} : \type{R} & \term{a} \equiv_{\type{R}} \term{b}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqTau}]{\mathtt{Tau}~\term{t} \cong \mathtt{Tau}~\term{u}}{\term{t},\term{u} : \mathtt{itree}~\type{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqVis}]{\mathtt{Vis}~\term{e}~\term{k_1} \cong \mathtt{Tau}~\term{e}~\term{k_2}}{\type{A} : \universe{\mathcal{U}} & \term{e} : \type{E}~\type{A} & \term{k_1},\term{k_2} : \type{A} \rightarrow \mathtt{itree}~\type{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
Now we just need to define \(\term{\alpha}_{\type{\overline{\mathcal{R}}}}\) \todo{define the \(\alpha_{\overline{R}}\) function}. Now we have a bisimulation relation, which is equivalent to equality, using what we showed in the previous section.

\section{Examples of fixed points}
We want to define spin, as being the fixed point \(\mathtt{spin}\ = \mathtt{later}~\mathtt{spin}\), so that is again a final coalgebra, but of a M-type (which is a final coalgebra)

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \term{\texttt{spin}} \ar[d,"\term{\texttt{later}}"] \\
    \term{\texttt{later}}~\term{\texttt{spin}}
  \end{tikzcd}
\end{figure}
\noindent Since it is final, it also must be unique, meaning that there is just one program that spins forever, without returning a value, meaning every other program must return a value. If we just

\section{Quotiented M-types}
We can define a quotient of the polynomial functor \(P\) as a functor \(F\), such that the following diagram commutes

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \term{P} \type{\alpha} \ar[r,"\term{P}\term{f}"] \ar[d,"\term{abs}_{\type{\alpha}}"'] & \term{P} \type{\beta} \ar[d,"\term{abs}_{\type{\beta}}"] \\
    \term{F} \type{\alpha} \ar[r,"\term{F}\term{f}"] & \term{F} \type{\beta}
  \end{tikzcd}
\end{figure}
\noindent for all \(f : \alpha \rightarrow \beta\) and \(\alpha,\beta\). This is a naturallity condition for \(abs\). As an example lets look at the quotient of the delay monad by the equality \(\forall \term{a} : \type{\mathtt{M}} , \term{\mathtt{later}}~\term{a} \equiv \term{a}\). We get the diagram

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{\texttt{M}} \ar[r,"\term{\texttt{later}}"] \ar[d,"\term{\texttt{out}}"'] & \type{\texttt{M}} \ar[d,"\term{\texttt{out}}"] \\
    \term{P} \type{\texttt{M}} \ar[r,"\term{P}~\term{\texttt{later}}"] \ar[d,"\term{abs}_{\type{\texttt{M}}}"'] & \term{P} \type{\texttt{M}} \ar[d,"\term{abs}_{\type{\texttt{M}}}"] \\
    \term{F} \type{\texttt{M}} \ar[r,"\term{F}~\term{\texttt{later}}"] & \term{F} \type{\texttt{M}}
  \end{tikzcd}
\end{figure}
\noindent Such that the (co?)limit for \(\term{F}~\type{\texttt{M}}\) is \(\unit + \type{R}\), meaning
\begin{equation}
  F~later \circ abs_M \circ out \equiv abs_M \circ out \circ later
\end{equation}
\begin{equation}
  F~later \equiv later^{-1}
\end{equation}
\begin{align}
  later &= in \circ inr \\
  out \circ later &= inr \\
        &= P~later \circ out \\
  abs_{M} \circ out \circ later &= abs_{M} \circ inr \\
        &= abs_M \circ P~later \circ out\\
        &= F~later \circ abs_M \circ out\\
\end{align}
\\ \\
Given the container of the final P-coalgebra for some container \(\container{S}\), we can construct the diagram:

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    (\type{\texttt{M}}, \term{P}~\type{\texttt{M}}) \ar[rr,"\texttt{Tau}"] \ar[dr,"\sim_x : \texttt{Tau}~x~\equiv~x"'] & & (\type{\texttt{M}}, \term{P}~\type{\texttt{M}}) \ar[dl,"\sim_y : \texttt{Tau}~y~\equiv~y"] \\
    & (\ssfrac{\type{\texttt{M}}}{\sim}, \term{F}~\ssfrac{\type{\texttt{M}}}{\sim}) 
  \end{tikzcd}
\end{figure}
\noindent Such that \(\sim_x \equiv \sim_y \circ \mathtt{Tau}\), where \(\ssfrac{\term{P}~\type{\texttt{M}}}{\sim} \equiv \term{F}~(\ssfrac{\type{\texttt{M}}}{\sim})\)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo[inline]{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo[inline]{\dots}

\end{document}


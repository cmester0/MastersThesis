\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\usepackage{marvosym}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command
\usepackage{proof} % \infer command
\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction

% allow breaks in align and equation (a new page for example) 
\allowdisplaybreaks

\usepackage{amsthm}

\theoremstyle{plain} % default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section] 
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% Custom commands

\newcommand*{\lemref}[1]{Lemma~\ref{lem:#1}}
\newcommand*{\figref}[1]{Figure~\ref{fig:#1}}

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{green!30!black}{#1}} % \textcolor{green!70!black} \textcolor{blue!80!black}
\newcommand*{\pathterm}[1]{\textcolor{green!40!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
% \newcommand*{\dependenttype}[1]{\textcolor{magenta!70!black}{#1}}
\newcommand*{\container}[1]{\textcolor{red}{#1}}
\newcommand*{\containerpair}[2]{\textcolor{red}{(}#1\,\textcolor{red}{,}\,#2\textcolor{red}{)}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\relation}[1]{\textcolor{gray}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constant}[1]{\textcolor{orange!60!black}{\ensuremath{\mathtt{#1}}}}

\newcommand*{\function}[1]{\textcolor{blue!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constructor}[1]{\textcolor{purple!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\destructor}[1]{\textcolor{pink!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\typeformer}[1]{\ensuremath{\mathtt{#1}}}
\newcommand*{\functor}[1]{\ensuremath{\mathbf{\mathtt{#1}}}}

\newcommand*{\unitelem}{\constant{\star}} % \constant{tt}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

\newcommand*{\natcases}[2]{\ensuremath{\mathbb{[\hspace{-.5mm}\rangle}~\ensuremath{#1}~,~\ensuremath{#2}~\mathbb{\langle\hspace{-.5mm}]}}}

% Concatenation of paths taken from HoTT book
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\newcommand*{\sym}[1]{\ensuremath{#1^{-1}}}

% \mathord

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
  {\Huge\sf \texttt{M}-types and Coinduction in HoTT and Cubical Type Theory}\\[2ex]
  {\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
  \noindent\rule{\linewidth}{1mm}\\[4ex]
  \noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
    \today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo[inline]{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo[inline]{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo[inline]{\dots}

\vspace{2ex}
c\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Introduction} % Everyone interested should be able to read this!
\label{ch:intro}
This work tries to formalize co-inductive types in the setting of homotopy type theory.

\todo[inline]{motivate and explain the problem to be addressed}

\todo[inline]{example of a citation:~\cite{amin2018}}
\todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Notation}
We use the following notation / font:
\begin{itemize}
\item Universe \(\universe{\mathcal{U}}_i\) or \(\universe{\mathcal{U}}\)
\item Type \(\type{A} : \universe{\mathcal{U}}\)
\item A type former or dependent type \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\)
\item A term \(\term{x} : \type{A}\) or for constants \(\constant{c} : \type{A}\)
\item A function \(\function{f} : \type{A} \rightarrow \type{C}\)
\item A constructor \(\constructor{f} : \type{A} \rightarrow \type{C}\) \todo{better description, not always a function}
\item A destructor \(\destructor{f} : \type{A} \rightarrow \type{C}\) \todo{better description, not always a function}
\item A path \(\pathterm{p} : \type{A} \equiv \type{C}\), heterogeneous paths are denotes \(\equiv_p\) or if the path is clear from context \(\equiv_*\).
\item A relation \(\relation{R} : \type{A} \rightarrow \type{A} \rightarrow \universe{\mathcal{U}}\) with notation \(\term{x}~\relation{R}~\term{y}\).
\item The unit type is \(\unit\) while the empty type is \(\empt\).
\item A functor \(\functor{P}\)
\item A container is denoted as \(\container{S}\) or \(\containerpair{\type{A}}{\typeformer{B}}\)
\item A coalgebra \(\coalg{\type{C}}{\function{\gamma}}\)
\item We denote the function giving the first and second projection of a dependent pair by \(\pi_1\) and \(\pi_2\).
\end{itemize}

Furthermore we define some useful notation
\begin{defn}
  \begin{equation}
    \natcases{\term{x}}{\function{f}} = \lambda\,n, \begin{cases} \term{x} & n = 0 \\ \function{f}~m & n = m + 1 \end{cases}
  \end{equation}
\end{defn}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Background Theory}
We start by giving some background theory summarizing important concepts used in the rest of this thesis.
\section{Proof assistants}
\section{Set Theory}
\todo{Should this be included}

\section{Type Theory}
Type theory is the computational angle on a basis for mathematics. In type theory every term \(\term{x}\) is an element of some type \(\type{A}\), written \(\term{x} : \type{A}\). The idea in type theory is that propositions are types, so proofs boils down to showing that there exists an element of some type representing a proposition. Specifically proofs of equality becomes construction of an element of an equality type.

\subsection{Martin L\"of Type Theory / Intuitionistic type Theory (MLTT/ITT)}
Per Matin-L\"of designed the type theory on the principles of mathmatical constructivism, where any existance proof must contain a witness. Meaning a proof that there exists an element, such that something is true, can be converted into an algorithm that finds that element. The type theory is built from the three finite types \(\empt\), \(\unit\) and \(\type{\mathbf{2}}\), and type constructors \(\Sigma\), \(\pi\) and \(=\). There is only a single way to make terms of \(=\)-type, and that is \(\mathtt{refl} : \prod_{a : A} (a = a)\). \todo{inductive types, universes and judgements} \todo{extensional vs intensional} \todo{find citation, currently \url{https://en.wikipedia.org/wiki/Intuitionistic_type_theory}}.
\subsubsection{Intensional Type Theory}
\todo{\url{https://ncatlab.org/nlab/show/intensional+type+theory}}

\section{The Univalence Axiom}
The map
\begin{equation}
  \typeformer{id}_{\universe{\mathcal{U}}}~\type{A}~\type{B} \rightarrow \typeformer{Equiv}~\type{A}~\type{B}
\end{equation}
is an equivalence, simplifying a bit, identity is equivalent to equivalence
\begin{equation}
  (\type{A} = \type{B}) \simeq (\type{A} \simeq \type{B})
\end{equation}
Or said in another way equivalent types are identical.

\section{Homotopy Type Theory (HoTT) / Univalent Foundations (UF)}
Homotopy type theory is an intensional dependent type theory (built on MLTT) with the univalence axiom and higher inductive types. Homotopy type theory is constructive by default, but can be made classical.

is a type theory where the idenitity types form path spaces, so proofs of identity are not just \texttt{refl}, as for MLTT. Types are seen as "spaces" or (higher groupoids), and we think of \(\term{a} : \type{A}\) as \(\term{a}\) being a point in the space \(\type{A}\), similarly functions are regarded as continuous maps from one space to another. \cite{nlab:homotopy_type_theory}

\subsection{Judgmental Equality / Definitional Equality}
This means equal by definition, denoted \(a \equiv b\). It does not make sense to assume definitional equality (inside the theory). The equality is algorithmically decidable (meta-theoretic algorithm, not internal). 

\subsection{Propositional Equality}
If the equality \(a =_{A} b\) is inhabited, then we get propositional equality.

\subsection{External (of theory)}
\subsection{Internal (of theory)}

\subsection{Constructivity}
From every proof we can extract an algorithm, that produces an element of the proposition.

\subsubsection{Proof relevant mathematics}

\subsection{Homotopy \(n\)-types}
The 0-types are the hSets, (-1)-types are mere propositions or hProp. So all elements of a type that is an hProp, will be equal. All equalities between elements of types that are hSets, are equal. For 1-types (1-groupoids) we get equalities of equalities are equal, and then so on for homotopy \(n\)-types.

\subsection{The HoTT Book}

\section{Higher order inductive types (HITs)}
\subsection{Propositional truncation and Set Truncated Quotients}

\section{Cubical Type Theory (CTT)}
Cubical type theory is a version of homotopy type theory where univalence actually computes, meaning it is not just an axiom, but can actually be proven. \cite{nlab:cubical_type_theory}

\subsection{UIP}
\subsection{Cubical Agda}
Cubical Agda is an implementation of a cubical type theory by extending the proof assistant Agda. One of the main additions is the interval and path types. The interval can be thought of as elements in \([0,1]\). When working with the interval, we can only access the left and right endpoint \(\constant{i0}\) and \(\constant{i1}\) or some unspecified point in the middle \(i\), modeling the intuition of a continuous interval. Cubical agda also generalizes transporting, given a type line \(\typeformer{A} : \mathbb{I} \rightarrow \universe{\mathcal{U}}\), and the endpoint \(\typeformer{A}~\constant{i0}\) you get a line from \(\typeformer{A}~\constant{i0}\) to \(\typeformer{A}~\constant{i1}\) \cite{cubicalagda}

\todo[inline]{Axioms of cubical Agda}
The theory of cubical Agda is a Cartesian closed category, meaning get exponentials.
\\ \\
\todo[inline]{Something about the interval type!!}

\subsubsection{Path type}
We add a type \(\mathbb{I}\), which is defined to be a free de Morgan algebra on a discrete infinite set of names \todo{cite: https://arxiv.org/pdf/1611.02108.pdf}. The elements of \(\mathbb{I}\) can be described by the grammar
\begin{equation}
  r,s ::= 0 \mid 1 \mid i \mid 1 - r \mid r \land s \mid r \lor s
\end{equation}
The set \(\mathbb{I}\) has decidable equality. The elements in \(\mathbb{I}\) can be thought as formal representations of elements in the unit interval \([0,1]\). There is a special substitution with \(\constant{i0}\) and \(\constant{i1}\) being the endpoints of \([0,1]\).


\section{Coinduction}
Coinduction is the dual concept (in a categorical manner) of induction. The induction principle is an equivalence principle for congruent elements in an initial algebra.

\section{W-types}

\section{Problems with / Getting around using AC and LEM}
These axioms does not have a computational interpretation, so to maintain the computational aspects of HoTT and CTT, we try to not use these axioms. \cite[Introduction]{hottbook}

\section{Universes ??}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{\texttt{M}-types}
\label{ch:m-types}
\section{Containers / Signatures}
In this section we will introduce containers (also known as signatures), and show how to use these to construct a coalgebra. 
\begin{defn}
  A Container (or signature) is a dependent pair \(\container{S} = (\type{A},\typeformer{B})\) for the types \(\type{A} : \universe{\mathcal{U}}\) and \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\).
\end{defn}
\noindent From a container we can define a polynomial functor.
\begin{defn}
  A polynomial functor is defined for objects (types) as
  \begin{equation}
    \begin{aligned}
      \functor{P}_{\container{S}} &: \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
      \functor{P}(\type{X}) := \functor{P}_{\container{S}}(\type{X}) &= \sum_{\term{a} : \type{A}} \typeformer{B}(\term{a}) \rightarrow \type{X}
    \end{aligned}
  \end{equation}
  and for a function \(\function{f} : \type{X} \rightarrow \type{Y}\) as
  \begin{equation}
    \begin{aligned}
      \functor{P}\function{f} &: \functor{P}\type{X} \rightarrow \functor{P}\type{Y} \\
      \functor{P}\function{f}(\term{a},\function{g}) &= (\term{a}, \function{f} \circ \function{g}).
    \end{aligned}
  \end{equation}
\end{defn}
\noindent Using these definitions we can now define the polynomial functor used to construct the type of streams.
\begin{exmp}
  The type for streams over the type \(\type{A}\) is defined by the container \(\container{S} = (\type{A},\lambda\,\_, \unit)\), applying the polynomial functor for the container \(\container{S}\), we get
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X}.
  \end{equation}
  Since we are working in a Category with exponentials, we get \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\). Furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\), so this will be equivalent to the definition
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \type{A} \times \type{X}.
  \end{equation}
\end{exmp}
\noindent We now construct the \(\functor{P}\)-coalgebra for a polynomial functor \(\functor{P}\).
\begin{defn}
  A \(\functor{P}\)-coalgebra is defined as
  \begin{equation}
    \typeformer{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow \functor{P}\type{C}.
  \end{equation}
  We denote a \(\functor{P}\)-coalgebra give by \(\type{C}\) and \(\function{\gamma}\) as \(\coalg{\type{C}}{\function{\gamma}}\). The coalgebra morphisms are defined as
  \begin{equation}
    \begin{aligned}
      \cdot \Rightarrow ~\cdot &: \typeformer{Coalg}_{\container{S}} \rightarrow \typeformer{Coalg}_{\container{S}} \\
      \coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{D}}{\function{\delta}} &= \sum_{\function{f} : \type{C} \rightarrow \type{D}} \function{\delta} \circ \function{f} = \functor{P} \function{f} \circ \function{\gamma}
    \end{aligned}
  \end{equation}
\end{defn}
\noindent We can now define \texttt{M}-types.
\begin{defn}
  Given a container \(\container{S}\), we define \(\mathtt{M}\)-types, as the type \(\typeformer{M}_{\container{S}}\), making the coalgebra given by \(\typeformer{M}_{\container{S}}\) and \(\function{out} : \typeformer{M}_{\container{S}} \rightarrow \functor{P}_{\container{S}}(\typeformer{M}_{\container{S}})\) fulfill the property
  \begin{equation}
    \typeformer{Final}_{\container{S}} := \sum_{(\coalg{\type{X}}{\function{\rho}} : \mathtt{Coalg}_{\container{S}})} \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{X}}{\function{\rho}}).
  \end{equation}
  That is \(\prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\typeformer{M}_{\container{S}}}{\function{out}})\). We denote the \texttt{M}-type as \(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}\) or \(\typeformer{M}_{\container{S}}\) or just \(\typeformer{M}\) when the Container is clear from the context.
\end{defn}
\noindent Continuing our example we now construct an \(\mathtt{M}\)-type for streams.
\begin{exmp} Given the polynomial functor \(\functor{P}_{\containerpair{\type{A}}{\lambda\,\_,\unit}} \typeformer{M} = \type{A} \times \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\) for streams, we get the diagram in \figref{stream-M-type},
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{A} & \type{A} \times \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \\
      & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[ul,"\destructor{hd}"] \ar[u,"\function{out}"'] \ar[ur,"\destructor{tl}"']
    \end{tikzcd}
    \caption{\texttt{M}-types of streams}
    \label{fig:stream-M-type}
  \end{figure}
  where \(\function{out}\) is an isomorphism (because of the finality of the coalgebra), with inverse \(\function{in} : \functor{P}_{\container{S}}(\typeformer{M}) \rightarrow \typeformer{M}\). We now have a semantic for the rules, we would expect for streams, if we let \(\constructor{cons} = \function{in}\) and \(\typeformer{stream}~\type{A} = \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\),
  \begin{equation}
    \infer[\mathtt{E}_{\destructor{hd}}]{\destructor{hd}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{E}_{\destructor{tl}}]{\destructor{tl}~\term{s} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{I}_{\constructor{cons}}]{\term{\constructor{cons}}~\term{x}~\term{xs} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \typeformer{stream}~\type{A}}
  \end{equation}
  or more precisely \(\destructor{hd} = \pi_1 \circ \function{out}\) and \(\destructor{tl} = \pi_2 \circ \function{out}\).
\end{exmp}
\begin{defn}
  We define a chain as a family of morphisms \(\function{\pi}_{(n)} : \type{X}_{n+1} \rightarrow \type{X}_{n}\), over a family of types \(\type{X}_{n}\). See \figref{x-chain}.
  \begin{figure}
    \label{fig:x-chain}
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"]
    \end{tikzcd}
    \caption{Chain of TODO}
  \end{figure}  
\end{defn}
\begin{lem}\label{lem:function-to-M-type-is-cone}
  For all coalgebras \(\coalg{\type{C}}{\function{\gamma}}\) for the container \(\container{S}\), we get \(\type{C} \rightarrow \typeformer{M}_{\container{S}} \equiv \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\), where \(\typeformer{Cone} = \sum_{(\function{f} : \prod_{(n : \mathbb{N})} \type{C} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ (\function{f}_{(n+1)}) \equiv f_n\)
  \begin{figure}
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"] \\
      & & \type{C} \ar[ull,"\function{f}_0"] \ar[ul,"\function{f}_1"'] \ar[u,draw=none,"\cdots" description] \ar[ur,"\function{f}_n"] \ar[urr,"\function{f}_{n+1}"'] \ar[urrr,draw=none,"\cdots"'] & 
    \end{tikzcd}
    \caption{Cone}
  \end{figure}  
  \begin{proof}
    We define an isomorphism from \(\type{C} \rightarrow \typeformer{M}_{\container{S}}\) to \(\typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\)
    \begin{align}
      &\function{fun}_{\pathterm{collapse}}~\function{f} = (\lambda\,n\,\term{z},\pi_1~(\function{f}~\term{z})~n),(\lambda\,n~i~\term{a},~\pi_2~(\function{f}~\term{a})~n~i) \\
      &\function{inv}_{\pathterm{collapse}}~(\function{u},\function{q})~\term{z} = (\lambda\,n,~\function{u}~n~\term{z}),(\lambda\,n\,i,~\function{q}~n~i~\term{z}) \\
      &\function{rinv}_{\pathterm{collapse}}~(\function{u},\function{q}) = \mathtt{refl}_{(\function{u},\function{q})} \\
      &\function{linv}_{\pathterm{collapse}}~\function{f} = \mathtt{refl}_{\function{f}}
    \end{align}
  \end{proof}
\end{lem}
\begin{lem}\label{lem:limit-collapse}
  Given \(\function{\ell} : \prod_{(n : \mathbb{N})} (\type{X}_{n} \rightarrow \type{X}_{n+1})\) and \(\term{y} : \sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \term{l}_n~\term{x}_n\) the chain collapses as the equality \(\type{\mathcal{L}} \equiv \type{X}_0\).
  \begin{proof}
    We define this collapse by the isomorphism
    \begin{align}
      \function{fun}_{\mathcal{L}collapse}~(\term{x} , \pathterm{r}) &= \term{x}_0 \\
      \function{inv}_{\mathcal{L}collapse}~\term{x}_0 &= (\lambda\,n,~\function{\ell}^n~\term{x}_0)~,~(\lambda\,n,~\mathtt{refl}_{(\function{\ell}^{(n+1)}\,\term{x}_0)}) \\
      \function{rinv}~\term{x}_0 &= \mathtt{refl}_{\term{x}_0}
    \end{align}
    where \(\function{\ell}^n = \function{\ell}_n \circ \function{\ell}_{n-1} \circ \dots \circ \function{\ell}_1 \circ \function{\ell}_0\). To define \(\function{linv}~(\term{x} , \pathterm{r})\), we first define a fiber \((\type{X} , \term{z}, \function{\ell})\) over \(\mathbb{N}\) given some \(\term{z} : \type{X}_0\). Then any element of the type \(\sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) is equal to a section over the fiber we defined. This means \(\term{y}\) is equal to a section. Since the sections are defined over \(\mathbb{N}\), which is an initial algebra for the functor \(\functor{G}\type{Y} = \unit + \type{Y}\), we get that sections are contractible, meaning \(\term{y} \equiv \function{inv}_{\mathcal{L}collapse} (\function{fun}_{\mathcal{L}collapse}~\term{y})\), since both are equal to sections over \(\mathbb{N}\).
\end{proof}
\end{lem}
\noindent We can now define the construction of \function{in} and \function{out}.
\begin{thm}
   Given the container \(\containerpair{\type{A}}{\typeformer{B}}\) we define the equality
  \begin{equation}
    \pathterm{shift} : \type{\mathcal{L}} \equiv \functor{P}\type{\mathcal{L}}
  \end{equation}
  where \(\functor{P}\type{\mathcal{L}}\) is the limit of a shifted sequence. Then
  \begin{equation}
    \function{in} = \mathtt{transport}~\pathterm{shift}
  \end{equation}
  \begin{equation}
    \function{out} = \mathtt{transport}~(\sym{\pathterm{shift}}).
  \end{equation}
  \begin{proof}
    The proof is done using the two helper lemmas
    \begin{equation}
      \pathterm{\alpha} : \type{\mathcal{L}}^{\functor{P}} \equiv \functor{P}\type{\mathcal{L}}
    \end{equation}
    \begin{equation}
      \pathterm{\mathcal{L}unique} : \type{\mathcal{L}} \equiv \type{\mathcal{L}}^{\functor{P}}
    \end{equation}
    We define \(\pathterm{\mathcal{L}unique}\) by the ismorphism
    \begin{align}
      \function{fun}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \natcases{\unitelem}{\function{a}} , \natcases{\mathtt{refl}_{\unitelem}}{\function{b}} \\
    \function{inv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \function{a} \circ \constructor{succ}~,~\function{b} \circ \constructor{succ} \\
    \function{rinv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})} \\
    \function{linv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})}
    \end{align}
    The definition of \(\pathterm{\alpha}\) is then, 
    \begin{align}
      \type{\mathcal{L}}^{\functor{P}} &\equiv \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \\
      &\equiv \sum_{(\term{x} : \sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n)} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,{(\pi_1\,\term{x})}_n \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv_* \function{u}_n \label{eq:alpha-unfold} \\
      &\equiv \sum_{(\term{a} : \type{A})} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,a \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n \label{eq:alpha-limit-collapse} \\
      &\equiv \sum_{\term{a} : \type{A}} \typeformer{B}~\term{a} \rightarrow \type{\mathcal{L}} \label{eq:alpha-cone}\\
      &\equiv \functor{P}\type{\mathcal{L}}
    \end{align}
    To collapse \(\sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n\) to \(\type{A}\) between \eqref{eq:alpha-unfold} and \eqref{eq:alpha-limit-collapse} we use \lemref{limit-collapse} . We use \lemref{function-to-M-type-is-cone} for the equality between \eqref{eq:alpha-limit-collapse} and \eqref{eq:alpha-cone}. The rest of the equalities are given by a simple isomorphism or by definition. The definition of \(\pathterm{shift}\) is
    \begin{equation}
      \pathterm{shift} = \sym{\pathterm{\alpha}} \ct \pathterm{\mathcal{L}unique}.
    \end{equation}
    We furthermore get the definitions \(\function{in} = \mathtt{transport}~\pathterm{shift}\) and \(\function{out} = \mathtt{transport}~(\sym{\pathterm{shift}})\), since \function{in} and \function{out} are part of an equality relation (\(\pathterm{shift}\)), they are both surjective and embeddings.
    \end{proof}
\end{thm}

\section{Coinduction Principle for \texttt{M}-types}
We can now construct a coinduction principle given a bisimulation relation
% Let (S;  S) and (T;  T) be F-systems. A subsetRSTof the Cartesianproduct ofSandTis called anF-bisimulationbetweenSandTif there exists anF-transition structureR:R!F(R) such that the projections fromRtoSandTareF-homomorphisms

\begin{defn}
  For all coalgebras \(\coalg{\type{C}}{\term{\gamma}} : \typeformer{Coalg}_{\container{S}}\), given a relation \(\relation{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\) and a type \(\type{\overline{\mathcal{R}}} = \sum_{\term{a} : \type{C}} \sum_{\term{b} : \type{C}} \term{a}~\relation{\mathcal{R}}~\term{b}\), such that \(\type{\overline{\mathcal{R}}}\) and \(\term{\alpha}_{\relation{\mathcal{R}}} : \type{\overline{\mathcal{R}}} \rightarrow \functor{P}(\type{\overline{\mathcal{R}}})\) forms a \(\functor{P}\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} : \mathtt{Coalg}_{\container{S}}\), making the diagram in \figref{coalgebra-coinduction-definition} commute (\(\Longrightarrow\) represents \(\functor{P}\)-coalgebra morphisms).  
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\type{C}}{\term{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\term{\gamma}}
    \end{tikzcd}
    \caption{Bisimulation for a coalgebra}
    \label{fig:coalgebra-coinduction-definition}
  \end{figure}
\end{defn}
\begin{defn}[Coinduction principle]
  \noindent Given a relation \(\relation{\mathcal{R}}\), that is part of a bisimulation over a final \(\functor{P}\)-coalgebra \(\coalg{\typeformer{M}}{\term{\mathtt{out}}}:\mathtt{Coalg}_{\container{S}}\) we get the diagram in \figref{final-coalgebra-coinduction},
  
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Bisimulation principle for final coalgebra}
    \label{fig:final-coalgebra-coinduction}
  \end{figure}
  \noindent where \(\pi_1^{\type{\overline{\mathcal{R}}}} = ~! = \pi_2^{\type{\overline{\mathcal{R}}}}\), which means given \(\term{r} : \term{m}~\relation{\mathcal{R}}~\term{m'}\) we get the equation
  \begin{equation}
    \term{m} = \pi_1^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \pi_2^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \term{m'}.
  \end{equation}
\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Instantiation of M-types}
\section{Stream Formalization using \texttt{M}-types}
As described earlier, given a type \(\type{A}\) we define the stream of that type as
\begin{equation}
  \typeformer{stream}~\type{A} := \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}
\end{equation}
this is equal to an alternative definition of streams \todo{...}

\section{ITrees as \texttt{M}-types}
We want the following rules for ITrees
\begin{equation}
  \infer[\mathtt{I}_{\constructor{Ret}}]{\constructor{Ret}~\term{r} : \typeformer{itree}~\typeformer{E}~\type{R}}{r : \type{R}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_{\constructor{Vis}}]{\constructor{Vis}~\term{a}~\term{f} : \typeformer{itree}~\typeformer{E}~\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \typeformer{E}~\type{A} & \term{f} : \type{A} \rightarrow \typeformer{itree}~\typeformer{E}~\type{R}}.
\end{equation}
Elimination rules
\begin{equation}
  \infer[\mathtt{E}_{\constructor{Tau}}]{\constructor{Tau}~\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}{\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}.
\end{equation}

\subsection{Delay Monad}
We start by looking at ITrees without the \(\constructor{Vis}\) constructor, this type is also know as the delay monad\todo[inline]{check this statement}. We construct this type by letting \(\container{S} = (\unit + \type{R},\lambda \{ \texttt{inl}~\_ \rightarrow \unit~;~\texttt{inr}~\_ \rightarrow \empt \})\), we then get the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{x} : \unit + \type{R}} \lambda \{ \texttt{inl}~\_ \rightarrow \unit ; \texttt{inr}~\_ \rightarrow \empt\}~\term{x} \rightarrow \type{X},
\end{equation}
which is equal to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R} \times (\empt \rightarrow \type{X}).
\end{equation}
We know that \((\empt \rightarrow \type{X}) \equiv \unit\), so we can reduce further to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R}
\end{equation}
meaning we get the following diagram.

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\constructor{now}"'] \ar[r,"\texttt{inl}"] & \type{R} + \typeformer{M}  & \typeformer{M} \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{later}"] \\
    & \typeformer{M} \ar[u,"\function{out}"']
  \end{tikzcd}
  \caption{Delay monad}
\end{figure}
\noindent Meaning we can define the operations \(\constructor{now}\) and \(\constructor{later}\) using \(\function{in} = \function{out}^{-1}\) together with the injections \(\mathtt{inl}\) and \(\mathtt{inr}\). \todo[inline]{(Later = Tau, Ret = Now)}

\subsection{Tree}
Now lets look at the example where we remove the \(\constructor{Tau}\) constructor. We let
\begin{equation}
  \container{S} = \left(\type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A}~,~\lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \} \right).
\end{equation}
This will give us the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{x} : \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A}} \lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \}~\term{x} \rightarrow \type{X},
\end{equation}
which simplifies to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X})),
\end{equation}
and further
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X}).
\end{equation}
We get the following diagram for the \(\functor{P}\)-coalgebra.

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\function{Ret}"'] \ar[r,"\texttt{inl}"] & \type{R} + \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})  & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[l,"\texttt{inr}"'] \ar[dl,"\function{Vis}"] \\
    & \typeformer{M} \ar[u,"\function{out}"]
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Again we can define \(\function{Ret}\) and \(\function{Vis}\) using the \(\function{in}\) function.

\subsection{ITrees}
\todo[inline]{Get the correct equivalence for ITrees (Part of project description?)}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types. We define ITrees by the container
\begin{equation}
  \container{S} = \left( \unit+\type{R}+\sum_{\type{A}:\universe{\mathcal{U}}} (\typeformer{E}~\type{A}) ~~,~~ \lambda\left\{ \texttt{inl}~(\texttt{inl}~\_) \rightarrow \unit ~;~ \texttt{inl}~(\texttt{inr}~\_) \rightarrow \empt ~;~ \texttt{inr} (\type{A},\_)  \rightarrow \type{A} \right\} \right).
\end{equation}
Such that the (reduced) polynomial functor becomes
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} ((\typeformer{E}~\type{A}) \times (\type{A} \rightarrow \type{X}))
\end{equation}
Giving us the diagram
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[ddrr,"\function{Ret}"'] \ar[r,"\texttt{inl}\,\circ\,\texttt{inr}"] & \typeformer{M} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} (\typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})) & & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[ll,"\texttt{inr}"'] \ar[ddl,"\function{Vis}"] \\
    & & \typeformer{M} \ar[ul,"\texttt{inl}\,\circ\,\texttt{inl}"'] \ar[d,"\function{Tau}"'] \\
    & & \typeformer{M} \ar[uul,"\function{out}"]
  \end{tikzcd}
  \caption{TODO}
\end{figure}

\section{Automaton}
An automaton is defined as a set of state \(\type{V}\) and an alphabet \(\type{\alpha}\) and a transition function \(\function{\delta} : \type{V} \rightarrow \type{\alpha} \rightarrow \type{V}\). This gives us the diagram in \figref{automaton}
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{V} \times (\type{V} \rightarrow \type{\alpha} \rightarrow \type{V}) \ar[dr,"build"'] \ar[r] & M & M \ar[dl,"step"] \\
    & M
  \end{tikzcd}
  \caption{automaton}
  \label{fig:automaton}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{QM-types}
\section{Quotienting and constructors}
\todo[inline]{Describe set truncated quotients and their construction / elimination principles, and how it relates to quotienting M-types}
\section{Quotient \texttt{M}-type}
We want to construct a quotient \texttt{M}-type, and we know that \texttt{M}-types are an algebraic theory? Meaning we want to define quotient algebra...

We want to construct a quotiented M type, which is given as a final bisimulation and a final coalgebra, and relations between them. This is a special case for a cofree coalgebra, namely starting at \(X = \unit\).
\\ \\
Since we know that \texttt{M}-types preserves the H-level, we can use set-truncated quotients, to define quotient \texttt{M}-types, for examples we can define weak bisimulation of the delay monad ...
\todo[inline]{Quotients of the delay monad}

\section{Quotient inductive-inductive types (QIITs)}
"A quotient inductive-inductive type (QIIT) can be seen as a multi-sorted algebraic theory where sorts can be indexed over each other" - "Constructing Quotient Inductive-Inductive Types"

"W-types can be seen informally as the free algebras for signatures with operations of possibly infinite arity, but no equations." -- \url{https://arxiv.org/pdf/1201.3898.pdf}

A quotient inductive-inductive type (QIIT) is a type together with a relation defined on that type, and then quotiented by that relation.
\todo[inline]{What is a QIIT concretely?}

\section{Partiality monad}
In this section we will define the partiality monad (see below) and show that (assuming the axiom of countable choice) the delay monad quotiented by weak bisimularity.
\begin{defn}[Partiality Monad]
  A simple example of a quotient inductive-inductive type is the partiality monad \((-)_\bot\) over a type \(\type{R}\), defined by the constructors\\[-9mm]
  \begin{center}
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \infer{\type{R}_\bot : \universe{\mathcal{U}}}{}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \infer{\constructor{\bot} : \type{R}_\bot}{}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \infer{\constructor{\eta}~\term{a} : \type{R}_\bot}{\term{a} : \type{R}}
      \end{equation}
    \end{minipage}
  \end{center}
  and a relation \((\cdot~\relation{\sqsubseteq_{\bot}}~\cdot)\) indexed twice over \(\type{R}_\bot\), with properties\\[-9mm] \todo{Should I define what it means to be an ordering relation separately, and just say the relation here is an instance of that? (Generalize?)}
  \begin{center}
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \infer{\constructor{\bigsqcup}~(\function{s},\function{b}) : \type{R}_\bot}{\function{s} : \mathbb{N} \rightarrow \type{R}_\bot & \function{b} : \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\function{s}_{n+1} }
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \infer{\constructor{\alpha_{\bot}}~\term{p}~\term{q} : \term{x} \equiv \term{y}}{\term{x},\term{y} : \type{R}_\bot & \term{p} : \term{x}~\relation{\sqsubseteq_{\bot}}~\term{y} & \term{q} : \term{y}~\relation{\sqsubseteq_{\bot}}~\term{x}}
      \end{equation}
    \end{minipage}
  \end{center}
  \strut\\[-15mm]
  \begin{center}
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \infer[\constructor{\sqsubseteq_{refl}}]{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{x}}{\term{x} : \type{R}_\bot}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.35\linewidth}
      \begin{equation}
        \infer[\constructor{\sqsubseteq_{trans}}]{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{z}}{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{y} & \term{y}~\relation{\sqsubseteq_{\bot}}~\term{z}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \infer[\constructor{\sqsubseteq_{never}}]{\constructor{\bot}~\relation{\sqsubseteq_{\bot}}~\term{x}}{\term{x} : \type{R}_\bot}
      \end{equation}
    \end{minipage}
  \end{center}
  \strut\\[-15mm]
  \begin{center}
    \hfill
    \begin{minipage}{0.50\linewidth}
      \begin{equation}
        \infer{\prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\bigsqcup(\function{s},\function{b})}{\function{s} : \mathbb{N} \rightarrow \type{R}_\bot & \function{b} : \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\function{s}_{n+1} }
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\linewidth}
      \begin{equation}
        \infer{\bigsqcup(\function{s},\function{b})~\relation{\sqsubseteq_{\bot}}~\term{x}}{\prod_{(n:\mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\term{x}}
      \end{equation}
    \end{minipage}
  \end{center}
  and finally set truncated
  \begin{equation}
    \infer[\constructor{(-)_\bot\text{-}isSet}]{\term{p} \equiv \term{q}}{\term{p} , \term{q} : \term{x}~\relation{\sqsubseteq_{\bot}}~\term{y}}
  \end{equation}
\end{defn}

\subsection{Delay monad to Sequences}
\todo[inline]{Introduce the delay monad before this section!!}
\begin{defn}
  We define
  \begin{equation}
    \typeformer{Seq}_{\type{R}} = \sum_{(\function{s} : \mathbb{N} \rightarrow \type{R} + \unit)} \function{isMon}~\function{s}
  \end{equation}
  where
  \begin{equation}
    \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} (\function{s}_n \equiv \function{s}_{n+1})  + ((\function{s}_n \equiv \mathtt{inr}~\unitelem) \times (\function{s}_{n+1} \not\equiv \mathtt{inr}~\unitelem))
  \end{equation}
  meaning a sequences is \(\mathtt{inr}~\unitelem\) until it reaches a point where it switches to \(\mathtt{inl}~\term{r}\) for some value \(\term{r}\). There are also the special cases of already terminated, meaning only \(\mathtt{inl}~\term{r}\) and never teminating meaning only \(\mathtt{inr}~\unitelem\).
\end{defn}
\noindent For each index in a sequence, the element at that index \(\function{s}_n\) is either not terminated \(\function{s}_n \equiv \mathtt{inr}~\unitelem\), which we denote as \(\function{s}_n \uparrow_{\type{R} + \unit}\), or it is terminated \(\function{s}_n \equiv \mathtt{inl}~\term{r}\) with some value \(r\), denoted by \(\function{s}_n \downarrow_{\type{R} + \unit} \term{r}\) or just \(\function{s}_n \downarrow_{\type{R} + \unit}\) to mean \(\function{s}_n \not\equiv \mathtt{inr}~\unitelem\). Thus we can write \(\function{isMon}\) as
\begin{equation}
  \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} (\function{s}_n \equiv \function{s}_{n+1})  + ((\function{s}_n \uparrow_{\type{R} + \unit}) \times (\function{s}_{n+1} \downarrow_{\type{R} + \unit}))
\end{equation}
We also introduce notation for the two special cases of sequences given above
\begin{equation}
  \function{now}_{Seq}~\term{r} = (\lambda\,\_, \mathtt{inl}~\term{r}) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl})
\end{equation}
\begin{equation}
  \constant{never}_{Seq} = (\lambda\,\_, \mathtt{inr}~\unitelem) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl})
\end{equation}
\todo[inline]{Some comment about decidable equivalence needed to show that \(\function{s}_{n+1} \not\equiv \mathtt{inr}~\unitelem\)}
\begin{defn}
  We can shift a sequence \((\function{s},\function{q})\) by inserting an element (and an equality) \((\term{z_s},\term{z_q})\) at \(n = 0\),
  \begin{equation}
    \function{shift}~(\function{s} , \function{q})~(\term{z_s} , \term{z_q}) = \begin{cases} \term{z_s} & n = 0 \\ \function{s}_m & n = m + 1 \end{cases} , \begin{cases} \term{z_q} & n = 0\\ \function{q}_m & n = m + 1 \end{cases},
  \end{equation}
\end{defn}
\begin{defn}
  We can unshift a sequence by removing the first element of the sequence
  \begin{equation}
    \begin{aligned}
      \function{unshift}&~(\function{s} , \function{q}) = \function{s} \circ \constructor{succ} , \function{q} \circ \constructor{succ}.
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  The function
  \begin{equation}
    \function{shift\text{-}unshift}~(\function{s},\function{q}) = \function{shift}~(\function{unshift}~(\function{s},\function{q}))~(\function{s}_0,\function{q}_0)
  \end{equation}
  is equal to the identity function.
  \begin{proof}
    Unshifting a value followed by a shift, where we reintroduce the value we just remove, gives the sequence we started  with.
  \end{proof}
\end{lem}
\begin{lem}
  The function
  \begin{equation}
    \function{unshift\text{-}shift}~(\function{s},\function{q})=\function{unshift}~(\function{shift}~(\function{s},\function{q})~\_)
  \end{equation}
  is equal to the identity function.
  \begin{proof}
    If we shift followed by an unshift, we just introduce a value to instantly remove it, meaning the value does not matter.
  \end{proof}
\end{lem}
\noindent We now define an equivalence between \(\typeformer{delay}~\type{R}\) and \(\typeformer{Seq}_{\type{R}}\), where \(\constructor{later}\) are equivalent to shifts, and \(\constructor{now}~\term{r}\) is equivalent terminated sequence with value \(\term{r}\). We do this by defining equivalence functions, and the left and right identities.
\begin{lem}[\(\constant{inl{\not\equiv}inr}\)]
  For any two elements \(\term{x} = \mathtt{inl}~\term{a}\) and \(\term{y} = \mathtt{inr}~\term{b}\) then \(\term{x} \not\equiv \term{y}\).
  \begin{proof}
    The constructors are disjoint, so there is not a path between them \todo{better formualted proof}.
  \end{proof}
\end{lem}
\begin{defn}
  We define function from \(\typeformer{Delay}~\type{R}\) to \(\typeformer{Seq}_{\type{R}}\)
  \begin{equation}
    \begin{aligned}
      \function{Delay{\rightarrow}Seq}&~(\constructor{now}~\term{r}) = \function{now}_{Seq}~\term{r} \\
      \function{Delay{\rightarrow}Seq}&~(\constructor{later}~\term{x}) = \\[-3mm]
      & \strut\hspace{-8mm}\function{shift}~(\function{Delay{\rightarrow}Seq}~\term{x})~\left(\mathtt{inr}~\unitelem , \begin{cases} \mathtt{inr}~(\mathtt{refl} , \constant{inl{\not\equiv}inr}) & \term{x} = \constructor{now}~\_ \\ \mathtt{inl}~\mathtt{refl} & \term{x} = \constructor{later}~\_ \end{cases}\right)
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  We define function from \(\typeformer{Seq}_{\type{R}}\) to \(\typeformer{Delay}~\type{R}\)
    \begin{equation}
      \begin{aligned}
        \function{Seq{\rightarrow}Delay}&~(\function{s} , \function{q}) = \begin{cases} \constructor{now}~\term{r} & \function{s}_0 = \mathtt{inl}~\term{r} \\ \constructor{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s} , \function{q}))) & \function{s}_0 = \mathtt{inr}~\unitelem \end{cases}
      \end{aligned}
    \end{equation}
\end{defn}
\begin{thm}
  The type \(\typeformer{Seq}_{\type{R}}\) is equal to \(\typeformer{Delay}~\type{R}\)
  \begin{proof}  
    We define right and left identity, saying that for any sequence \((\function{s},\function{q})\), we get
    \begin{equation}
      \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{s},\function{q})) \equiv (\function{s},\function{q})
    \end{equation}
    defined by cases analysis on \(\function{s}_0\), if \(\function{s}_0 = \mathtt{inl}~\term{r}\) then we need to show
    \begin{equation}
      \function{now}_{Seq}~\term{r} \equiv (\function{s},\function{q})
    \end{equation}
    This is true, since \((\function{s},\function{q})\) is a monotone sequence and \(\mathtt{inl}~\term{r}\) is the top element of the order, then all elements of the sequence are \(\mathtt{inl}~\term{r}\). If \(\function{s}_0 = \mathtt{inr}~\unitelem\) then, we need to show
    \begin{equation}
      \function{shift}~(\function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s},\function{q}))))~(\mathtt{inr}~\unitelem,\_) \equiv (\function{s},\function{q})
    \end{equation}
    by the induction hypothesis we get
    \begin{equation}
      \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s},\function{q}))) \equiv \function{unshift}~(\function{s},\function{q})
    \end{equation}
    since shift and unshift are inverse, we get the needed equality.
    \todo[inline]{Shift takes two arguemnts, either clarify that its shift' that inserts inr tt or ...}
    For the left identity, we need to show that for any delay monad \(\term{t}\) we get
    \begin{equation}
      \function{Seq{\rightarrow}Delay}~(\function{Delay{\rightarrow}Seq}~\term{t}) \equiv \term{t}
    \end{equation}
    defined by case analysis on \(\term{t}\), if \(\term{t} = \constructor{now}~a\) then the equality is \(\mathtt{refl}\). If \(\term{t} = \constructor{later}~\term{x}\) then we need to show
    \begin{equation}
      \constructor{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{shift}~(\function{Delay{\rightarrow}Seq}~x))) \equiv \constructor{later}~x
    \end{equation}
    By unshift and shift being inverse, and the induction hypothesis we get the wanted equality. Since we are able to define a left and right identity function, we get the wanted equality.
  \end{proof}
\end{thm}
\begin{cor}
  The types \(\typeformer{Delay}/\sim\) and \(\typeformer{Seq}/\sim\) are equal.
  \begin{proof}
    We show that if \(a~\relation{\sim_{delay}}~b\) then \(\function{Delay{\rightarrow}Seq}~a~\relation{\sim_{Seq}}~\function{Delay{\rightarrow}Seq}~b\), \todo{Show this}
    \\ \\
    and we show if \(x~\relation{\sim_{Seq}}~y\) then \(\function{Seq{\rightarrow}Delay}~x~\relation{\sim_{Seq}}~\function{Seq{\rightarrow}Delay}~y\), \todo{Show this}
  \end{proof}
\end{cor}

\subsection{Sequence to Partiality Monad}
In this section we will show that assuming the "Axiom of Countable Choice", we get an equivalence between sequences and the partiality monad.
\begin{defn}[Sequence Termination]
  The following relations says that a sequence \((\function{s},\function{q}) : \typeformer{Seq}_{\type{R}}\) terminates with a given value \(\term{r} : \type{R}\),
  \begin{equation}
    (\function{s},\function{q})~\relation{\downarrow_{\mathtt{Seq}}}~\term{r} = \sum_{(n : \mathbb{N})} \function{s}_n \downarrow_{\type{R} + \unit} \term{r}.
  \end{equation}
\end{defn}
\begin{defn}[Sequence Ordering]
  \begin{equation}
    (\function{s},\function{q})~\relation{\sqsubseteq_{\mathtt{Seq}}}~(\function{t},\function{p}) = \prod_{(\term{a} : \type{R})} \left(\|\function{s}~\relation{\downarrow_{\mathtt{Seq}}}~\term{a}\| \rightarrow \| \function{t}~\relation{\downarrow_{\mathtt{Seq}}}~\term{a}\|\right)
  \end{equation}
  where \(\| \cdot \|\) is propositional \todo{propositional or set truncation?} truncation.
\end{defn}
\begin{defn} There is a conversion from \(\type{R} + \unit\) to the partiality monad \(\type{R}_\bot\)
  \begin{equation}
    \begin{aligned}
      &\function{Maybe{\rightarrow}(-)_\bot}~(\mathtt{inl}~\term{r}) = \constructor{\eta}~\term{r} \\
      &\function{Maybe{\rightarrow}(-)_\bot}~(\mathtt{inr}~\unitelem) = \constructor{\bot}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}[Maybe Ordering]
  \label{eq:maybe-order}
  Given some \(x,y : \type{R} + \unit\), the ordering relation is defined as
  \begin{equation}
    \term{x}~\relation{\sqsubseteq_{\type{R} + \unit}}~\term{y} = (\term{x} \equiv \term{y}) + ((\term{x}  \downarrow_{\type{R} + \unit}) \times (\term{y} \uparrow_{\type{R} + \unit}))
  \end{equation}
\end{defn}
\noindent This ordering definition is basically \(\function{isMon}\) at a specific index, so we can again rewrite \(\function{isMon}\) as
\begin{equation}
  \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\type{R} + \unit}}~\function{s}_{n+1}
\end{equation}
This rewriting confirms that if \(\function{isMon}~\function{s}\), then \(\function{s}\) is monotone, and therefore a sequence of partial values\todo{there exists non-monotone sequences, it just follows our definition of a sequence.}.
\begin{lem}
  The function \(\function{Maybe{\rightarrow}(-)_\bot}\) is monotone, that is, if \(\term{x}~\relation{\sqsubseteq_{\type{A} + \unit}}~\term{y}\), for some \(\term{x}\) and \(\term{y}\), then \((\function{Maybe{\rightarrow}(-)_\bot}~\term{x})~\relation{\sqsubseteq_{\bot}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{y})\).
  \begin{proof}
    We do the proof by case.
    \begin{equation}
      \begin{aligned}
        &\function{Maybe{\rightarrow}(-)_\bot\text{-}mono}~(\function{inl}~\pathterm{p}) = \\[-1mm]
        &\qquad\qquad \mathtt{subst}~(\lambda\,\term{a},~\function{Maybe{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Maybe{\rightarrow}(-)_\bot}~\term{a})~\pathterm{p}~(\constructor{\sqsubseteq_{refl}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{x})) \\[1mm]
        &\function{Maybe{\rightarrow}(-)_\bot\text{-}mono}~(\function{inr}~(\pathterm{p}, \_)) = \\[-1mm]
        &\qquad\qquad \mathtt{subst}~(\lambda\,\term{a},~\function{Maybe{\rightarrow}(-)_\bot}~\term{a}~\relation{\sqsubseteq_{\bot}}~\function{Maybe{\rightarrow}(-)_\bot}~\term{y})~\sym{\pathterm{p}}~(\constructor{\sqsubseteq_{never}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{y}))
      \end{aligned}
    \end{equation}
  \end{proof}
\end{lem}
\begin{defn}
  There is a function taking a sequence to an increasing sequence \todo{What is an increasing sequence ??, this is not defined anywhere!!}
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}incSeq} \\
      &\function{Seq{\rightarrow}incSeq}~(\function{g} , \function{q}) = \function{Maybe{\rightarrow}(-)_\bot} \circ \function{g} , \function{Maybe{\rightarrow}(-)_\bot\text{-}mono} \circ \function{q}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  There is a function taking a sequence to the partiality monad
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}(-)_\bot} : \typeformer{Seq}_{\type{A}} \rightarrow \type{A}_{\bot} \\
      &\function{Seq{\rightarrow}(-)_\bot}~(\function{g},\function{q}) = \bigsqcup \circ~\function{Seq{\rightarrow}incSeq}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  The function \(\function{Seq{\rightarrow}(-)_\bot}\) is monotone. 
  \begin{equation}
    \function{Seq{\rightarrow}(-)_\bot\text{-}mono} : \typeformer{isSet} \type{A} \rightarrow (\term{x}~\term{y} : \typeformer{Seq}_{\type{A}}) \rightarrow \term{x}~\relation{\sqsubseteq_{seq}}~\term{y} \rightarrow \function{Seq{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}
\end{equation}
  \begin{proof}
    Given two sequences, if one is smaller than the another, then the least upper bounds of each sequence respect the ordering. \todo{should this be formalized entirely, or should there just be a comment about monotonicity? Does not seem relevant? (There is alot of work here..)}
  \end{proof}
\end{lem}
\begin{defn}
  If two sequences \(\term{x},\term{y}\) are weakly bisimular, then \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\)
\begin{equation}
  \function{Seq{\rightarrow}(-)_\bot\text{-}{\approx}{\rightarrow}{\equiv}}~\term{A_{set}}~\term{x}~\term{y}~(\term{p} , \term{q}) = \constructor{\alpha_{\bot}}~(\function{Seq{\rightarrow}(-)_\bot\text{-}mono}~\term{A_{set}}~\term{x}~\term{y}~\term{p})~(\function{Seq{\rightarrow}(-)_\bot\text{-}mono}~\term{A_{set}}~\term{y}~\term{x}~\term{q})
\end{equation}
\end{defn}
\begin{defn}[Recursor for Quotient]
  \todo{is this a recursor, and for what? The quotient?}
  For all sequences \(\term{x}, \term{y} : \typeformer{Seq}_{\type{A}}\), functions \(\function{f} : \type{A} \rightarrow \type{B}\) and relations \(\function{g} : \term{x}~\relation{R}~\term{y} \rightarrow \function{f}~\term{x} \equiv \function{f}~\term{y}\), then if \(\type{B}\) is a set \(\term{B_{set}} : \typeformer{isSet}~\type{B}\), we get a function \(\function{rec} : \type{A} / \relation{R} \rightarrow \type{B}\), defined by case as
  \begin{equation}
    \label{eq:quotient-recursor}
    \begin{aligned}
      &\function{rec}~\function{[}\,\term{z}\,\function{]} = \function{f}~\term{z} \\
      &\function{rec}~(\function{eq/}~\_~\_~\term{r}~i) = \function{g}~\term{r}~i \\
      &\function{rec}~(\function{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \term{B_{set}}~(\function{rec}~\term{a})~(\function{rec}~\term{b})~(\mathtt{ap}~\function{rec}~\pathterm{p})~(\mathtt{ap}~\function{rec}~\pathterm{q})~i~j
    \end{aligned}
  \end{equation}
\end{defn}
This recursor allows us to lift the function \(\function{Seq{\rightarrow}(-)_\bot}\) to the quotient
\begin{defn}
  \label{eq:QuotientedSeqToPartialityMonad}
  We can define a function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) from \(\typeformer{Seq}_{\type{A}}\) to \(\type{A}_{\bot}\), where \(\term{A_{set}} : \typeformer{isSet}~\type{A}\) as
  \begin{equation}
    \function{Seq/{\sim}{\rightarrow}(-)_\bot} = \function{rec}~\function{Seq{\rightarrow}(-)_\bot}~(\function{Seq{\rightarrow}(-)_\bot\text{-}{\approx}{\rightarrow}{\equiv}}~\term{A_{set}})~\constructor{(-)_\bot\text{-}isSet}
  \end{equation} 
\end{defn}
\begin{lem}
  \label{eq:injectivity-lemma}
  Given two sequences \(\term{s}\) and \(\term{t}\), if \(\function{Seq{\rightarrow}(-)_\bot}~\term{s} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{t}\), then \(\term{s}~\relation{\sim_{seq}}~\term{t}\).
  \begin{proof}
    We can reduce the burden of the proof, since
    \begin{equation}
      \term{s}~\relation{\sim_{seq}}~\term{t} = \left(\prod_{(\term{r} : \type{R})} \| \term{x}~\relation{\downarrow_{seq}}~\term{r} \| \rightarrow \| \term{y}~\relation{\downarrow_{seq}}~\term{r} \|\right) \times \left(\prod_{(\term{r} : \type{R})} \| \term{y}~\relation{\downarrow_{seq}}~\term{r} \| \rightarrow \| \term{x}~\relation{\downarrow_{seq}}~\term{r} \|\right)
    \end{equation}
    so we can just show one part and get the other by symmetry. We assume \(\| \term{x}~\relation{\downarrow_{seq}}~\term{r} \|\), to show \(\| \term{y}~\relation{\downarrow_{seq}}~\term{r} \|\). By the mapping property of propositional truncation, we reduce the proof to defining a function \(\term{x}~\relation{\downarrow_{seq}}~\term{r} \rightarrow \term{y}~\relation{\downarrow_{seq}}~\term{r}\). Since \(\term{x}~\relation{\downarrow_{seq}}~\term{r}\), then \(\constructor{\eta}~\term{r}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{x}\), but we have assumed \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\), so we get \(\constructor{\eta}~\term{r}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}\), and thereby \(\term{y}~\relation{\downarrow_{seq}}~\term{r}\).
  \end{proof}
\end{lem}
\begin{lem}
  The function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is injective.
  \begin{proof}
    We use propositional elimination of quotients \todo{Should this be formalized?}
    \begin{equation}
      \begin{aligned}
        \function{elimProp} :~& (\typeformer{B} :\typeformer{Seq}_{\type{R}} / \relation{\sim_{seq}} \rightarrow \universe{\mathcal{U}}) \rightarrow ((\term{x} : \typeformer{Seq}_{\type{R}} / \relation{\sim_{seq}}) \rightarrow \typeformer{isProp}~(\typeformer{B}~\term{x})) \\
        \rightarrow~& (\function{f} : (\term{a} : \typeformer{Seq}_{\type{R}}) \rightarrow \typeformer{B}~\function{[}~a~\function{]}) \rightarrow (\term{x} : \typeformer{Seq}_{\type{R}} / \relation{\sim_{seq}}) \rightarrow \typeformer{B}~\term{x}
      \end{aligned}
    \end{equation}
    to show the injectivity, meaning for all \(\term{x}~\term{y} : \typeformer{Seq}_{\type{R}} / \relation{\sim_{seq}}\) we get \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{y} \rightarrow \term{x} \equiv \term{y}\). We start by eliminating \(\term{x}\), followed by elimination of \(y\), this gives us the proof term \todo{Convert to text, instead of a proof term!?}
    \begin{equation}
      \begin{aligned}
        &\function{elimProp} \\
        &\quad (\lambda\,\term{a},~\function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{a} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{y} \rightarrow \term{a} \equiv \term{y}) \\
        &\quad (\lambda\,\term{a},~\function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\term{a}~\term{y})) \\
        &\quad (\lambda\,\term{a},~\function{elimProp} \\
        &\qquad\qquad\quad (\lambda\,\term{b},~\function{Seq{\rightarrow}(-)_\bot}~\term{a} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{b} \rightarrow \function{[}~\term{a}~\function{]} \equiv \term{b}) \\
        &\qquad\qquad\quad (\lambda\,\term{b},~\function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\function{[}~\term{a}~\function{]}~\term{b})) \\
        &\qquad\qquad\quad (\lambda\,\term{b},~(\constructor{eq/}~\term{a}~\term{b}) \circ (\function{Seq{\rightarrow}(-)_\bot\text{-}isInjective}~\term{a}~\term{b})))
      \end{aligned}
    \end{equation}
    where \(\function{Seq{\rightarrow}(-)_\bot\text{-}isInjective}\) is \eqref{eq:injectivity-lemma}, 
  \end{proof}
\end{lem}
\begin{lem}
  \label{eq:constant-sequence-equality}
  For all constant sequences \(\term{s}\), where all elements have the same value \(\term{v}\), we get \(\function{Seq{\rightarrow}(-)_\bot}~\term{s} \equiv \function{Maybe{\rightarrow}(-)_\bot}~\term{v}\).
  \begin{proof}
    The left side of the equality reduces to \(\function{Maybe{\rightarrow}(-)_\bot}\) applied on the least upper bound of the constant sequence, which is exactly the right hand side of the equality.
  \end{proof}
\end{lem}
\begin{lem}
  Assuming countable choice, the function \(\function{Seq{\rightarrow}(-)_\bot}\) is surjective
  \todo[inline]{describe countable choice (and why it is needed!)}
  \begin{proof}
    We do the proof by case \todo{describe what it means to do the surjective proof by case!} on \(\type{R}_{\bot}\), if it is \(\constructor{\eta}~r\) or \(\constructor{never}\), we convert them to the sequences \(\function{now}_{seq}~\term{r}\) and \(\constant{never}_{seq}\) respectively, then we are done by \eqref{eq:constant-sequence-equality}. For the least upper bound \(\constructor{\bigsqcup} (\function{s},\function{b})\), we translate to the (increasing) sequence, defined by \((\function{s},\function{b})\) \todo{more precise description!}. \todo{Complete the rest of the proof!}
  \end{proof}
\end{lem}
\begin{lem}
  Assuming countable choice, the function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is surjective
  
\end{lem}
\begin{thm}
  Assuming countable choice, we get an equivalence between sequences and the partiality monad.
  \begin{proof}
 The function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is injective and surjective assuming countable choice, meaning we get an equivalence, since we are working in hSets.
\end{proof}
\end{thm}

\subsubsection{Building the Partiality Monad as an M-type (Dialgebra?)}
\todo[inline]{Is this possible?}

\subsection{Silhouette Trees}
We start by defining an \(\type{R}\) valued \(\type{E}\) branching tree, as the \texttt{M}-type given by the following container
\begin{equation}
  \left(\type{R} + \unit , \begin{cases} \bot & \mathtt{inl}~\term{a} \\ \type{E} & \mathtt{inr}~\unitelem \end{cases}\right)
\end{equation}
We get the constructors
\begin{equation}
  \infer{\constructor{leaf}~\term{a} : \typeformer{tree}~\type{R}~\type{E}}{\term{a} : \type{R}}
\end{equation}
\begin{equation}
  \infer{\constructor{node}~\function{k} : \typeformer{tree}~\type{R}~\type{E}}{\function{k} : \type{E} \rightarrow \typeformer{tree}~\type{R}~\type{E}}
\end{equation}
Then we define the weak bisimularity relation \(\relation{\sim_{tree}}\)
\begin{equation}
  \infer[\constructor{\sim_{leaf}}]{\constructor{leaf}~x~\relation{\sim_{tree}}~\constructor{leaf}~y}{}
\end{equation}
\begin{equation}
  \infer[\constructor{\sim_{node}}]{\constructor{node}~\function{k_1}~\relation{\sim_{tree}}~\constructor{node}~\function{k_2}}{\prod_{(v : \type{E})}~\function{k_1}~\term{v}~\relation{\sim_{tree}}~\function{k_2}~\term{v}}
\end{equation}
This is enough to define, what we call, silhouette trees, which are trees quotiented by this notion of weak bisimularity, namely \(\typeformer{tree} / \relation{\sim_{tree}}\). We can also construct this type directly as a QIIT, with type constructors \todo{add all needed constructors}
\begin{equation}
  \infer{\constructor{leaf}_{\typeformer{sTree}} : \typeformer{sTree}~\type{E}}{}
\end{equation}
\begin{equation}
  \infer{\constructor{node}_{\typeformer{sTree}}~\function{k} : \typeformer{sTree}~\type{E}}{\function{k} : \type{E} \rightarrow \typeformer{sTree}~\type{E}}
\end{equation}
And the ordering relation \((\cdot~\relation{\sqsubseteq_{sTree}}~\cdot)\) of how "defined" the trees are by the constructors \todo{add all needed constructors}
\begin{equation}
  \infer{\constructor{\alpha}_{\typeformer{sTree}}~\term{x}~\term{y} : \typeformer{sTree}~\type{E}}{\term{x}~\relation{\sqsubseteq_{sTree}}~\term{y} & \term{y}~\relation{\sqsubseteq_{sTree}}~\term{x}}
\end{equation}
\begin{equation}
  \infer{\mathop{\constructor{\bigsqcup}}_{(\function{e} : \mathbb{N} \rightarrow \type{E})}~(\function{s}~\function{e})}{\function{s} : (\mathbb{N} \rightarrow \type{E}) \rightarrow \typeformer{sTree}~\type{E}}
\end{equation}

\subsubsection{From \(\typeformer{tree}\) to \(\typeformer{Seq}_{tree}\)}
We now want to show the equivalence between these two constructions, to do this we define an intermediate construction \(\typeformer{Seq}_{tree}\), where we get an ordering on the "definedness" of trees.
\begin{defn}
  We define monotone increasing sequences of trees as \todo{ordering is container ordering not maybe?}, all breanches are monotone increasing \todo{specify branches increasing?}.
  \begin{equation}
    \typeformer{Seq}_{tree} = \prod_{(\function{e} : \mathbb{N} \rightarrow \type{E})} \sum_{(\function{s} : \mathbb{N} \rightarrow \type{R} + \unit)} \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\type{R}+\unit}}~\function{s}_{n+1}
  \end{equation}
  where \(\relation{\sqsubseteq_{\type{R}+\unit}}\) is similar to the relation defined at \eqref{eq:maybe-order} \todo{how does it differ? Constructors are equal type is different (trees instead of delay)}.
\end{defn}
\begin{defn}
  We define a function to shift a \(\typeformer{Seq}_{tree}\), it takes \(\function{f} : \type{E} \rightarrow \typeformer{Seq}_{tree}\) as an argument. We let \(\function{s'} = \function{f}~\function{e}_0~(\function{e} \circ \constructor{succ})\), then the definition is given as
  \begin{equation}
    \begin{aligned}
      &\function{shift\text{-}seq}~\function{f} = \\[-5mm]
      &\qquad \lambda\,\function{e}, \natcases{\mathtt{inr}~\unitelem}{\pi_1~\function{s'}} , \left(\lambda\,n, \begin{cases} \mathtt{inr}~(\mathtt{refl} , \constant{inl{\not\equiv}inr}) & n = 0 \land \pi_1~\function{s'}~0 = \mathtt{inl}~r \\ \mathtt{inl}~\mathtt{refl} & n = 0 \land \pi_1~\function{s'}~0 = \mathtt{inr}~\unitelem \\ \pi_2~\function{s'}~m & n = m + 1 \end{cases}\right)
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  We define a function to unshift a \(Seq_{tree}\)
  \begin{equation}
    \begin{aligned}
      &\function{unshift\text{-}seq}~\function{s}~\term{v} = \lambda\,\function{e},~(\pi_1~(\function{s}~(\natcases{\term{v}}{\function{e}})) \circ \constructor{succ}) , (\pi_2~(\function{s}~(\natcases{v}{\function{e}})) \circ \constructor{succ})
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  Shift and unshift er inverse to each other
  \begin{proof}
    The same reasoning as for \todo{shift - unshift}
  \end{proof}
\end{lem}
\begin{defn}
  We get a function from trees to monotone sequences
  \begin{equation}
    \begin{aligned}
      &\function{tree{\rightarrow}Seq}~(\constructor{leaf}~\term{r}) = \lambda\,\_, (\lambda\,\_, \mathtt{inl}~\term{r}) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl}) \\
      &\function{tree{\rightarrow}Seq}~(\constructor{node}~\function{k}) = \function{shift}~(\function{tree{\rightarrow}Seq} \circ \function{k})
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  We get a function from monotone sequences to trees
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}tree}~\function{s} = \begin{cases} \constructor{leaf}~\term{r} & \prod_{(\function{e} : \mathbb{N} \rightarrow \type{E})} \pi_1~(\function{s}~\function{e})~0 = \mathtt{inl}~\term{r} \\ \constructor{node}~(\function{Seq{\rightarrow}tree} \circ \function{unshift}~\function{s}) & o.w.  \end{cases}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  \label{lem:seq-first-is-leaf}
  If the first element in the sequence is terminated / a leaf, then the rest of the elements will also be terminated.
  \begin{equation}
    \left(\prod_{e : \mathbb{N} \rightarrow \type{E}} \pi_1~(\function{s}~\function{e})~0 = \mathtt{inl}~\term{r}\right) \Leftrightarrow \left(\function{s} \equiv \lambda\,\_,(\lambda\,\_,\mathtt{inl}~\term{r}),(\lambda\,\_,\mathtt{inl}~\mathtt{refl})\right)
  \end{equation}
  \begin{proof}
    Since the sequence is monotone, and \(\mathtt{inl}~\term{r}\) is the top element of the order, if the first element is \(\mathtt{inl}~\term{r}\), then the sequence must be \(\lambda\,\_,(\lambda\,\_,\mathtt{inl}~\term{r}),(\lambda\,\_,\mathtt{inl}~\mathtt{refl})\). The other direction is trivial.
  \end{proof}
\end{lem}
\begin{thm}
  The types \(\typeformer{tree}\) and \(\typeformer{Seq}_{tree}\) are equal
  \begin{proof}
    We construct an isomorphism by the functions \(\function{tree{\rightarrow}Seq}\) and \(\function{Seq{\rightarrow}tree}\), with right inverse given by two cases, one where the first element in the sequence is \(\mathtt{inl}~\term{r}\), meaning representing a leaf with value \(r\), then we need to show that \(\function{s} \equiv \lambda\,\_,(\lambda\,\_,\mathtt{inl}~\term{r}),(\lambda\,\_,\mathtt{inl}~\mathtt{refl})\) which follows from \lemref{seq-first-is-leaf}. Otherwise we need to show that
    \begin{equation}
      \function{shift}~(\function{tree{\rightarrow}Seq} \circ \function{Seq{\rightarrow}tree} \circ \function{unshift}~\function{s}) \equiv \function{s}
    \end{equation}
    By induction we get
    \begin{equation}
      \function{tree{\rightarrow}Seq} \circ \function{Seq{\rightarrow}tree} \circ \function{unshift}~\function{s} \equiv \function{unshift}~\function{s}
    \end{equation}
    then by the right inverse of the equality between shift and unshift, we are done. For the left inverse we do case analysis, using induction and the left inverse of the equality between shift and unshift
    \begin{equation}
      \begin{aligned}
        &\function{tree\text{-}Seq}~(\constructor{leaf}~\term{r}) = \mathtt{refl} \\
        &\function{tree\text{-}Seq}~(\constructor{node}~\term{k}) = \function{unshift\text{-}shift}~(\function{tree{\rightarrow}Seq} \circ \function{k}) \ct \function{tree\text{-}Seq}~k
      \end{aligned}
    \end{equation}
  \end{proof}
\end{thm}
\noindent We start by defining some ordering relation on \(\typeformer{Seq}_{tree}\)
\begin{defn}[Sequence Termination]
  The following relations says that a branche \(\function{e} : \mathbb{N} \rightarrow \type{E}\) of a sequence \(\function{s} : \typeformer{Seq}_{tree}\) terminates with some value \(\term{r} : \type{R}\),
  \begin{equation}
    (\function{s}~\function{e})~\relation{\downarrow_{\typeformer{Seq}_{tree}}}~\term{r} = \sum_{(n : \mathbb{N})} (\function{s}~\function{e}~n) \downarrow_{\type{R} + \unit} \term{r}.
  \end{equation}
\end{defn}
\begin{defn}[Sequence Ordering]
  \begin{equation}
    \function{s}~\relation{\sqsubseteq_{\typeformer{Seq}_{tree}}}~\function{t} = \prod_{(e : \type{E})} \prod_{(\term{a} : \type{R})} \left(\|(\function{s}~\function{e})~\relation{\downarrow_{\mathtt{Seq}}}~\term{a}\| \rightarrow \| (\function{t}~\function{e})~\relation{\downarrow_{\mathtt{Seq}}}~\term{a}\|\right)
  \end{equation}
  where \(\| \cdot \|\) is propositional \todo{propositional or set truncation?} truncation.
\end{defn}
\begin{defn}
  We define weak bisimularity relation for sequences \todo{Is this defined for partiality monad?}
  \begin{equation}
    \function{s}~\relation{\sim_{\typeformer{Seq}_{tree}}}~\function{t} = \function{s}~\relation{\sqsubseteq_{\typeformer{Seq}_{tree}}}~\function{t} \times \function{t}~\relation{\sqsubseteq_{\typeformer{Seq}_{tree}}}~\function{s}
  \end{equation}
\end{defn}
\begin{cor}
  The types \(\typeformer{tree}/\relation{\sim_{tree}}\) and \(\typeformer{Seq}_{tree} / \relation{\sim_{\typeformer{Seq}_{tree}}}\) are equal.
  \begin{proof}
    We follow the same strategy as for \(\typeformer{Delay}/{\sim}\) and \(\typeformer{Seq}/{\sim}\)
  \end{proof}
\end{cor}

\subsubsection{\(\typeformer{Seq}_{tree}\) to \(\typeformer{sTree}\)}
\todo{Introduction to Seq to tree}
\begin{defn}
  We define a function converting a sequence on trees to a monotone sequence on \typeformer{sTree}'s
  \begin{equation}
    \function{Seq{\rightarrow}incSeq}
  \end{equation}
\end{defn}
\begin{defn}
  There is a function from \(\typeformer{Seq}_{tree}\) to \(\typeformer{sTree}\)
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}sTree}~\function{s} = \mathop{\constructor{\bigsqcup}}_{(\function{e} : \mathbb{N} \rightarrow \type{E})}~(\function{Seq{\rightarrow}incSeq}~\function{s}~\function{e})
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  Given \(a~\relation{\sqsubseteq_{\typeformer{Seq}_{tree}}}~b\), then \(\function{Seq{\rightarrow}sTree}~a~\relation{\sqsubseteq_{sTree}}~\function{Seq{\rightarrow}sTree}~b\).
  \begin{proof}
    \todo{Complete proof}.
  \end{proof}
\end{lem}
\noindent Since this definition is monotone, it can be lifted to the quotiented sequences.
\begin{lem}
  If two elements are weakly bisimilar, then they are equal as \function{sTrees} \todo{describe better}
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}sTree\text{-}{\approx}{\rightarrow}{\equiv}}~\term{x}~\term{y}~(\function{p},\function{q}) = \\
      &\qquad\constructor{\alpha_{sTree}}~(\function{Seq{\rightarrow}sTree\text{-}mono}~\term{x}~\term{y}~\function{p})~(\function{Seq{\rightarrow}sTree\text{-}mono}~\term{y}~\term{x}~\function{q})
    \end{aligned}
  \end{equation}
\end{lem}
\noindent We then get the definition
\begin{defn}
  TODO! \todo{TODO}
\end{defn}
~\\ \\
\begin{equation}
  \begin{aligned}
    &\function{Seq{\rightarrow}sTree}~\function{s} = \mathop{\constructor{\bigsqcup}}_{(\function{e} : \mathbb{N} \rightarrow \type{E})}~(\function{s}~\function{e})
  \end{aligned}
\end{equation}
\noindent We then show this definition is monotone, such that it can be lifted to a function from the quotient
\begin{lem}
  The function \(\function{tree{\rightarrow}sTree}\) is monotone, meaning if \(\term{x}~\relation{\sqsubseteq_{tree}}~\term{y}\), then we have \(\function{tree{\rightarrow}sTree}~\term{x}~\relation{\sqsubseteq_{sTree}}~\function{tree{\rightarrow}sTree}~\term{y}\).
  \begin{proof}
    By case
    \begin{equation}
      \function{tree{\rightarrow}sTree\text{-}mono}~(\constructor{leaf})~\_ = 
    \end{equation}
  \end{proof}
\end{lem}
\noindent We then want to lift this definition to the quotient using the recursor for quotients \eqref{eq:quotient-recursor},
\begin{defn}
  There is a function from \(\typeformer{tree}~\type{A}~\type{E} / \relation{\sim_{tree}}\) to \(\typeformer{sTree}~\type{E}\)
  \begin{equation}
    \function{tree/{\sim}{\rightarrow}sTree} = \function{rec}~\function{tree{\rightarrow}sTree}~\function{tree→sTree-{\approx}{\rightarrow}{\equiv}}~\constructor{sTree\text{-}isSet}
  \end{equation}
\end{defn}

\subsection{QM-types}
We want to define sequences based on \texttt{M}-types
\begin{equation}
  \typeformer{Seq}_{\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}} = \prod_{(a : \mathbb{N} \rightarrow \typeformer{B}~?)} \sum_{a : \mathbb{N} \rightarrow \type{A}} \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{?}}~\function{s}_{n+1}
\end{equation}
\\ \\
\todo{which other QM types can be expressed as QIITs}
% Sierpinski set
% Rosolini’s dominance
% non-termination monad -- Partiality monad - completely iterative monad (on 1 -> 1)
A QM-type is a quotiented M-type, we try to define this as a quotient on containers. We define container quotients as
\begin{equation}
  ...
\end{equation}
\\ \\
We want to define QM-types as the final coalgebra satisfying a set of equations. The construction takes inspiration from \cite{Infinitary-QIITs}
\subsubsection{Cofree Coalgebra}
We want to define a cofree coalgebra over a container \(\containerpair{A}{\lambda\,\_, \empt}\).
\\ \\
This is defined as the left adjoint to the forgetful functor \(\function{U} : \coalg{\type{C}}{\term{\gamma}} \rightarrow \type{C}\) as \(\function{F} : \type{C} \rightarrow \coalg{\type{C}}{\term{\gamma}}\).

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \functor{P} \type{A} \ar[d] \ar[d,"\epsilon"] \\
    \type{A} & \type{M} \ar[l,"\alpha"] \ar[ul,"\alpha^\sharp"']
  \end{tikzcd}
  \caption{Cofree Coalgebra}
  \label{fig:cofree-coalgebra}
\end{figure}

A coalgebra PA is cofree on A iff for all coalgebras M and mappings \(\alpha : UM \rightarrow C\) there is a unique morphism \(\alpha^\sharp : M \rightarrow TC\) such that the diagram \figref{cofree-coalgebra} commutes

\subsubsection{Equation system}
We start by defining a equation system called a covariety \cite{Hughes} of a coalgebra (dual of variety of an algebra).
\\ \\
Complete covarities are closed under bisimulation.

\section{Strongly Extensional (Coalgebra)}

% https://en.wikipedia.org/wiki/Variety_(universal_algebra)
% Hughes
% Alexander Kurz

\begin{defn}
  A equation system is given by
  \begin{equation}
    EqSys : \sum_{(E : \universe{\mathcal{U}})} \sum_{(V : \type{E} \rightarrow \universe{\mathcal{U}})} ((e : E) \rightarrow T (V e)) \times ((e : E) \rightarrow T (V e))
  \end{equation}
  where \(\type{E}\) representing the equations, and variables for the given equations, given by the type \(\typeformer{V}\), and \(T\) is the free coalgebra.
\end{defn}

\subsection{in progress}
Let \(\functor{G}\) be functors and \(v : \functor{P} \rightarrow \functor{G}\) a natural transformation. Suppose that for any type \(\type{V}\), the functor \((\lambda\,\_ \rightarrow \type{V}) \times\functor{F}\) has a final coalgebra. Then there exists for any G-coalgebra \(\coalg{\type{C}}{\function{\gamma}}\) an \(P\)-coalgebra \(\coalg{S_C}{\alpha}\) and a \(\functor{G}\)-homomorphism \(\varepsilon:\coalg{S_C}{v_{S_C} \circ \alpha} \Rightarrow \coalg{C}{\gamma}\), satisfying the universal property: for any \(P\)-coalg \(\coalg{U}{\alpha_U}\) and any G-homomorphism \(f : \coalg{U}{v_U \circ \alpha_U} \Rightarrow \coalg{C}{\gamma}\) there exists a unique \(P\)-homomorphism \(\tilde{f} : \coalg{U}{\alpha_u} \Rightarrow \coalg{S_C}{\alpha}\) such that \(\varepsilon \circ \tilde{f} = f\). The \(P\)-coalg \(\coalg{S_c}{\alpha}\) (and \(\varepsilon\)) is called cofree on the G-coalgebra \(\coalg{C}{\gamma}\). \cite[theorem 17.1]{UniversalCoalgebra}.
\\ \\
The coalgebra generated by the polynomial functor over the container \(\containerpair{A}{B}\) is a cofree coalgebra. We can now define a quotient, by defining a equation system at the same time, as we define the \texttt{M}-type type. The equation systems is defined on a type \(E : \mathcal{U}\) with variables of type \(V : E \rightarrow \mathcal{U}\), each equation is given by functions \(l,r : C \rightarrow A\) for some type \(C\). A coalgebra satisfies the equation system iff \((t : B (l c) \rightarrow MQ) \rightarrow (s : B (r c) \rightarrow MQ) \rightarrow l c \equiv r c\) is inhabited.

\section{TODO}
\begin{itemize}
\item Resumption Monad transformer
\item coinduction in Coq is broken
\item bisim \(\Rightarrow\) eq
\item copattern matching
\item cubical Agda. Relation between \texttt{M}-types defined by coinduction/copattern matching and constructed from W-types
\item   In Agda, co-inductive types are defined using Record types, which are Sigma-types. 
\item   In cubical Agda, 3.2.2 the issue of productivity is discussed. This can probably be made precise using guarded types.
\item streams defined by guarded recursion vs coinduction in guarded cubical Agda. 
\item    p3 of the guarded cubical Agda paper describes how semantic productivity improves over syntactic productivity
\item Reduction of co-inductive types in Coq/Agda to (indexed) \texttt{M}-types. Like reduction of strictly positive inductive types to W-types. https://ncatlab.org/nlab/show/W-type
\item QIITs have been formalized in Agda using private types. Can this also be done in cubical Agda (ie without cheating).
\item   Show that this is the final (quotiented) coalgebra. Does this generalize to Q\texttt{M}-types, and what are those constructively ??
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Properties of M-types?}
\section{Closure properties of \texttt{M}-types}
We want to show that \texttt{M}-types are closed under simple operations, we start by looking at the product.
\subsection{Product of \texttt{M}-types}
We start with containers and work up to \texttt{M}-types.
\begin{defn}
  The product of two containers is defined as \cite{ContainerRules}
  \begin{equation}
    \containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}} \equiv \containerpair{\type{A} \times \type{C}}{\lambda\,(\term{a} , \term{c}), \typeformer{B}~\term{a} \times \typeformer{D}~\term{c}}.
  \end{equation}
\end{defn}
\noindent We can lift this rule, through the diagram in \figref{container-products}, used to define \texttt{M}-types.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{A} & \type{A} \times \type{C} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \type{C} \\
    \functor{P} (\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}) \ar[u,"\pi_1"'] & \functor{P}(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}) \ar[l] \ar[r] \ar[u,"\pi_1"'] & \functor{P} (\typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}}) \ar[u,"\pi_1"'] \\
    \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}} \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] & \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}} \ar[l] \ar[r] \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] & \typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}} \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] \\
    {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^n~\unit \ar[d,"\function{\pi}_{(n)}"] & {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \ar[l] \ar[r] \ar[d,"\function{\pi}_{(n)}"] & {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \ar[d,"\function{\pi}_{(n)}"] \\
    \vdots \ar[d,"\function{\pi}_{(1)}"] & \vdots \ar[d,"\function{\pi}_{(1)}"] & \vdots \ar[d,"\function{\pi}_{(1)}"] \\
    \functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}~\unit \ar[d,"\function{\pi}_{(0)}"] & \functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}~\unit \ar[l] \ar[r] \ar[d,"\function{\pi}_{(0)}"] & \functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}~\unit \ar[d,"\function{\pi}_{(0)}"] \\
    \unit & \unit \ar[l,"\texttt{refl}"] \ar[r,"\texttt{refl}"'] & \unit
  \end{tikzcd}
  \caption{Diagram for products of chains}
  \label{fig:container-products}
\end{figure}
\begin{thm}
  For any \(n : \mathbb{N}\) the following is true
  \begin{equation}
    {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^n~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^n~\unit. \label{eq:polynomial-functor-product}
  \end{equation}
  
  \begin{proof}
    We do induction on \(n\), for \(n = 0\), we have \(\unit \times \unit \equiv \unit\). For \(n = m + 1\), we may assume
    \begin{equation}
      {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit,
    \end{equation}
    in the following
    \begin{align}
      &~ {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^{m+1}~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^{m+1}~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\typeformer{B}}} ({\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit) \times \functor{P}_{\containerpair{\type{C}}{\typeformer{D}}} ({\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} : \type{A}} \typeformer{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times \sum_{\term{c} : \type{C}} \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} (\typeformer{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit) \times (\typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \typeformer{B}~\term{a} \times \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \typeformer{B}~\term{a} \times \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}} ({\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^{m+1}~\unit
    \end{align}
    taking the limit of \eqref{eq:polynomial-functor-product} we get
  \begin{equation}
    \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}} \times \typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}.
  \end{equation}
  \end{proof}
\end{thm}
\begin{exmp} For streams we get
\begin{equation}
  \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit}} \times \typeformer{M}_{\containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit} \times \containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{stream}~(\type{A} \times \type{B}) \label{eq:zip-equality}
\end{equation}
as expected. Transporting along \eqref{eq:zip-equality} gives us a definition for \function{zip}.
\end{exmp}

\subsection{Co-product}
\todo[inline]{Coproducts?}

\subsection{...}
\todo[inline]{The rest of the closures defined in "Categories of Containers" \cite{ContainerRules}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Examples of \texttt{M}-types}

\section{The Partiality monad}
To construct the partiality monad, we start with the delay monad, and the preorder
\begin{equation}
\forall x, \bot \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x, x \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x\,y\,z, x \sqsubseteq y \rightarrow y \sqsubseteq z \rightarrow x \sqsubseteq z
\end{equation}
we can then define the partiality monad

The partiality monad \((-)_\bot\) is a way of adding partiality to a given computation. Along with the partiality monad, we also get a partial ordering \((\cdot \sqsubseteq \cdot)\), by
\begin{equation}
\forall x, \bot \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x, x \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x\,y\,z, x \sqsubseteq y \rightarrow y \sqsubseteq z \rightarrow x \sqsubseteq z
\end{equation}
\begin{equation}
\forall\,x\,y, x \sqsubseteq y \rightarrow y \sqsubseteq x \rightarrow x \equiv y
\end{equation}
We now want to show that we can construct the partiality monad from the delay monad. We need an operation that given an element of the delay monad, maps to an element of the partiality monad.
\begin{equation}
  \function{now}~x = x + \unit
\end{equation}
\begin{equation}
  \function{later}~y = y
\end{equation}

\section{TODO: Place these subsections}
\todo[inline]{What makes a relation a bisimulation? Is bisim and equality equal.}
\subsection{Identity Bisimulation}
Lets start with a simple example of a bisimulation namely the one given by the identity relation for any \texttt{M}-type.
\begin{lem}
  The identity relation \((\cdot \equiv \cdot)\) is a bisimulation for any final coalgebra \(\coalg{\typeformer{M}_{\container{S}}}{\function{out}}\) defined over an \texttt{M}-type.
  
  \begin{proof}
  We first define the function
  \begin{equation}
    \begin{aligned}
      \function{\alpha}_{\equiv} &: \type{\overline{\equiv}} \rightarrow \functor{P}(\type{\overline{\equiv}}) \\
      \function{\alpha}_{\equiv} (x , y) &:= \pi_1~(\function{out}~x)~,~(\lambda\,b, (\pi_2~(\function{out}~x)~b \,,\, \texttt{refl}_{(\pi_2\,(\function{out}\,x)\,b)}))
    \end{aligned}
  \end{equation}
  and the two projections
  \begin{align}
    \pi_1^{\type{\overline{\equiv}}} &= (\pi_1 , \texttt{funExt}~\lambda\,(a,b,r), \texttt{refl}_{\function{out}\,a}) \\
    \pi_2^{\type{\overline{\equiv}}} &= (\pi_2 , \texttt{funExt}~\lambda\,(a,b,r), \texttt{cong}_{\function{out}}~(\sym{r})).
  \end{align}
  This defines the bisimulation, given by the diagram in \figref{id-bisim}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\equiv}}}{\function{\alpha}_{\equiv}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\equiv}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\equiv}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Identity bisimulation}
    \label{fig:id-bisim}
  \end{figure}
\end{proof}
\end{lem}
\subsection{Bisimulation of Streams}
\todo[inline]{TODO}
\subsection{Bisimulation of Delay Monad}
We want to define a strong bisimulation relation \(\relation{\sim_{delay}}\) for the delay monad, 
\begin{defn}
  The relation \(\relation{\sim_{delay}}\) is defined by the following rules
  \begin{equation}
    \infer[\mathtt{now}{\sim}]{\function{now}~\term{r}~\relation{\sim_{delay}}~\function{now}~\term{r} : \universe{\mathcal{U}}}{\type{R} : \universe{U} & \term{r} : \type{R}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{later}{\sim}]{\function{later}~\term{t}~\relation{\sim_{delay}}~\function{later}~\term{u} : \universe{\mathcal{U}}}{\type{R} : \universe{\mathcal{U}} & \term{t} : \typeformer{delay}~\type{R} & \term{u} : \typeformer{delay}~\type{R} & \term{t}~\relation{\sim_{delay}}~\term{u} : \universe{\mathcal{U}}}
  \end{equation}
\end{defn}
\begin{thm}
  The relation \(\relation{\sim_{delay}}\) is a bisimulation for \(\typeformer{delay}~\type{R}\).
  \begin{proof}
    First we define the function
    \begin{equation}
      \begin{aligned}
        \function{\alpha}_{\relation{\sim_{delay}}} &: \type{\overline{\sim_{delay}}} \rightarrow \functor{P} (\type{\overline{\sim_{delay}}}) \\
        \function{\alpha}_{\relation{\sim_{delay}}}~(\term{a} , \term{b} , \mathtt{now}{\sim}~\term{r}) &:= (\mathtt{inr}~\term{r} , \lambda\,(\,)) \\
        \function{\alpha}_{\relation{\sim_{delay}}}~(\term{a} , \term{b} , \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}) &:= (\mathtt{inl}~\unitelem , \lambda\,\_, (\term{x} , \term{y} , \term{q}))
      \end{aligned}
    \end{equation}
    then we define the projections
      \begin{align}
        \pi_1^{\type{\overline{\sim_{delay}}}} &= \left( \pi_1 ~~ , ~~ \texttt{funExt}~\lambda\,(\term{a},\term{b},p), \begin{cases} (\mathtt{inr}~\term{r} , \lambda\,(\,)) & p = \mathtt{now}{\sim}~\term{r} \\ (\mathtt{inl}~\unitelem , \lambda\,\_, x) & p = \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}\end{cases} \right) \\
        \pi_2^{\type{\overline{\sim_{delay}}}} &= \left( \pi_2 ~~ , ~~ \texttt{funExt}~\lambda\,(\term{a},\term{b},p), \begin{cases} (\mathtt{inr}~\term{r} , \lambda\,(\,)) & p = \mathtt{now}{\sim}~\term{r} \\ (\mathtt{inl}~\unitelem , \lambda\,\_, y) & p = \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}\end{cases} \right) \\
      \end{align}
      This defines the bisimulation, given by the diagram in \figref{delay-strong-bisim}.
      \begin{figure}[h]
        \centering
        \begin{tikzcd}[column sep = large]
          \coalg{\typeformer{delay}~\type{R}}{\function{out}} & \coalg{\type{\overline{\sim_{\texttt{delay}}}}}{\function{\alpha}_{\relation{\sim_{delay}}}} \ar[l,Rightarrow,"\pi_1^{\type{\overline{\sim_{delay}}}}"'] \ar[r,Rightarrow,"\pi_2^{\type{\overline{\sim_{delay}}}}"] & \coalg{\typeformer{delay}~\type{R}}{\function{out}}
        \end{tikzcd}
        \caption{Strong bisimulation for delay monad}
        \label{fig:delay-strong-bisim}
      \end{figure}
  \end{proof}
\end{thm}

\subsection{Bisimulation of ITrees}
We define our bisimulation coalgebra from the strong bisimulation relation \(\mathcal{R}\), defined by the following rules.
\begin{equation}
  \infer[\mathtt{EqRet}]{\mathtt{Ret}~\term{a} \cong \mathtt{Ret}~\term{b}}{\term{a},\term{b} : \type{R} & \term{a} \equiv_{\type{R}} \term{b}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqTau}]{\mathtt{Tau}~\term{t} \cong \mathtt{Tau}~\term{u}}{\term{t},\term{u} : \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqVis}]{\mathtt{Vis}~\term{e}~\term{k_1} \cong \mathtt{Tau}~\term{e}~\term{k_2}}{\type{A} : \universe{\mathcal{U}} & \term{e} : \typeformer{E}~\type{A} & \term{k_1},\term{k_2} : \type{A} \rightarrow \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
Now we just need to define \(\term{\alpha}_{\relation{\mathcal{R}}}\) \todo[inline]{define the \(\alpha_{\relation{R}}\) function}. Now we have a bisimulation relation, which is equivalent to equality, using what we showed in the previous section.

\subsection{Zip Function}
We want the diagram in \figref{zip-computation-rules} to commute,
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    & A \times B & \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[ur,"\destructor{hd} \times \destructor{hd}"'] \ar[rr,"\function{zip}"] \ar[d,"\destructor{tl} \times \destructor{tl}"] & & \typeformer{stream}~(\type{A} \times \type{B}) \ar[ul,"\destructor{hd}"] \ar[d,"\destructor{tl}"] \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[rr,"\function{zip}"] & & \typeformer{stream}~(\type{A} \times \type{B})
  \end{tikzcd}
  \caption{TODO}
  \label{fig:zip-computation-rules}
\end{figure}
meaning we get the computation rules
\begin{equation}
  (\destructor{hd} \times \destructor{hd}) \equiv \destructor{hd} \circ \function{zip}
\end{equation}
\begin{equation}
  \function{zip} \circ (\destructor{tl} \times \destructor{tl}) \equiv \destructor{tl} \circ \function{zip}
\end{equation}
we can define the zip function as we did in the end of the last section. Another way to define the zip function is more directly, using the following lifting property of \texttt{M}-types
\begin{equation}
  \begin{aligned}
    &\function{lift_M}~\left(x : \prod_{n : \mathbb{N}} (\type{A} \rightarrow {\functor{P}_{\container{S}}}^n~\unit)\right)~\left(u : \prod_{n : \mathbb{N}} (\type{A} \rightarrow \pi_n (x_{n+1} a) \equiv x_n a)\right) (a : \type{A}) : \function{M}~\container{S} := \\
    &\qquad\qquad (\lambda\,n, x~n~a) , (\lambda\,n~i, p~n~a~i).
  \end{aligned} \label{eq:M-lift}
\end{equation}
To use this definition, we first define some helper functions
\begin{equation}
  \function{zip}_{X}~n~(x , y) = \begin{cases} \unit & \mathtt{if}~n = 0 \\ (\destructor{hd}~x , \destructor{hd}~y) , (\lambda\,\_, \function{zip}_{X}~m~(\destructor{tl}~x,\destructor{tl}~y)) , & \mathtt{if}~n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{zip}_{\pi}~n~(x , y) = \begin{cases} \function{refl} & \mathtt{if}~n = 0 \\ \lambda\,i,(\destructor{hd}~x , \destructor{hd}~y) , (\lambda\,\_, \function{zip}_{\pi}~m~(\destructor{tl}~x,\destructor{tl}~y)~i) , & \mathtt{if}~n = m + 1 \end{cases},
\end{equation}
we can then define
\begin{equation}
  \function{zip}_{lift}~(x , y) := \function{lift_M}~\function{zip}_X~\function{zip}~(x,y).
\end{equation}
\subsubsection{Equality of Zip Definitions}
We would expect that the two definitions for zip are equal
\begin{align}
  \texttt{transport}_{?}~a &\equiv \function{zip}_{lift}~a \\
                           &\equiv \function{lift_M}~\function{zip}_X~\function{zip}_\pi~(x,y) \\
                           &\equiv (\lambda\,n, \function{zip}_X~n~(x,y)) , (\lambda\,n~i, \function{zip}_\pi~n~(x,y)~i)
\end{align}
zero case \(X\)
\begin{equation}
  \function{zip}_X~0~(x,y) \equiv \unit
\end{equation}
Successor case \(X\)
\begin{align} 
  \function{zip}_X~(m+1)~(x,y) &\equiv (\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\destructor{tl}~x,\destructor{tl}~y)) \\
                               &\equiv (\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_, {?}~(\destructor{tl}~a)) \\
                               &\equiv (\destructor{hd}~(\texttt{transport}_{?} a)),(\lambda\,\_, \texttt{transport}_{?} (\destructor{tl}~a)) \\
                               &\equiv \mathtt{transport}_?~a \\
\end{align}
Zero case \(\pi\): \((\lambda\,i, \function{zip}_\pi~0~(x,y)~i \equiv refl)\).
\begin{align}
  &\equiv () , (\lambda\,i, \function{zip}_\pi~0~(x,y)~i) \\
  &\equiv \unit , \function{refl} \\
\end{align}
successor case
\begin{align}
  &\equiv (\function{zip}_X~(m+1)~(x,y)) , (\lambda\,i, \function{zip}_\pi~(m+1)~(x,y)~i) \\
  &\equiv ((\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\destructor{tl}~x,\destructor{tl}~y))) , (\lambda\,i, (\destructor{hd}~x, \destructor{hd}~y),(\lambda\,\_,\function{zip}_\pi~m~(\destructor{tl}~x,\destructor{tl}~y)~i))
\end{align}
\todo[inline]{Complete this proof}

\subsection{Examples of Fixed Points}
\subsubsection{Zeros}
Let us try to define the zero stream, we do this by lifting the functions
\begin{equation}
  \function{const_X}~(n : \mathbb{N})~(c : \mathbb{N})  := \begin{cases} \unit & n = 0 \\ (c , \lambda\,\_, \function{const_X}~m~c) & n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{const_\pi}~(n : \mathbb{N})~(c : \mathbb{N}) := \begin{cases} \mathtt{refl} & n = 0 \\ \lambda\,i,(c , \lambda\,\_, \function{const_\pi}~m~c~i) & n = m + 1 \end{cases}
\end{equation}
to get the definition of zero stream
\begin{equation}
  \mathtt{zeros} := \function{lift_M}~\function{const_X}~\function{const_\pi}~0.
\end{equation}
We want to show that we get the expected properties, such as
\begin{align}
  \destructor{hd}~\mathtt{zeros} &\equiv 0 \\
  \destructor{tl}~\mathtt{zeros} &\equiv \mathtt{zeros}
\end{align}

\subsubsection{Spin}
We want to define spin, as being the fixed point \(\mathtt{spin} = \mathtt{later}~\mathtt{spin}\), so that is again a final coalgebra, but of a \texttt{M}-type (which is a final coalgebra)

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \function{spin} \ar[d,"\function{later}"] \\
    \function{later}~\function{spin}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Since it is final, it also must be unique, meaning that there is just one program that spins forever, without returning a value, meaning every other program must return a value. If we just


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Conclusion}
\label{ch:conclusion}

\todo[inline]{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\appendix

\chapter{Additions to the Cubical Agda Library}
% Should be in the appendix ...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{The Technical Details}

\todo[inline]{\dots}

\end{document}

\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\usepackage{marvosym}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command

\usepackage{proof} % \infer command

\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction

% allow breaks in align and equation (a new page for example) 
\allowdisplaybreaks

\renewcommand{\thefootnote}{\fnsymbol{footnote}} %footnote style

\usepackage{amsthm}

% \DeclareUnicodeCharacter{2080}{_0}

% \usepackage[math-style=TeX,vargreek-shape=unicode]{unicode-math} % loads fontspec -- no-math
\usepackage{fontspec} 

\usepackage{newunicodechar}
\newunicodechar{λ}{\ensuremath{\lambda}}
\newunicodechar{←}{\ensuremath{\from}}
\newunicodechar{→}{\ensuremath{\to}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{ℓ}{\ensuremath{\ell}}
% \newunicodechar{₀}{~} %TODO?
\newunicodechar{Σ}{\ensuremath{\Sigma}}
\newunicodechar{≈}{\ensuremath{\approx}}
\newunicodechar{⟨}{\ensuremath{\langle}}
\newunicodechar{⟩}{\ensuremath{\rangle}}
\newunicodechar{≡}{\ensuremath{\equiv}}
\newunicodechar{π}{\ensuremath{\pi}}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{≅}{\ensuremath{\cong}}

\usepackage{listings} %lstlistings
\lstset{inputpath=src/}
% Cubical Agda listing config

\lstdefinelanguage{agda}{
  sensitive = true,
  keywords={},
  % otherkeywords={% Operators
  %   >, <, ==
  % },
  keywords = [2]{module, open, import, where},
  keywordstyle=\color{green},
  keywordstyle=[2]\color{blue},% for example
  keywords = [3]{postulate, private},
  keywordstyle=[3]\color{magenta},
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  comment=[l]{--},
  morecomment=[s]{\{-\#}{\#-\}},
  commentstyle=\color{gray}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  % morestring=[b]',
  % morestring=[b]"
}

\lstset{
  language=agda, 
  basicstyle=\ttfamily\small,
  numberstyle=\footnotesize,
  numbers=left,
  backgroundcolor=\color{gray!10},
  frame=single,
  tabsize=2,
  rulecolor=\color{black!30},
  title=\lstname,
  % escapeinside={\%*}{*)},
  breaklines=true,
  breakatwhitespace=true,
  framextopmargin=2pt,
  framexbottommargin=2pt,
  inputencoding=utf8,
  extendedchars=true,
  % literate={}{!}1,
}

\theoremstyle{plain} % default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}% [section] 
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example} % [section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% Custom commands

\newcommand*{\thmref}[1]{\hyperref[thm:#1]{Theorem~\ref*{thm:#1}}} % Theorem~\ref
\newcommand*{\lemref}[1]{\hyperref[lem:#1]{Lemma~\ref*{lem:#1}}}
\newcommand*{\corref}[1]{\hyperref[cor:#1]{Corollary~\ref*{cor:#1}}}
\newcommand*{\defref}[1]{\hyperref[defn:#1]{Definition~\ref*{defn:#1}}}
\newcommand*{\figref}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand*{\exmpref}[1]{\hyperref[exmp:#1]{Example~\ref*{exmp:#1}}}
\newcommand*{\sectionref}[1]{\hyperref[sec:#1]{Section~\ref*{sec:#1}}}
\newcommand*{\subsectionref}[1]{\hyperref[sec:#1]{Subsection~\ref*{sec:#1}}}
\newcommand*{\chapterref}[1]{\hyperref[ch:#1]{Chapter~\ref*{ch:#1}}}

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{green!30!black}{#1}} % \textcolor{green!70!black} \textcolor{blue!80!black}
\newcommand*{\pathterm}[1]{\textcolor{green!65!red!75!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
% \newcommand*{\dependenttype}[1]{\textcolor{magenta!70!black}{#1}}
\newcommand*{\container}[1]{\textcolor{orange}{#1}}
\newcommand*{\containerpair}[2]{\ensuremath{\colorlet{savedleftcolor}{.}\color{orange}\left(\color{savedleftcolor}#1\,\textcolor{orange}{\mathbf{,}}\,#2\color{orange}\right)\color{savedleftcolor}}}
\newcommand*{\containerpairsimple}[2]{\containerpair{#1}{\lambda\,\_,\,#2}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\relation}[1]{\textcolor{gray!75!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constant}[1]{\textcolor{orange!60!black}{\ensuremath{\mathtt{#1}}}}

\newcommand*{\function}[1]{\textcolor{blue!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constructor}[1]{\textcolor{purple!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\destructor}[1]{\textcolor{yellow!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\typeformer}[1]{\ensuremath{\mathtt{#1}}}
\newcommand*{\functor}[1]{\ensuremath{\mathbf{\mathtt{#1}}}}

\newcommand*{\unitelem}{\constant{\star}} % \constant{tt}
\newcommand*{\quotientconstructor}[1]{\constructor{[}\,#1\,\constructor{]}}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

\newcommand*{\natcases}[2]{\ensuremath{\mathbb{[\hspace{-.5mm}\rangle}~\ensuremath{#1}~,~\ensuremath{#2}~\mathbb{\langle\hspace{-.5mm}]}}}

% Concatenation of paths taken from HoTT book
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\newcommand*{\sym}[1]{\ensuremath{#1^{-1}}}

% \mathord

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
  {\Huge\sf (Q)\texttt{M}-types and Coinduction in HoTT / CTT}\\[2ex]
  {\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
  \noindent\rule{\linewidth}{1mm}\\[4ex]
  \noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
    \today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

We present a construction of \texttt{M}-types from containers in a cubical type theory (CTT), We show how the containers construct a coalgebra, for which we can define a coinduction principle, making strong bisimulation imply equality. We then show constructions of \texttt{M}-types, and how they can be quotiented to construct what we call Q\texttt{M}-types. The problem with Q\texttt{M}-types is that in general assuming that we can lift function types of equivalence classes is equivalent to the axiom of choice \cite{DBLP:tt-in-tt}, but this can be solved by defining the quotienting relation and the type at the same time as a quotient inductive-inductive type (QIIT), which assuming the axiom of (countable) choice, is equal to the Q\texttt{M}-type. We construct multisets and the partiality monad as some examples of quotiented \texttt{M}-types and show the equivalence between the two constructions. We then discuss the pros and cons of the two constructions, and relate them to an alternative construction, which defines quotient polynomial functors (QPF), and define the quotiented \texttt{M}-type as the final coalgebra for the QPF. However this construction requires the axiom of choice, so it is still not a suitable construction. We conclude with some examples of how to use \texttt{M}-types and some properties. All work is formalized in Cubical Agda, and the work on defining \texttt{M}-types has been accepted to the Cubical Agda github repository. \todo{complete}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

I denne afhandling vil vi give en konstruktion af \texttt{M}-typer ved brug af "containers". Formaliseringen af dette bliver udført i en "Cubical Type Theory". Given en "conatiner" kan vi konstruere en polynomisk funktor, og ved gentaget anvendelse af denne på enhedstypen, får vi en sekvens af typer, som vi kan tage grænsen af. Denne grænse giver os en endelig coalgebra, hvilket vi definere \texttt{M}-type som. Vi giver nogle eksempler på \texttt{M}-typer. Vi beskriver tre mulige definitioner for kvotient \texttt{M}-typer, kaldet en Q\texttt{M}-type, den første er at bruge set trunkeret kvotienter givet en relation, problemet ved denne defintion er at vi ikke kan løfte konstruktørerne for \texttt{M}-typerne til Q\texttt{M}-typen. Vores anden defination er kvotient inductive-inductive typer (QIITs), hvor relationen og typen defineres samtidig. Vi giver nogle eksempler på denne konstruktion, og viser eksempler på ækvivalence mellem de konstruktioner, dog kræver disse antagelsen af udvalgsaksiomet. Den tredje konstruktion er at lave en kvotient polynomisk functor, og tage grænsen af denne, for at få en Q\texttt{M}-type, men igen kræver det udvalgsaksiomet, siden vi skal løfte operationerne fra kvotienten. \todo{complete}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}
I would like to thank my supervisor Bas Spitters for some enlightening discussions and quick responses and for taking the time to do weekly meetings regarding this masters thesis. I would also like to thank my fellow students, who made this challenging but fun time less lonely despite the Corona pandemic.
\vspace{2ex}
\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{3} % 2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Introduction} % Everyone interested should be able to read this!
\label{ch:intro}

\section{Overview}
Inductive types in homotopy type theory (HoTT) / cubical type theory have been studied a lot, one body of work is \texttt{W}-types, which has been shown equal to inductive types. However there has not been much work done on the dual concept, namely coinductive types in HoTT defined as \texttt{M}-types. The goal of this thesis is to get an understanding of \texttt{M}-types and extend on the existing theory. We construct some examples of \texttt{M}-types, as an attempt to make the theory of \texttt{M}-types more accessible. A useful technique for defining a type with some properties, is quotienting a free objects, as such we will look at quotients of \texttt{M}-types in the setting of cubical type theory and the problems with axiom of choice that arise from this construction.
\\ \\
In the rest of this chapter we will introduce some of the background theory and notation used in this thesis. In \chapterref{M-types} we construct \texttt{M}-types from containers, and define a coinduction principle for the \texttt{M}-types. In \chapterref{M-types-examples} we give some example constructions of \texttt{M}-types. In \chapterref{QM-types} we introduce quotiented \texttt{M}-types (Q\texttt{M}-types), and show equalities between these and quotient inductive-inductive types (QIITs), we show the construction of multisets and the partiality monad as example, and discuss how quotients of \texttt{M}-types should be constructed. Finally in \chapterref{conclusion} we discuss future research and conclude on the work done.
We expect readers to have entry level knowledge of category theory, type theory and homotopy type theory.

\section{Background Theory}
We start by giving some background theory and summarize important concepts used in the rest of this thesis.
\\ \\
We will be using \textbf{type theory} \cite{nlab:type_theory} as the basis for mathematics. In type theory every term \(\term{x}\) is an element of some type \(\type{A}\), written \(\term{x} : \type{A}\). A paradigm in type theory is the idea propositions as types \cite{nlab:propositions_as_types}, where propositions are types, meaning proofs boils down to showing that there exists an element of some type representing a proposition. Specifically proofs of equality is a construction of an element of the equality type. The type theory we are working in is build on \textbf{Martin L\"of Type Theory (MLTT)} / Intuitionistic type Theory (ITT) \cite{nlab:martin-loef_dependent_type_theory}, which is designed on the principles of mathematical constructivism, where any existence proof must contain a witness. Meaning a proof of existence, can be converted into an algorithm that finds the element making the statement true. MLTT is built from the three finite types \(\empt\), \(\unit\) and \(\type{\mathbf{2}}\), and type constructors \(\Sigma\), \(\Pi\) and \(=\). The types \(\Sigma\) and \(\Pi\) can be read as exists and for all. There is only a single way to make terms of \(=\)-type, and that is \(\mathtt{refl} : \prod_{a : A} (a = a)\). MLTT also has universes \(\universe{\mathcal{U}}_0, \universe{\mathcal{U}}_1, \dots\), however we will leave the index implicit and write \(\universe{\mathcal{U}}\).  We will say that a type is given inductively (coinductively) from a set of constructors and/or destructors, meaning we either take the smallest (largest) type for which these rules are true. A constructor for a type \(\type{A}\) is a function, that takes some arguments, and returns an element \(\term{a} : \type{A}\), dually a destructor of \(\type{A}\) will take an element \(\term{a} : \type{A}\) and return something. Inductive types are defined by giving rules for some base cases and then some inductive cases, an example is the natural numbers, defined as\\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.15\linewidth}
    \begin{equation}
      \vcenter{\infer{0 : \mathbb{N}}{\strut}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.20\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{succ}~n : \mathbb{N}}{n : \mathbb{N}}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
with base case 0, and inductive case \(\constructor{succ}~n\), which says that \(n+1\) is a natural number if \(n\) is. If we take the type defined coinductively over the same set of constructors, we get an element where \(\constructor{succ}\) is applied infinitely, namely \(\infty = \constructor{succ}~\infty\), which is not an element of \(\mathbb{N}\). This type is also know as \(\mathtt{co}\mathtt{N}\). A way to look at inductive definitions is that the rules describe the structure of the type, while for a coinduction definition, the rules describe the observable behavior of the type.
\\ \\
We define an equivalence relation \(\relation{\sim_{\mathbb{N}}}\) on the natural numbers inductively, since the natural numbers are defined inductively. That is equivalence on the natural numbers follows the structure defined by the constructors \\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.20\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{0}}]{0 = 0}{\strut}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{succ}}]{\constructor{succ}~n~\relation{\sim_{\mathbb{N}}}~\constructor{succ}~m}{n~\relation{\sim_{\mathbb{N}}}~m}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
so two natural numbers are equal, if they both are zero, or if they are equal when we subtract one from each of them. Equivalence relations defined this way for inductive types implies equality, meaning if two elements are related then they are equal. Lets try and do a similar construcation for the coinductive type of streams. A stream is an infinite sequence of elements. Streams can be defined from the two destructors head (\(\destructor{hd}\)) and tail (\(\destructor{tl}\)), where head represents the first element, and tail represents the rest of the sequence.\\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.225\linewidth}
    \begin{equation}
      \vcenter{\infer{\destructor{hd}~\term{s} : \type{A}}{\term{s} : \typeformer{stream}~\type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.25\linewidth}
    \begin{equation}
      \vcenter{\infer{\destructor{tl}~\term{s}: \typeformer{stream}~\type{A}}{\term{s} : \typeformer{stream}~\type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
We can again define an equivalence relation \(\relation{\sim_{stream}}\), but this time coinductively, focusing on the observable behavior instead
\begin{equation}
  \label{eq:stream-bisimilarity}
  \vcenter{\infer{\term{s}~\relation{\sim_{stream}}~\term{t}}{\destructor{hd}~\term{s} = \destructor{hd}~\term{t} & \destructor{tl}~\term{s}~\relation{\sim_{stream}}~\destructor{tl}~\term{t}}}
\end{equation}
This equivalence relation does not give an equality in MLTT, we just get bisimilarity meaning elements "behave" the same, but they are not equivalent. We solve this problem by working in a type theory, where the univalence axiom holds, that is we use a \textbf{Univalent Foundations (UF)} for mathematics in this work. The \textbf{univalence axiom} says that equality is equivalent to equivalence
\begin{equation}
  (\type{A} = \type{B}) \simeq (\type{A} \simeq \type{B})
\end{equation}
meaning if two types are equivalent, then there is an equality between them. This makes (strong) bisimilarity imply equality, solving the problem for \(\relation{\sim_stream}\). The univalent foundations we will be using is \textbf{Homotopy type theory (HoTT)} \cite{hottbook}. HoTT is an intensional dependent type theory (built on MLTT) with the univalence axiom and higher inductive types . In HoTT the idenitity types form path spaces, so proofs of identity are not just \texttt{refl} as is the case in MLTT. Types are seen as "spaces", and we think of \(\term{a} : \type{A}\) as \(\term{a}\) being a point in the space \(\type{A}\), similarly functions are regarded as continuous maps from one space to another \cite{nlab:homotopy_type_theory}. As such we can construct higher inductive types, with point constructors as well as equality constructors. One of the problems with "plain" HoTT is that the univalence axiom is just postulated, meaning it is not constructive. To remedy this we will be working in a \textbf{cubical type theory (CTT)} \cite{DBLP:CTT}, where the univalence axiom is not an axiom, but a statement that can be proven, meaning we constructivity of univalence axiom and application thereof \cite{nlab:cubical_type_theory}.  The reason for the name cubical type theory, is because composition is defined by square, that is given three sides of a square we get the last one, see \figref{cubical-composition-square}.
\begin{figure}[h]
  \centering
  \begin{tikzcd}
    A \ar[r,"p \ct q \ct r",dashed] & B \\
    C \ar[u,"p^{-1}"] \ar[r,"q"'] & D \ar[u,"r"']
  \end{tikzcd}
  \caption{Composition square}
  \label{fig:cubical-composition-square}
\end{figure}
\\ 
If you are used to working in set theory, then working in HoTT will take some getting used to. Homotopy type theory is proof relevant, which means that there might be multiple proofs of one statement, and these proofs might not be interchangeable (equal). This can be explained by the use of H-level in HoTT, which describes how equality behaves. We start from H-level (-2) which are contractiable types, meaning inhabited types, where all element are equal to. Then there is (-1)-types which are mere propositions or hProp, where all elements of the type are equal, but types might not be inhabited. If the type is inhabited, then we say the proposition is true. The 0-types are the hSets, where all equalities between two elements \(x,y\) are equal. For 1-types (1-groupoids) we get equalities of equalities are equal, and so on for homotopy \(n\)-types. Any \(n\)-type is also a \(n+1\)-type, but with trivial equalities at the \(n+1\) level. If we don't want to do proof relevant mathematics we can do propositional truncation (denoted \(\|{\cdot}\|\)), converting types to \(-1\)-types, meaning we ignore the difference in proofs by just look at whether a type is inhabited or not. However doing this we loose some of the reasoning power of HoTT. One of the tools we get using the full power of HoTT is \textbf{Higher order inductive types (HITs)}, which defines a type by point constructors and equality constructors. An example is the propositional truncation we just described, defined as a constructor taking any element to it its truncated version, and then defining equality between all propositional truncated elements\\[-9mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}[b]{0.25\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{|}\,\term{x}\,\constructor{|} : \| \type{A} \|}{\term{x} : \type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.3\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{squash}~\term{x}~\term{y} : \term{x} \equiv \term{y}}{\term{x}, \term{y} : \|\type{A}\|}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
Another useful example is set truncated quotients. Given some free type, we can quotient it by a relation, to get a type with equalities that respect the relation. A set truncated quotient of a type \(\type{A}\) with a relation \(\relation{R}\) is given by the HIT  \\[-10mm]
\begin{center}
  \strut
  \hfill
  \begin{minipage}[b]{0.2\linewidth}
    \begin{equation}
      \vcenter{\infer{\quotientconstructor{\term{x}} : \type{A} / \relation{\mathcal{R}}}{\term{x} : \type{A}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.325\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{eq/}~\term{x}~\term{y}~\term{r} : \term{x} \equiv \term{y}}{\term{x}, \term{y} : \type{A} / \relation{\mathcal{R}} & \term{r} : \term{x}~\relation{\mathcal{R}}~\term{y}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.325\linewidth}
    \begin{equation}
      \vcenter{\infer{\constructor{squash/} :\texttt{isSet}~(\type{A} / \relation{R})}{\strut}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
When working with these two HITs, you might need to use the axiom of choice (AC), which is defined as follows in HoTT
\begin{equation}
  \prod_{(\term{x} : \type{X})} \big\| \typeformer{Y}~\term{x} \big\| \rightarrow \bigg\| \prod_{(\term{x} : \type{X})} \typeformer{Y}~\term{x} \bigg\|
\end{equation}
where \(\typeformer{Y}\) is a type family over set \(\type{X}\) \cite[Section 3.8]{hottbook}, or the weaker version axiom of countable choice (\(\text{AC}_{\omega}\))
\begin{equation}
  \prod_{(n : \mathbb{N})} \big\| \typeformer{Y}~n \big\| \rightarrow \bigg\| \prod_{(n : \mathbb{N})} \typeformer{Y}~n \bigg\|  
\end{equation}
Using the axiom of choice is problematic in a constructive type theory, since it does not have a constructive interpretation. To maintain the computational aspects of HoTT and CTT, we try to avoid the axiom of choice \cite[Introduction]{hottbook}.
\\ \\
We have formalized most of \chapterref{M-types}\footnote{Accepted to the cubical agda github, pull request: \url{https://github.com/agda/cubical/pull/245}}, the examples in \chapterref{M-types-examples} and some of \chapterref{QM-types} in the proof assistant / programming languge Cubical Agda. A \textbf{proof assistant} helps with verifying proofs, while making the process of making proofs interactive. \textbf{Cubical Agda}\footnote{Cubical Agda commit: e8d22a50079df1186b111c1f096eb29a1e3daa20, Agda Version: Agda-2.6.2} \cite{cubicalagda} is an implementation of a cubical type theory (inspired by CCHM \cite{DBLP:CCHM}) made by extending the proof assistant Agda. One of the main additions is the interval and path types. The \textbf{interval} \(\mathbb{I}\) can be thought of as elements in the interval \([0,1]\). When working with the interval, we can only access the left and right endpoint \(\constant{i0}\) and \(\constant{i1}\) or some unspecified point in the middle \(i\), keeping with the intuition of a continuous interval. Cubical agda also generalizes transporting, given a type line \(\typeformer{A} : \mathbb{I} \rightarrow \universe{\mathcal{U}}\), and the endpoint \(\typeformer{A}\,\constant{i0}\) you get a line from \(\typeformer{A}\,\constant{i0}\) to \(\typeformer{A}\,\constant{i1}\). Using these tools we can make the univalence axiom compute and it eases the formalization, since proofs become more computational.

\section{Notation}
The following is the notation / fonts used to denote specific definitions / concepts
\begin{table}[h]
  % \centering
  \begin{tabular}[h]{ll}
    \(\universe{\mathcal{U}}_i\) or \(\universe{\mathcal{U}}\) & Universe \\
    \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\) & Type \\
    \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\) & Type former \\
    \(\typeformer{T} : \Pi_{(a : \type{A})} \typeformer{B}~\term{a}\) & Dependent product type \\
    \(\typeformer{T} : \sum_{(a : \type{A})} \typeformer{B}~\term{a}\) & Dependent sum type \\
    \(\term{x} : \type{A}\) & Term of a type \\
    \(\constant{c} : \type{A}\) & Constant \\
    \(\function{f} : \type{A} \rightarrow \type{C}\) & Function \\
    \(\constructor{f}\) & Constructor \\
    \(\destructor{f}\) & Destructor \\
    \(\pathterm{p} : \type{A} \equiv \type{C}\) & Homogeneous path \\
    \(\pathterm{q} : \type{A} \equiv_{p} \type{C}\) & Heterogeneous path, denoted \(\equiv_{*}\) if \(p\) is clear from context \\
    \(\relation{R} : \type{A} \rightarrow \type{A} \rightarrow \universe{\mathcal{U}}\) & Relation, elements denoted \(\term{x}~\relation{R}~\term{y}\)\\
    \(\unit\) & Unit type \\
    \(\empt\) & Empty / Zero / Bottom type \\
    \(\functor{P}\) & Functor \\
    \(\pi_1\), \(\pi_2\) &  First and second projection for dependent type \(\sum_{(\term{a} : \type{A})} \typeformer{B}~\term{a}\)
  \end{tabular}
  \caption{Notation}
\end{table}
We do a lot of casing on the natural numbers, so we will also introduce some notation, to make this more readable
\begin{defn}
  Useful notation for casing on natural numbers.
  \begin{equation}
    \natcases{\term{x}}{\function{f}} = \lambda\,n, \begin{cases} \term{x} & n = 0 \\ \function{f}~m & n = m + 1 \end{cases}
  \end{equation}
\end{defn}
We may define an isomorphism to give an equality \(\type{A} \equiv \type{B}\) using an isomorphism, that is we define functions \(\function{fun} : \type{A} \rightarrow \type{B}\) and \(\function{inv} : \type{B} \rightarrow \type{A}\), and show there are right and left identities \(\function{rinv} : \function{fun} \circ \function{inv} \equiv \function{id}\).
\noindent We will introduce further notation as we go.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{\texttt{M}-types}
\label{ch:M-types}
In this chapter we will introduce containers (aka. signatures), and use them to construct \texttt{M}-types and operations \(\function{in}\) and \(\function{out}\) on the \texttt{M}-types (\thmref{M-shift}) and showing that \(\coalg{\typeformer{M}}{\function{out}}\) is a final coalgebra (\thmref{M-type-final}). We conclude the chapter by proving a coinduction principle for \texttt{M}-types (\thmref{M-coinduction-principle}) \cite{DBLP:non-wellfounded}.

\section{Containers / Signatures}
We start by introducing the notion of containers and polynomial functors for these containers.
\begin{defn}
  A Container (or signature) is a dependent pair \(\container{S} = \containerpair{\type{A}}{\typeformer{B}}\) for the types \(\type{A} : \universe{\mathcal{U}}\) representing shape and \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\) defining branching based on the shape.
\end{defn}
\begin{defn}
  A polynomial functor \(\functor{P}_{\container{S}}\) for a container \(\container{S} = \containerpair{\type{A}}{\typeformer{B}}\) is defined, for types as
  \begin{equation}
    \begin{aligned}
      &\functor{P}_{\container{S}} : \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
      &\functor{P}_{\container{S}}\,\type{X} = \sum_{\term{a} : \type{A}} \typeformer{B}(\term{a}) \rightarrow \type{X}
    \end{aligned}
  \end{equation}
  and for a function \(\function{f} : \type{X} \rightarrow \type{Y}\) as
  \begin{equation}
    \begin{aligned}
      &\functor{P}_{\container{S}}\,\function{f} : \functor{P}_{\container{S}}\type{X} \rightarrow \functor{P}_{\container{S}}\type{Y} \\
      &\functor{P}_{\container{S}}\,\function{f}~(\term{a},\function{g}) = (\term{a}, \function{f} \circ \function{g}).
    \end{aligned}
  \end{equation}
  If the container is clear from context we will just write \(\functor{P}\).
\end{defn}
\begin{exmp}
  \label{exmp:stream-polyfunctor-example}
  The polynomial functor for streams over the type \(\type{A}\) is defined by the container \(\container{S} = \containerpairsimple{\type{A}}{\unit}\), we get
  \begin{equation}
    \label{eq:stream-polyfunctor-pre}
    \functor{P}_{\container{S}}\,\type{X} = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X}.
  \end{equation}
  We can simplify this expression using \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\). Furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\), so \eqref{eq:stream-polyfunctor-pre} is equivalent to
  \begin{equation}
    \functor{P}_{\container{S}}\,\type{X} = \type{A} \times \type{X}.
  \end{equation}
\end{exmp}
\noindent We define the \(\functor{P}_{\container{S}}\)-coalgebra for a polynomial functor \(\functor{P}_{\container{S}}\), and the morphisms between coalgebras.
\begin{defn}
  A \(\functor{P}_{\container{S}}\)-coalgebra is defined as
  \begin{equation}
    \typeformer{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow \functor{P}_{\container{S}}\type{C}.
  \end{equation}
  where we denote a \(\functor{P}_{\container{S}}\)-coalgebra given by \(\type{C}\) and \(\function{\gamma}\) as \(\coalg{\type{C}}{\function{\gamma}}\). Coalgebra morphisms are defined as
  \begin{equation}
    \begin{aligned}
      \cdot \Rightarrow ~\cdot &: \typeformer{Coalg}_{\container{S}} \rightarrow \typeformer{Coalg}_{\container{S}} \\
      \coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{D}}{\function{\delta}} &= \sum_{\function{f} : \type{C} \rightarrow \type{D}} \function{\delta} \circ \function{f} = \functor{P} \function{f} \circ \function{\gamma}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}[Final Coalgebra / \texttt{M}-type]
  \label{defn:M-type-final-def}
  Given a container \(\container{S}\), we define \(\mathtt{M}\)-types as the type, making the coalgebra given by \(\typeformer{M}_{\container{S}}\) and \(\function{out} : \typeformer{M}_{\container{S}} \rightarrow \functor{P}_{\container{S}}\,\typeformer{M}_{\container{S}}\) fulfill the property
  \begin{equation}
    \typeformer{Final}_{\container{S}} := \sum_{(\coalg{\type{X}}{\function{\rho}} : \mathtt{Coalg}_{\container{S}})} \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{X}}{\function{\rho}}).
  \end{equation}
  That is \(\prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\typeformer{M}_{\container{S}}}{\function{out}})\). We denote the \texttt{M}-type as \(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}\) or \(\typeformer{M}_{\container{S}}\) or just \(\typeformer{M}\) when the container is clear from the context. When writing \(\mathtt{isContr}~\type{A}\), we mean \(\type{A}\) is of H-level \((-2)\), that is \(\sum_{\term{x} : \type{A}} \prod_{\term{y} : \type{A}} \term{y} \equiv \term{x}\) or equivalently \(\type{A} \equiv \unit\).
\end{defn}
\noindent Continuing our example we now construct streams as an \(\mathtt{M}\)-type.
\begin{exmp}
  \label{exmp:stream-M-type-example}
  We define streams over the type \(\type{A}\) as the \(\mathtt{M}\)-type over the container \(\containerpairsimple{\type{A}}{\unit}\). If we apply the polynomial functor to the \texttt{M}-type, then we get \(\functor{P}_{\containerpairsimple{\type{A}}{\unit}} \typeformer{M} = \type{A} \times \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\), illustrated in \figref{stream-M-type}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{A} & \type{A} \times \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \\
      & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[ul,"\destructor{hd}"] \ar[u,"\function{out}"'] \ar[ur,"\destructor{tl}"']
    \end{tikzcd}
    \caption{\texttt{M}-types of streams}
    \label{fig:stream-M-type}
  \end{figure}
  We will show that \(\function{out}\) is an isomorphism with inverse \(\function{in} : \functor{P}_{\container{S}}\,\typeformer{M} \rightarrow \typeformer{M}\) later in this section. We now have a semantic for the rules, we would expect for streams, if we let \(\constructor{cons} = \function{in}\) and \(\typeformer{stream}~\type{A} = \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\),
  \begin{equation}
    \vcenter{\infer[\mathtt{E}_{\destructor{hd}}]{\destructor{hd}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}}
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{E}_{\destructor{tl}}]{\destructor{tl}~\term{s} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}}
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{I}_{\constructor{cons}}]{\term{\constructor{cons}}~\term{x}~\term{xs} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \typeformer{stream}~\type{A}}}
  \end{equation}
  or more precisely \(\destructor{hd} = \pi_1 \circ \function{out}\) and \(\destructor{tl} = \pi_2 \circ \function{out}\).
\end{exmp}
\subsection{Construction of \texttt{M}-type}
We will show that \texttt{M}-types can be defined as the limit of a chain defined by repeatedly applying \(\functor{P}\) to the unit type \(\unit\).
\begin{defn}
  We define a chain as a family of morphisms \(\function{\pi}_{(n)} : \type{X}_{n+1} \rightarrow \type{X}_{n}\), over a family of types \(\type{X}_{n}\). See \figref{x-chain}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"]
    \end{tikzcd}
    \caption{Chain of types / functions}
    \label{fig:x-chain}
  \end{figure}
\end{defn}
\begin{defn}
  The limit of a chain is given as
  \begin{equation}
    \type{\mathcal{L}} = \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n)} \prod_{(n : \mathbb{N})} (\function{\pi}_{(n)}~\term{x}_{n+1} \equiv \term{x}_n)
  \end{equation}
\end{defn}
\begin{lem}\label{lem:limit-collapse}
  Given \(\function{\ell} : \prod_{(n : \mathbb{N})} (\type{X}_{n} \rightarrow \type{X}_{n+1})\) and \(\term{y} : \sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) the chain collapses as the equality \(\type{\mathcal{L}} \equiv \type{X}_0\).
  \begin{proof}
    We define this collapse by the isomorphism
    \begin{align}
      &\function{fun}_{\pathterm{\mathcal{L}collapse}}~(\term{x} , \pathterm{r}) = \term{x}_0 \\
      &\function{inv}_{\pathterm{\mathcal{L}collapse}}~\term{x}_0 = (\lambda\,n,~\function{\ell}^{(n)}~\term{x}_0)~,~(\lambda\,n,~\mathtt{refl}_{(\function{\ell}^{(n+1)}\,\term{x}_0)}) \\
      &\function{rinv}_{\pathterm{\mathcal{L}collapse}}~\term{x}_0 = \mathtt{refl}_{\term{x}_0}
    \end{align}
    where \(\function{\ell}^{(n)} = \function{\ell}_n \circ \function{\ell}_{n-1} \circ \dots \circ \function{\ell}_1 \circ \function{\ell}_0\). To define \(\function{linv}_{\pathterm{\mathcal{L}collapse}}~(\term{x} , \pathterm{r})\), we first define a fiber \((\type{X} , \term{z}, \function{\ell})\) over \(\mathbb{N}\) given some \(\term{z} : \type{X}_0\). Then any element of the type \(\sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) is equal to a section over the fiber we defined. This means \(\term{y}\) is equal to a section. Since the sections are defined over \(\mathbb{N}\), which is an initial algebra for the functor \(\functor{G}\type{Y} = \unit + \type{Y}\), we get that sections are contractible, meaning \(\term{y} \equiv \function{inv}_{\mathcal{L}collapse} (\function{fun}_{\mathcal{L}collapse}~\term{y})\), since both are equal to sections over \(\mathbb{N}\).
\end{proof}
\end{lem}
\begin{lem}\label{lem:function-to-M-type-is-cone}
  For all coalgebras \(\coalg{\type{C}}{\function{\gamma}}\) define over the container \(\container{S}\), we get \(\type{C} \rightarrow \typeformer{M}_{\container{S}} \equiv \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\), where \(\typeformer{Cone} = \sum_{(\function{f} : \prod_{(n : \mathbb{N})} \type{C} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{f}_{n+1} \equiv \function{f}_n\) illustrated in \figref{M-seq-cone}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"] \\
      & & \type{C} \ar[ull,"\function{f}_0"] \ar[ul,"\function{f}_1"'] \ar[u,draw=none,"\cdots" description] \ar[ur,"\function{f}_n"] \ar[urr,"\function{f}_{n+1}"'] \ar[urrr,draw=none,"\cdots"'] & 
    \end{tikzcd}
    \caption{Cone}
    \label{fig:M-seq-cone}
  \end{figure}  
  \begin{proof}
    We define an isomorphism from \(\type{C} \rightarrow \typeformer{M}_{\container{S}}\) to \(\typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\)
    \begin{align}
      &\function{fun}_{\pathterm{collapse}}~\function{f} = (\lambda\,n\,\term{z},\pi_1~(\function{f}~\term{z})~n),(\lambda\,n~i~\term{a},~\pi_2~(\function{f}~\term{a})~n~i) \\
      &\function{inv}_{\pathterm{collapse}}~(\function{u},\function{q})~\term{z} = (\lambda\,n,~\function{u}~n~\term{z}),(\lambda\,n\,i,~\function{q}~n~i~\term{z}) \\
      &\function{rinv}_{\pathterm{collapse}}~(\function{u},\function{q}) = \mathtt{refl}_{(\function{u},\function{q})} \\
      &\function{linv}_{\pathterm{collapse}}~\function{f} = \mathtt{refl}_{\function{f}}
    \end{align}
  \end{proof}
\end{lem}
\begin{thm}
  \label{thm:M-shift}
  Given the container \(\containerpair{\type{A}}{\typeformer{B}}\), we define a chain as the repeated application of \(\functor{P}\) to the unit element \(\type{X}_n = \functor{P}^n\,\unit\), and \(\function{\pi}_{(n)} = \functor{P}^n\,\constant{!}\) where \(\constant{!} : A \rightarrow \unit\) is the unique function into the unit type. Then there is an equality
  \begin{equation}
    \pathterm{shift} : \type{\mathcal{L}} \equiv \functor{P}\type{\mathcal{L}}
  \end{equation}
  \begin{proof}
    The proof is done using the two helper lemmas
    \begin{align}
      \pathterm{\alpha} : \type{\mathcal{L}}^{\functor{P}} \equiv \functor{P}\,\type{\mathcal{L}} \\
      \pathterm{\mathcal{L}unique} : \type{\mathcal{L}} \equiv \type{\mathcal{L}}^{\functor{P}}
    \end{align}
    where \(\mathcal{L}^{\functor{P}}\) is the limit of the shifted chain defined as \(\type{X'}_n = \type{X}_{n+1}\) and \(\function{\pi'}_{(n)} = \function{\pi}_{(n+1)}\). We can then define
    \begin{equation}
      \pathterm{shift} = \pathterm{\alpha} \ct \pathterm{\mathcal{L}unique}.
    \end{equation}
    We start by showing \(\pathterm{\mathcal{L}unique}\), by the ismorphism
    \begin{align}
      \function{fun}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \natcases{\unitelem}{\function{a}} , \natcases{\mathtt{refl}_{\unitelem}}{\function{b}} \\
    \function{inv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \function{a} \circ \constructor{succ}~,~\function{b} \circ \constructor{succ} \\
    \function{rinv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})} \\
    \function{linv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})}
    \end{align}
    By \(\pathterm{\mathcal{L}unique}\) we get that the limit of the chain is unique, so it just remains to show that, the limit of shifted chain is equal to \(\functor{P}\,\type{\mathcal{L}}\), which is \(\pathterm{\alpha}\) given by the equalities 
    \begin{align}
      \type{\mathcal{L}}^{\functor{P}} &\equiv \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_{n+1})} \prod_{(n : \mathbb{N})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \\
      &\equiv \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \label{eq:alpha-unfold}\\
      &\equiv \sum_{((\term{a} , \function{p}) : \sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n)} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,\term{a}_n \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv_* \function{u}_n \label{eq:alpha-swap} \\
      &\equiv \sum_{(\term{a} : \type{A})} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,a \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n \label{eq:alpha-limit-collapse} \\
      &\equiv \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{\mathcal{L}} \label{eq:alpha-cone}\\
      &\equiv \functor{P}\type{\mathcal{L}}
    \end{align}
    The equality from \eqref{eq:alpha-unfold} to \eqref{eq:alpha-swap} is rearranging terms, and adding a trivial point to the start of for the shifted chain. The equality from \eqref{eq:alpha-swap} and \eqref{eq:alpha-limit-collapse} is done with \lemref{limit-collapse} to collapse \(\sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n\) to \(\type{A}\). For the equality between \eqref{eq:alpha-limit-collapse} and \eqref{eq:alpha-cone}, we use \lemref{function-to-M-type-is-cone}. The rest of the equalities are trivial, completing the chain of equalities for the proof.
  \end{proof}
\end{thm}
\begin{defn}
  For the equality \(\pathterm{shift}\) we denote the functions back and forth as
  \begin{align}
    \function{out} &= \mathtt{transport}~\pathterm{shift} \\
    \function{in} &= \mathtt{transport}~(\sym{\pathterm{shift}}).
  \end{align}
\end{defn}
\begin{thm}
  \label{thm:M-type-final}
  The \texttt{M}-type \(\typeformer{M}_{\container{S}}\) is defined as the limit for a polynomial functor \(\functor{P}_{\container{S}}\). This definition fulfills the requirement for the \texttt{M}-type given in \defref{M-type-final-def} namely \(\typeformer{Final}_{\container{S}}~\type{\mathcal{L}}\).
  \begin{proof}
    Unfolding the definition we need to show that \(\prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}})\), so we assume we are given some \(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}}\) to show contractability by \((\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}}) \equiv \unit\). We get the following equalities,
    \begin{align}
      &\quad~\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}} \\
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{out} \circ \function{f} \equiv \functor{P}\function{f} \circ \function{\gamma}) \\
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{in} \circ \function{out} \circ \function{f} \equiv \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}) \\
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{in} \circ \functor{P}\function{f} \circ \function{\gamma})
    \end{align}
    since \(\function{in}\) and \(\function{out}\) are each others inverse, and \(\function{in}\) is part of an equality and therefore an embedding, which implies \((\function{in} \circ \function{a} \equiv \function{in} \circ \function{b}) \equiv (\function{a} \equiv \function{b})\). We let \(\function{\psi} = \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}\), which simplifies the expression to \(\sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{\psi}~\function{f})\). We define \(\function{e}\) to be the function from right to left for the equality in \lemref{function-to-M-type-is-cone}, we then get the equality
    \begin{equation}
      \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{\psi}~\function{f}) \quad \equiv \quad \sum_{(\term{c} : \typeformer{Cone}_{\coalg{C}{\gamma}})} (\function{e}~\term{c} \equiv \function{\psi}~(\function{e}~\term{c}))
  \end{equation}
  If we define a function \(\function{\phi} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \rightarrow \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\) as \(\function{\phi}~(\function{u},\function{g}) = (\function{\phi}_0~\function{u},\function{\phi}_1~\function{u}~\function{g})\) where
  \begin{align}
    \function{\phi}_0~\function{u} &= \natcases{(\lambda\,\_, \unitelem)}{\functor{P}\function{f} \circ \function{\gamma} \circ \function{u}} \\
    \function{\phi}_1~\function{u}~\function{g} &= \natcases{\mathtt{funExt}~\lambda\,\_, \mathtt{refl}_{\unitelem}}{\mathtt{ap}~(\functor{P}\function{f} \circ \function{\gamma}) \circ \function{g}}
  \end{align}
  then we get the commuting square in \figref{commuting-square},
    \begin{figure}[b]
    \centering
    \begin{tikzcd}
      \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \ar[d,"\function{\phi}"] \ar[r,"\function{e}"] & (\type{C} \rightarrow \type{\mathcal{L}}) \ar[d,"\function{\psi}"] \\
      \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \ar[r,"\function{e}"] & (\type{C} \rightarrow \type{\mathcal{L}})
    \end{tikzcd}
    \caption{commuting square}
    \label{fig:commuting-square}
  \end{figure}
  which says \(\function{\psi}~(\function{e}~\term{c}) = \function{e}~(\function{\phi}~\term{c})\), so we can continue the simplification
  \begin{equation}
    \sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\function{e}~\function{c} \equiv \function{e}~(\function{\phi}~\function{c}))
  \end{equation}
  We know that \(\function{e}\) is part of an equality (namely \lemref{function-to-M-type-is-cone}), so it is an embedding, that is for all \(\term{a},\term{b}\) the equality \(\function{e}~\term{a} \equiv \function{e}~\term{b}\) implies \(\term{a} \equiv \term{b}\), using this and unfolding the definition of \(\function{\phi}\), we get the equalities
  \begin{align}
    &\quad~\sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\function{c} \equiv \function{\phi}~\function{c}) \\
    &\equiv \sum_{(\term{(\function{u},\function{g})} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} ((\function{u},\function{g}) \equiv (\function{\phi}_0~\function{u},\function{\phi}_1~\function{u}~\function{g})) \\
    &\equiv \sum_{(\term{(\function{u},\function{g})} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} \sum_{(\pathterm{p} : \function{u} \equiv \function{\phi}_0\,\function{u})} \function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}
  \end{align}
  We rearrange and unfold the definition of \(\typeformer{Cone}\) to get
  \begin{equation}
    \sum_{\big(\term{(\function{u},\pathterm{p})} : \sum_{(\function{u} : \prod_{(n:\mathbb{N})} \type{C} \rightarrow \type{X}_n)} \function{u} \equiv \function{\phi}_0\,\function{u}\big)} \sum_{(\function{g} : \prod_{(n:\mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n)}\function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}
  \end{equation}
  We define the following two equalities from \lemref{limit-collapse}
  \begin{align}
    \unit &\equiv \left(\sum_{(\function{u} : \prod_{(n:\mathbb{N})} \type{C} \rightarrow \type{X}_n)} \function{u} \equiv \function{\phi}_0\,\function{u}\right)  \\
    \unit &\equiv_{*} \left(\sum_{(\function{g} : \prod_{(n:\mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n)}\function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}\right)
  \end{align}
  using these two equalities the proof becomes showing \(\sum_{\unitelem : \unit} \unit \equiv \unit\), which is trivial.
  \end{proof}
\end{thm}

\section{Coinduction Principle for \texttt{M}-types}
We can now construct a coinduction principle for \texttt{M}-types given a (strong) bisimulation relation.
\begin{defn}
  For all coalgebras \(\coalg{\type{C}}{\function{\gamma}} : \typeformer{Coalg}_{\container{S}}\), then a relation \(\relation{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\) is a (strong) bisimulation relation, if the type \(\type{\overline{\mathcal{R}}} = \sum_{(\term{a} : \type{C})} \sum_{(\term{b} : \type{C})} \term{a}~\relation{\mathcal{R}}~\term{b}\) and the function \(\function{\alpha}_{\relation{\mathcal{R}}} : \type{\overline{\mathcal{R}}} \rightarrow \functor{P}_{\container{S}}\,\type{\overline{\mathcal{R}}}\) forms a \(\functor{P}\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} : \mathtt{Coalg}_{\container{S}}\), that makes the diagram in \figref{coalgebra-coinduction-definition} commute (\(\Longrightarrow\) represents \(\functor{P}\)-coalgebra morphisms). That is \(\function{\gamma} \circ \pi_1^{\type{\overline{\mathcal{R}}}} \equiv \functor{P}\,\pi_1^{\type{\overline{\mathcal{R}}}} \circ \function{\alpha}_{\relation{R}}\), and similarly for \(\pi_2^{\type{\overline{\mathcal{R}}}}\).
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\type{C}}{\function{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\function{\gamma}}
    \end{tikzcd}
    \caption{Bisimulation for a coalgebra}
    \label{fig:coalgebra-coinduction-definition}
  \end{figure}
\end{defn}
\begin{thm}[Coinduction principle]
  \label{thm:M-coinduction-principle}
  Given a relation \(\relation{\mathcal{R}}\), that is a bisimulation for an \texttt{M}-type, then for all \(\term{x},\term{y}\) if \(\term{x}~\relation{\mathcal{R}}~\term{y}\) then they are equal \(\term{x} \equiv \term{y}\).  
  \begin{proof}
    Given a relation \(\relation{\mathcal{R}}\), that is part of a bisimulation over a final \(\functor{P}\)-coalgebra \(\coalg{\typeformer{M}}{\function{out}}:\mathtt{Coalg}_{\container{S}}\) we get the diagram in \figref{final-coalgebra-coinduction}.
    \begin{figure}[h]
      \centering
      \begin{tikzcd}[row sep=huge,column sep=huge]
        \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\typeformer{M}}{\function{out}}
      \end{tikzcd}
      \caption{Bisimulation principle for final coalgebra}
      \label{fig:final-coalgebra-coinduction}
    \end{figure}
    By the finality of \(\coalg{\typeformer{M}}{\function{out}}\), we get a function \(\constant{!}\), such that \(\pi_1^{\type{\overline{\mathcal{R}}}} \equiv ~\constant{!} \equiv \pi_2^{\type{\overline{\mathcal{R}}}}\). Now if we are given \(\term{r} : \term{x}~\relation{\mathcal{R}}~\term{y}\), we can construct the equality
    \begin{equation}
      \term{x} \equiv \pi_1^{\type{\overline{\mathcal{R}}}} (\term{x}, \term{y}, \term{r}) \equiv \pi_2^{\type{\overline{\mathcal{R}}}} (\term{x}, \term{y}, \term{r}) \equiv \term{y}.
    \end{equation}
    Giving us the coinduction principle for \texttt{M}-types.
  \end{proof}
\end{thm}
\noindent We therefore get nice equalities for \texttt{M}-types, where we can define a bisimulation. For example the bisimilarity given for streams in the introduction \eqref{eq:stream-bisimilarity}, will give us equality principle for streams by this coinduction principle.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\section{Examples of \texttt{M}-types}
\label{ch:M-types-examples}
In this section we show some examples of coinductive types that can be constructed as \texttt{M}-types, and show how to define the constructors/destructors of these types. We conclude this chapter with some general observation, and define some rules for how to construct \texttt{M}-types. \todo{Is there anything else that is show for each M-type?}

\subsection{ITrees as \texttt{M}-types}
Interaction trees (ITrees) \cite{DBLP:itrees} are used to model effectful behavior, where computations can interact with an external environment by events. ITrees are defined by the following constructors
\begin{equation}
  \vcenter{\infer[\mathtt{I}_{\constructor{Ret}}]{\constructor{Ret}~\term{r} : \typeformer{itree}~\typeformer{E}\,\type{R}}{r : \type{R}}}
\end{equation}
\begin{equation}
  \vcenter{\infer[\mathtt{I}_{\constructor{Vis}}]{\constructor{Vis}~\term{a}~\term{f} : \typeformer{itree}~\typeformer{E}\,\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \typeformer{E}\,\type{A} & \term{f} : \type{A} \rightarrow \typeformer{itree}~\typeformer{E}\,\type{R}}}.
\end{equation}
\begin{equation}
  \vcenter{\infer[\mathtt{E}_{\constructor{Tau}}]{\constructor{Tau}~\term{t} : \typeformer{itree}~\typeformer{E}\,\type{R}}{\term{t} : \typeformer{itree}~\typeformer{E}\,\type{R}}}.
\end{equation}
where \(\type{R}\) is the type for returned values, while \(\typeformer{E}\) is a dependent type for events representing external interactions. We will try and give some intuition on how to construct this type, by constructing types with two out of three of these constructors.

\subsubsection{Delay Monad}
We start by looking at ITrees without the \(\constructor{Vis}\) constructor, this type is also know as the delay monad. It can be used to model delayed computations, either returning immediately given by the constructor \(\constructor{now} = \constructor{Ret}\), or delayed some (possibly infinite) number of steps by the constructor \(\constructor{later} = \constructor{Tau}\). We construct this type as an \texttt{M}-type.
\begin{thm}
  The delay monad can be defined as the \texttt{M}-type.
  \begin{proof}
    We want to construct a container, that will give us two constructors, one that returns immediately and one that delays the computation, that is the
    \begin{equation}
      \container{S} = \containerpair{\type{R} +\unit}{\begin{cases} \empt & \mathtt{inl}~\term{r} \\ \unit & \mathtt{inr}~\unitelem \end{cases}}
    \end{equation}
    which gives us the polynomial functor
    \begin{equation}
      \functor{P}_{\container{S}}\,\type{X} = \sum_{(\term{x} : \type{R} + \unit)} \begin{cases} \empt & \term{x} = \mathtt{inl}~\term{r} \\ \unit & \term{x} = \mathtt{inr}~\unitelem \end{cases} \rightarrow \type{X},
    \end{equation}
    since this definition is not dependent, we can simplify it to the following
    \begin{equation}
      \functor{P}_{\container{S}}\,\type{X} = \type{R} \times (\empt \rightarrow \type{X}) + \type{X}.
    \end{equation}
    from the property that \((\empt \rightarrow \type{X}) \equiv \unit\), we can simplify the definition further to
    \begin{equation}
      \functor{P}_{\container{S}}\,\type{X} = \type{R} + \type{X}
    \end{equation}
    meaning we get diagram in \figref{delay-monad}, by applying \(\functor{P}_{\container{S}}\) to \(\mathtt{M}_{\container{S}}\) and using the functions \(\function{in}\) and \(\function{out}\) defined by the equality \(\pathterm{shift}\).
    \begin{figure}[h]
      \centering
      \begin{tikzcd}[row sep=large,column sep=large]
        \type{R} \ar[dr,"\constructor{now}"'] \ar[r,"\texttt{inl}"] & \type{R} + \typeformer{M} \ar[d,"\function{in}"'] & \typeformer{M} \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{later}"] \\
        & \typeformer{M}
      \end{tikzcd}
      \caption{Delay monad}
      \label{fig:delay-monad}
    \end{figure}
    \noindent We define the constructors \(\constructor{now}\) and \(\constructor{later}\) using \(\function{in}\) function for \texttt{M}-types, together with the injections \(\mathtt{inl}\) and \(\mathtt{inr}\), such that the diagram in \figref{delay-monad} commutes.
  \end{proof}
\end{thm}

\subsubsection{\(\type{R}\)-valued \(\typeformer{E}\)-event Trees}
Now lets look at the example, where we remove the \(\constructor{Tau}\) constructor. This gives us a type of tree, with leaves given by \(\constructor{Ret}\), and nodes given by \(\constructor{Vis}\) branching based on some type \(\type{A}\), for an event \(\term{a} : \typeformer{E}\,\type{A}\). 
\begin{thm}
  We define \(\type{R}\)-valued \(\typeformer{E}\)-event trees as an \texttt{M}-type
  \begin{proof}
    We want a container, with a leaf constructor, that returning immediately with a value, and a node constructor, that branches on some event. We defined this by the container
  \begin{equation}
    \container{S} = \containerpair{\type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} \typeformer{E}\,\type{A}}{\begin{cases}\empt & \mathtt{inl}~\term{r} \\ \type{A} & \mathtt{inr}~(\type{A},\term{e})\end{cases}}.
  \end{equation}
for which we get the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}\,\type{X} = \sum_{(\term{x} : \type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} \typeformer{E}\,\type{A})} \begin{cases}\empt & \term{x} = \mathtt{inl}~\term{r} \\ \type{A} & \term{x} = \mathtt{inr}~(\type{A},\term{e})\end{cases} \rightarrow \type{X},
\end{equation}
we can again split the two case into a sum
\begin{equation}
  \functor{P}_{\container{S}}\,\type{X} = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \type{X})),
\end{equation}
and simplify further using \((\empt \rightarrow \type{X}) \equiv \unit\), to get the definition
\begin{equation}
  \functor{P}_{\container{S}}\,\type{X} = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \type{X}).
\end{equation}
By applying this polynomial functor to the \texttt{M}-type, we get the diagram in \figref{tree-constructors}. 
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\constructor{Ret}"'] \ar[r,"\texttt{inl}"] & \type{R} + \sum_{\type{A} : \universe{U}} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[d,"\function{in}"]  & \sum_{\type{A} : \universe{U}} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{Vis}"] \\
    & \typeformer{M}
  \end{tikzcd}
  \caption{Tree Constructors}
  \label{fig:tree-constructors}
\end{figure}
We can again define \(\constructor{Ret}\) and \(\constructor{Vis}\) using the \(\function{in}\) function together with injections. We can see that \constructor{now} and \constructor{Ret} has the same structure, both in the diagram and in how they were defined in the container.
\end{proof}
\end{thm}

\subsubsection{ITrees}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types.
\todo[inline]{Get the correct equivalence for ITrees (Part of project description?)}
\begin{thm}
  We define the type of ITrees as the \texttt{M}-type
  \begin{proof}
    We combine the constructions of the delay monad and \(\type{R}\)-valued \(\typeformer{E}\)-event Trees, into the container
    \begin{equation}
      \container{S} = \containerpair{\type{R}+\unit+\sum_{\type{A}:\universe{\mathcal{U}}} (\typeformer{E}\,\type{A})}{\begin{cases} \empt & \texttt{inl}~r \\ \unit & \texttt{inl}~(\texttt{inl}~\unitelem) \\ \type{A} & \texttt{inr}~(\texttt{inr}~(\type{A},\term{e})) \end{cases}}.
    \end{equation}
    \noindent For which the reduced polynomial functor is
    \begin{equation}
      \functor{P}_{\container{S}}\,\type{X} = \type{R} + \type{X} + \sum_{(\type{A} : \universe{\mathcal{U}})} (\typeformer{E}\,\type{A} \times (\type{A} \rightarrow \type{X}))
    \end{equation}
    Applying this polynomial functor to the \texttt{M}-type, for the container, we get the diagram in \figref{ITree-constructors},
    \begin{figure}[h]
      \centering
      \begin{tikzcd}[row sep=large,column sep=large]
        \type{R} \ar[ddrr,"\constructor{Ret}"'] \ar[r,"\texttt{inl}\,\circ\,\texttt{inr}"] & \typeformer{M} + \type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} (\typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{M})) \ar[ddr,"\function{in}"] & & \sum_{\type{A} : \universe{U}} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[ll,"\texttt{inr}"'] \ar[ddl,"\constructor{Vis}"] \\
        & & \typeformer{M} \ar[ul,"\texttt{inl}\,\circ\,\texttt{inl}"'] \ar[d,"\constructor{Tau}"'] \\
        & & \typeformer{M}
      \end{tikzcd}
      \caption{ITree constructors}
      \label{fig:ITree-constructors}
    \end{figure}
    from which the constructors of the ITrees type can be defined using \(\function{in}\) and injections.
  \end{proof}
\end{thm}

\subsection{General rules for constructing \texttt{M}-types}
We want to create a rule set for how to define coinductive types as \texttt{M}-types, we take inspiration from the rules for containers \cite{DBLP:DiffContainer}. We would like to be able to define a type from a given set of constructor / destructors. If we for example is given the rule
\begin{equation}
  \vcenter{\infer{\constructor{ret}~a : \type{T}}{\term{a} : \type{A}}}
\end{equation}
we get that it corresponds to the \texttt{M}-type for the container \(\containerpairsimple{\type{A}}{\empt}\), while if we have something that produces an element of it self as
\begin{equation}
  \vcenter{\infer{\destructor{tl}~\term{a} : \type{T}}{\term{a} : \type{T}}}
\end{equation}
the container is \(\containerpairsimple{\unit}{\unit}\). If we want a type with both these rules, then we just take the disjoint union of the two containers
\begin{equation}
  \containerpair{\type{A} + \unit}{\begin{cases} \empt & \mathtt{inl}~\term{a} \\ \unit & \mathtt{inr}~\unitelem \end{cases}}
\end{equation}
which is the delay type. We define some more involved constructors, that build on the type itself
\begin{equation}
  \vcenter{\infer{\constructor{node}~\term{a} : \type{T}}{\term{a} : \type{A} \rightarrow \type{T}}}
\end{equation}
has container \(\containerpair{\unit}{\type{A}}\). A type for the destructor
\begin{equation}
  \vcenter{\infer{\destructor{hd}~\term{a} : \type{A}}{\term{a} : \type{T}}}
\end{equation}
can be constructed by the container \(\containerpairsimple{\type{A}}{\empt}\), but this container is the same as the one for \(\constructor{ret}\), so do we get both? Whether we get a constructor or destructor depends on how we combine the containers with the containers for other constructors / destructors. In general adding containers \(\containerpair{\type{A}}{\typeformer{B}}\) and \(\containerpair{\type{C}}{\typeformer{D}}\) for two constructors together is done by
\begin{equation}
  \containerpair{\type{A} + \type{C}}{ \begin{cases} \typeformer{B}\,\term{a} & \mathtt{inl}~\term{a} \\ \typeformer{D}\,\term{c} & \mathtt{inr}~\term{c} \end{cases}}
\end{equation}
whereas adding containers for two destructors is done by
\begin{equation}
  \containerpairsimple{\type{A} \times \type{C}}{\lambda\,(\term{a},\term{c}),~\typeformer{B}\,\term{a} + \typeformer{D}\,\term{c}}  
\end{equation}
however combining destructors and constructors is not as simple. Any type \(\type{T}\) that can be defined using a (coinductive) record (except for higher inductive types), will also be definable as an \texttt{M}-type. Given a record, which is a list of fields \(\term{f}_1 : \type{F}_1,\term{f}_2 : \type{F}_2,\dots,\term{f}_n : \type{F}_n\), we can construct the \texttt{M}-types by the container
\begin{equation}
  \containerpairsimple{\type{F}_1 \times \type{F}_2 \times \dots \times \type{F}_n}{\empt}
\end{equation}
where each destructor \(\destructor{d_n} : \type{T} \rightarrow \type{F_n}\) for the field \(\term{f}_n\) will be defined as \(\destructor{d_n}~\term{t} = \pi_n~(\function{out}~\term{t})\). However fields in a coinductive record may depend on previous defined fields. That is we can have the list of fields \(\term{f}_1 : \type{F}_1,\term{f}_2 : \typeformer{F}_2,\cdots,\term{f}_n : \typeformer{F}_n\), where each field depends on all the previous once. We define this as the \texttt{M}-type for the container
\begin{equation}
  \containerpairsimple{\sum_{(\term{f}_1 : \type{F}_1)} \sum_{(\term{f_2} : \typeformer{F}_2)} \cdots \sum_{(\term{f}_{n-1} : \typeformer{F}_{n-1})}\typeformer{F}_n}{\empt}
\end{equation}
however, if any of the fields are non dependent, then they can be added as a product (\(\times\)) instead of a dependent sum (\(\Sigma\)). Fields may also coinductively construct an element of the record \(\type{T}\), however other fields may not refer to such a field, since it will break the strictness requirements of the record / coinductive type. As an example let \(\type{f}_1\) be a type and \(\function{f_2}\) be the function with type \(\typeformer{F}_2 = \type{f}_1 \rightarrow (\type{f}_1 \rightarrow \type{A}) \rightarrow \mathtt{M}\), which by currying is equal to \(\type{f}_1 \times (\type{f}_1 \rightarrow \type{A}) \rightarrow \mathtt{M}\), we can then define by the container
\begin{equation}
  \containerpair{\sum_{(\type{f}_1 : \universe{\mathcal{U}})} \left(\unit \times \sum_{(\term{f}_3 : \typeformer{F}_3)} \cdots \sum_{(\term{f}_{n-1} : \typeformer{F}_{n-1})}\typeformer{F}_n\right)}{\lambda\,(\type{f}_1,\unitelem,\term{f}_3,\dots),\typeformer{F}_2}
\end{equation}
where \(\typeformer{F}_2\) have been moved to the last part of the container, we can even leave out the "\(\unit \times\)" from the container. Another case is that the type of a field is dependent \(\typeformer{F_2} = (\term{x} : \type{f}_1) \rightarrow \typeformer{B}\,\term{x} \rightarrow \mathtt{M}\), but again by currying we can get \(\typeformer{F_2} : \sum_{(\term{x} : \type{f}_1)} \typeformer{B}\,\term{x} \rightarrow \mathtt{M}\) which can be defined by the container
\begin{equation}
  \containerpair{\sum_{(\type{f}_1 : \universe{\mathcal{U}})} \sum_{(\term{f}_3 : \typeformer{F_3})} \cdots \sum_{(\term{f}_{n-1} : \typeformer{F_{n-1}})}\typeformer{F_n}}{\lambda\,(\type{f}_1,\term{f}_3,\dots),\sum_{\term{x} : \type{f}_1} (\typeformer{B}\,\term{x})}
\end{equation}
so we would also expect that a type defined as a (coinductive) record is equal to the version defined as a \texttt{M}-type. However this has not been shown formally. \todo{Something about the proof almost being done}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Q\texttt{M}-types}
\label{ch:QM-types}
In this chapter we will introduce rules for set truncated quotients, and show some ways of how to construct quotiented \texttt{M}-types which we call Q\texttt{M}-types. We show examples of how you can be constructed a quotient inductive-inductive type (QIIT) that is equal to the Q\texttt{M}-type assuming axiom of choice. The examples are multisets and the partiality monad, defined as quotients with weak bisimilarity relations. We conclude the chapter by discussion, how we should define Q\texttt{M}-types.

\section{Elimintators and Recursors for the Set Truncated Quotient}
We start by defining the recursor and some eliminators for the set truncated quotient, which will be used in the upcoming sections.
\begin{defn}[Recursor for quotient]
  \label{defn:quotient-recursor}
  For all elements \(\term{x}, \term{y} : \type{A}\), functions \(\function{f} : \type{A} \rightarrow \type{B}\) and relations \(\function{g} : \term{x}~\relation{R}~\term{y} \rightarrow \function{f}~\term{x} \equiv \function{f}~\term{y}\), then if \(\type{B}\) is a set, we get a function from \(\type{A} / \relation{R}\) to \(\type{B}\), defined by case as
  \begin{equation}
    \label{eq:quotient-recursor}
    \begin{aligned}
      &\function{rec}~\quotientconstructor{\term{a}} = \function{f}~\term{a} \\
      &\function{rec}~(\constructor{eq/}~\_~\_~\term{r}~i) = \function{g}~\term{r}~i \\
      &\function{rec}~(\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \term{B_{set}}~(\function{rec}~\term{a})~(\function{rec}~\term{b})~(\mathtt{ap}~\function{rec}~\pathterm{p})~(\mathtt{ap}~\function{rec}~\pathterm{q})~i~j
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}[Propositional eliminator for quotient]
  \label{defn:propositional-elimination-quotient}
  Given a dependent type \(\typeformer{P} : \type{A} / \relation{R} \rightarrow \universe{\mathcal{U}}\) , that is a proposition at all points \(\function{P_{prop}} : \prod_{(\term{x} : \type{A} / \relation{R})} \typeformer{isProp}~(\typeformer{P}\,\term{x})\), then given a proof for the base case \(\function{f} : \prod_{(\term{a} : \type{A})} \typeformer{P}\,\quotientconstructor{\term{a}}\) we get a function from \(\term{x} : \type{A} / \relation{R}\) to \(\typeformer{P}\,\term{x}\), defined as
  \begin{equation}
    \begin{aligned}
      &\function{elimProp}~\quotientconstructor{\term{a}} = \function{f}~\term{a}\\
      &\function{elimProp}~(\constructor{eq/}~\term{a}~\term{b}~i) = \function{P_{prop}}~(\function{elimProp}~\term{a})~(\function{elimProp}~\term{b})~(\constructor{eq/}~\term{a}~\term{b})~i \\
      &\function{elimProp}~(\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \\
      &\qquad\function{isSet{\rightarrow}isSetDep}~(\function{isProp{\rightarrow}isSet} \circ \function{P_{prop}}) \\
      &\qquad\quad (\function{elimProp}~\term{a})~(\function{elimProp}~\term{b})~(\mathtt{ap}~\function{elimProp}~p)~(\mathtt{ap}~\function{elimProp}~q)\\
      &\qquad\quad (\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q})~i~j
    \end{aligned}
  \end{equation}
  where \(\function{isSet{\rightarrow}isSetDep}\) takes a function \(\prod_{\term{a} : \type{A}} \function{isSet}~(\typeformer{B}\,\term{a})\) to the dependent version \(\function{isSetDep}~\type{A}~\typeformer{B}\). Using this eliminator we can to do propositional elimination of a quotient, by supplying the base case \(\typeformer{P}\,\quotientconstructor{\term{a}}\).
\end{defn}
\begin{defn}[Eliminator for quotients]
  \label{defn:quotient-eliminator}
  Given a dependent type \(\typeformer{P} : \type{A} / \relation{R} \rightarrow \universe{\mathcal{U}}\) which is a set \(\function{P_{set}} : \prod_{(\term{x} : \type{A}/\relation{R})} \function{isSet}~(\typeformer{P}\,\term{x})\), a proof for the base case \(\function{f} : \prod_{(\term{a} : \type{A})} \typeformer{P}\,\quotientconstructor{\term{a}}\) and a proof for the equality case \(\function{f_{eq}} : \prod_{(\term{a},\term{b} : A)} \prod_{(\term{r} : \term{a}~\relation{R}~\term{b})} \function{f}~\term{a} \equiv_* \function{f}~\term{b}\) for the equality constructor \(\constructor{eq/}~\term{a}~\term{b}~\term{r}\), we get a function \(\function{elim} : (\term{x} : \type{A} / \relation{R}) \rightarrow \typeformer{P}\,\term{x}\) as follows
  \begin{equation}
    \begin{aligned}
      &\function{elim}~\quotientconstructor{\term{a}} = \function{f}~\term{a} \\
      &\function{elim}~(\constructor{eq/}~\term{a}~\term{b}~\term{r}~i) = \function{f_{eq}}~\term{a}~\term{b}~\term{r}~i \\[1mm]
      &\function{elim}~(\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \\[-1mm]
      &\quad\function{isSet{\rightarrow}isSetDep}~\function{P_{set}}~(\function{elim}~\term{a})~(\function{elim}~\term{b})~(\mathtt{ap}~\function{elim}~\pathterm{p})~(\mathtt{ap}~\function{elim}~\pathterm{q})~(\constructor{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q})~i~j
    \end{aligned}
  \end{equation}
  which is the eliminator for quotients.
\end{defn}
\noindent We can now construct some more interesting data types, by set quotienting \texttt{M}-types, which we call Q\texttt{M}-types, some examples follow in the following section. \todo{preserves the H-level}

\section{Q\texttt{M}-types and Quotient inductive-inductive types (QIITs)}
In this section we will show some examples of quotiented \texttt{M}-type, defined using set truncated quotients. We will construct the same type using quotient inductive-inductive types instead, and show these two construction gives equal types, assuming the axiom of choice. A quotient inductive-inductive type (QIIT) is a type that is defined at the same time as a relation over that type and set truncated. We believe, but do not show, that this equality between the two ways of constructing Q\texttt{M}-types is general. However QIITs are more general than our Q\texttt{M}-types, so we cannot expect every QIIT to have a corresponding Q\texttt{M}-type.

\subsection{Multiset}
In this subsection we define infinite trees, where the order of subtrees does not matter also known as multisets \cite{DBLP:QIIT}\cite{DBLP:tt-in-tt}\cite{DBLP:Constructing-QIITs}, we construct the type of multisets as a QM-type and as a QIIT and show these are equal (\thmref{QM-QIIT-eq-multiset}). We start by defining the tree type we want to quotient.
\begin{defn}
  We define \(\type{A}\)-valued \(\mathbb{N}\)-branching trees \(\typeformer{T}\,\type{A}\) as the \texttt{M}-type defined by the container
  \begin{equation}
    \left(\type{A}+\unit, \begin{cases} \empt & \mathtt{inl}~\term{a} \\ \mathbb{N} & \mathtt{inr}~\unitelem \end{cases}\right)
  \end{equation}
  For which we get the constructors\\[-10mm]
  \begin{center}
    \strut
    \hfill
    \begin{minipage}[b]{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{leaf}~\term{a} : \typeformer{T}\,\type{A}}{\term{a} : \type{A}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{node}~\function{f} : \typeformer{T}\,\type{A}}{\function{f} : \mathbb{N} \rightarrow \typeformer{T}\,\type{A}}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{center}
\end{defn}
\noindent Trees where the permutation of subtrees does not matter is multisets. We define equality between permuation of subtrees by the following rule
\begin{equation}
  \vcenter{\infer[\constructor{perm}]{\constructor{node}~\function{f} \equiv \constructor{node}~(\function{f} \circ \function{g})}{\function{f} : \mathbb{N} \rightarrow \typeformer{T}\,\type{A} & \function{g} : \mathbb{N} \rightarrow \mathbb{N} & \mathtt{isIso}~\function{g}}}
\end{equation}
One way to define this type is as the Q\texttt{M}-type given by quotienting \(\typeformer{T}\,\type{A}\) by the relation \(\relation{\sim_T}\) defined by the constructors
\begin{center}
  \strut
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{leaf}}]{\constructor{leaf}~\term{x}~\relation{\sim_{T}}~\constructor{leaf}~\term{y}}{\term{x} \equiv \term{y}}}
    \end{equation}
  \end{minipage}
  \hfill
  \begin{minipage}{0.35\linewidth}
    \begin{equation}
      \vcenter{\infer[\constructor{\sim_{node}}]{\constructor{node}~\function{f}~\relation{\sim_T}~\constructor{node}~\function{g}}{\prod_{(n : \mathbb{N})} \function{f}~n~\relation{\sim_T}~\function{g}~n}}
    \end{equation}
  \end{minipage}
  \hfill
  \strut
\end{center}
\begin{equation}
  \vcenter{\infer[\constructor{\sim_{perm}}]{\constructor{node}~\function{f}~\relation{\sim_T}~\constructor{node}~(\function{f} \circ \function{g})}{\function{f} : \mathbb{N} \rightarrow \typeformer{T}\,\type{A} & \function{g} : \mathbb{N} \rightarrow \mathbb{N} & \mathtt{isIso}~\function{g}}}
\end{equation}
We have the problem that we cannot lift the definition of \(\constructor{node}\) to the quotiented type, without the use of the axiom of choice. To solve this problem we can define multisets as a QIIT denoted \(\typeformer{MS}~\type{A}\), with the constructors \(\constructor{leaf}, \constructor{node}\) and \(\constructor{perm}\) and set truncation constructor \(\constructor{MS\text{-}isSet}\). We show these two ways of constructing a type for multisets are equal assuming the axiom of (countable) choice.
\begin{defn}
  There is a function from \(\typeformer{T}\,\type{A}\) to \(\typeformer{MS}~\type{A}\)
  \begin{equation}
    \begin{aligned}
      &\function{T{\rightarrow}MS}~(\constructor{leaf}_{\typeformer{T}}~\term{x}) = \constructor{leaf}_{\typeformer{MS}}~\term{x} \\
      &\function{T{\rightarrow}MS}~(\constructor{node}_{\typeformer{T}}~\function{f}) = \constructor{node}_{\typeformer{MS}}~(\function{T{\rightarrow}MS} \circ \function{f})
    \end{aligned}
  \end{equation}
\end{defn}
This function takes weakly bisimilar objects to equal once.
\begin{lem}
  If \(\term{x}, \term{y} : \typeformer{T}\,\type{A}\) are weakly bisimilar \(p : \term{x}~\relation{\sim_{T}}~\term{y}\) then \(\function{T{\rightarrow}MS}~\term{x} \equiv \function{T{\rightarrow}MS}~\term{y}\).
  \begin{proof}
    We do the proof by casing on the weak bisimilarity.
    \begin{equation}
      \begin{aligned}
        &\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}~(\constructor{\sim_{leaf}}~\pathterm{p}) = \mathtt{ap}~\constructor{leaf}_{\typeformer{MS}}~\pathterm{p} \\
        &\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}~(\constructor{\sim_{node}}~\function{k}) = \mathtt{ap}~\constructor{node}_{\typeformer{MS}}~(\mathtt{funExt}~(\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}} \circ \function{k})) \\
        &\function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}~(\constructor{\sim_{perm}}~\function{f}~\function{g}~\term{e}) = \constructor{perm}~(\function{T{\rightarrow}MS} \circ \function{f})~\function{g}~\term{e}
      \end{aligned}
    \end{equation}
  \end{proof}
\end{lem}
\noindent With this lemma, we can lift the function \(\function{T{\rightarrow}MS}\) to the quotient.
\begin{defn}
  There is a function \(\function{T/{\sim}{\rightarrow}MS}\) from \(\typeformer{T}\,\type{A}/\relation{\sim_{T}}\) to \(\typeformer{MS}~\type{A}\), defined using the recursor for quotients defined in \defref{quotient-recursor}, with \(\function{f} = \function{T{\rightarrow}MS}\) and \(\function{g} = \function{T{\rightarrow}MS\text{-}{\sim}{\rightarrow}{\equiv}}\) and \(\typeformer{MS}\) is a set by \(\constructor{MS\text{-}isSet}\)
\end{defn}
\begin{lem}
  \label{lem:weak-bisim-to-eq-multiset}
  Given an equality \(\function{T{\rightarrow}MS}~\term{x} \equiv \function{T{\rightarrow}MS}~\term{y}\) then \(\term{x}~\relation{\sim_{T}}~\term{y}\).
  \begin{proof}
    If \(x\) and \(y\) are leafs with values \(a\) and \(b\) then \(a \equiv b\) by the injectivity of the constructor \(\constructor{leaf}_{\typeformer{MS}}\), making a bisimilarity using \(\sim_{leaf}\). If \(x\) and \(y\) are nodes defined by functions \(f\) and \(g\), then by the injectivity of the constructor \(\constructor{node}_{\typeformer{MS}}\), we get \(\prod_{(n : \mathbb{N})} \function{f}~n \equiv \function{g}~n\) and by induction we get \(\prod_{(n : \mathbb{N})} \function{f}~n~\relation{\sim_{T}}~\function{g}~n\), making us able to use \(\constructor{\sim_{node}}\) to construct the bisimilarity. We do not get any other equalities, since \(\constructor{leaf}_{\typeformer{MS}}\) and \(\constructor{node}_{\typeformer{MS}}\) are disjoint.
  \end{proof}
\end{lem}
\begin{lem}
  The function \(\function{T/{\sim}{\rightarrow}MS}\) is injective, meaning \(\function{T/{\sim}{\rightarrow}MS}~\term{x} \equiv \function{T/{\sim}{\rightarrow}MS}~\term{y}\) implies \(\term{x} \equiv \term{y}\).
  \begin{proof}
    We show injectivity by doing propositional elimination defined in \defref{propositional-elimination-quotient}, with
    \begin{equation}
      \typeformer{P} = (\lambda\,\term{x},~\function{T/{\sim}{\rightarrow}MS}~\term{x} \equiv \function{T/{\sim}{\rightarrow}MS}~\term{y} \rightarrow \term{x} \equiv \term{y})
    \end{equation}
    which is a proposition for all \(\term{x}\) by \(\function{P_{prop}} = \lambda\,\term{x},~\function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\term{x}~\term{y})\). We do it twice, first for \(\term{x}\) and then for \(\term{y}\) where we define \(\typeformer{P}\) and \(\function{P_{prop}}\) similarly, but with \(\term{x} = \quotientconstructor{\term{a}}\) since it has already been propositionally eliminated. 
    \begin{equation}
      \begin{aligned}
        &\function{elimProp}~(\lambda\,\term{a},~\function{elimProp} (\lambda\,\term{b},~\constructor{eq/}~\term{a}~\term{b} \circ \function{T{\rightarrow}MS\text{-}{\equiv}{\rightarrow}{\sim}}~\term{a}~\term{b})~\term{y})~\term{x}
      \end{aligned}
    \end{equation}
    where \(\function{T{\rightarrow}MS\text{-}{\equiv}{\rightarrow}{\sim}}\) is \lemref{weak-bisim-to-eq-multiset}.
  \end{proof}
\end{lem}
\begin{lem}
  The function \(\function{T/{\sim}{\rightarrow}MS}\) is surjective \((\prod_{(\term{b} : \typeformer{MS})}, \| \Sigma_{(\term{x} : \typeformer{T})}~\function{T/{\sim}{\rightarrow}MS}~\term{x} \equiv \term{b} \|)\), assuming the axiom of choice.
  \begin{proof}
    We only need to look at the point constructors of \(\typeformer{MS}\). For the leaf case, we have the simple equality \(\function{T/{\sim}{\rightarrow}MS}~\quotientconstructor{\constructor{leaf}_{\typeformer{T}}~\term{x}} \equiv \constructor{leaf}_{\typeformer{MS}}~\term{x}\). For the node case with \(\constructor{node}~\function{f}\) then by induction, surjection of \(\quotientconstructor{{\cdot}}\) and the axiom of choice, we get \(\function{g} : \mathbb{N} \rightarrow \typeformer{T}\,\type{A}\) such that \(\prod_{(n : \mathbb{N})} \,\function{T/{\sim}{\rightarrow}MS}~\quotientconstructor{\function{g}~n} \equiv \function{f}~n\), making \(\function{T/{\sim}{\rightarrow}MS}~\quotientconstructor{\constructor{node}~\function{g}} \equiv \constructor{node}~\function{f}\).
  \end{proof}
\end{lem}
\begin{thm}
  \label{thm:QM-QIIT-eq-multiset}
  There is an equality between the types \(\typeformer{T}\,\type{A}/\relation{\sim_{T}}\) and \(\typeformer{MS}~\type{A}\), assuming the axiom of choice.
  \begin{proof}
    Since the function \(\function{T/{\sim}{\rightarrow}MS}\) is injective and surjective, it becomes an equality.
  \end{proof}
\end{thm}

\subsection{Partiality monad}
In this subsection we will define the partiality monad (see below) and show that it is equal to the delay monad quotiented by weak bisimilarity, assuming the axiom of choice. We do this proof by defining an intermediate representation of sequences, and then first showing the delay monad equal to this type (\subsectionref{delay-monad-to-sequences}), and then showing that sequences quotiented by weak are equal to the partiality monad (\subsectionref{sequences-to-partiality-monad}) \cite{Partiality-Revisited}.
\begin{defn}[Partiality Monad]
  A simple example of a quotient inductive-inductive type is the partiality monad \((-)_\bot\) over a type \(\type{R}\), defined by the constructors\\[-9mm]
  \begin{center}
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\type{R}_\bot : \universe{\mathcal{U}}}{\strut}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\bot} : \type{R}_\bot}{\strut}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\eta}~\term{a} : \type{R}_\bot}{\term{a} : \type{R}}}
      \end{equation}
    \end{minipage}
  \end{center}
  and a relation \((\cdot~\relation{\sqsubseteq_{\bot}}~\cdot)\) indexed twice over \(\type{R}_\bot\), with properties\\[-9mm]
  \begin{center}
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\bigsqcup}~(\function{s},\function{b}) : \type{R}_\bot}{\function{s} : \mathbb{N} \rightarrow \type{R}_\bot & \function{b} : \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\function{s}_{n+1} }}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{\alpha_{\bot}}~\term{p}~\term{q} : \term{x} \equiv \term{y}}{\term{x},\term{y} : \type{R}_\bot & \term{p} : \term{x}~\relation{\sqsubseteq_{\bot}}~\term{y} & \term{q} : \term{y}~\relation{\sqsubseteq_{\bot}}~\term{x}}}
      \end{equation}
    \end{minipage}
  \end{center}
  \strut\\[-15mm]
  \begin{center}
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sqsubseteq_{refl}}]{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{x}}{\term{x} : \type{R}_\bot}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.35\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sqsubseteq_{trans}}]{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{z}}{\term{x}~\relation{\sqsubseteq_{\bot}}~\term{y} & \term{y}~\relation{\sqsubseteq_{\bot}}~\term{z}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sqsubseteq_{never}}]{\constructor{\bot}~\relation{\sqsubseteq_{\bot}}~\term{x}}{\term{x} : \type{R}_\bot}}
      \end{equation}
    \end{minipage}
  \end{center}
  \strut\\[-15mm]
  \begin{center}
    \hfill
    \begin{minipage}{0.50\linewidth}
      \begin{equation}
        \vcenter{\infer{\prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\bigsqcup(\function{s},\function{b})}{\function{s} : \mathbb{N} \rightarrow \type{R}_\bot & \function{b} : \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\function{s}_{n+1} }}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\linewidth}
      \begin{equation}
        \vcenter{\infer{\bigsqcup(\function{s},\function{b})~\relation{\sqsubseteq_{\bot}}~\term{x}}{\prod_{(n:\mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\bot}}~\term{x}}}
      \end{equation}
    \end{minipage}
  \end{center}
  and finally set truncated
  \begin{equation}
    \vcenter{\infer[\constructor{(-)_\bot\text{-}isSet}]{\term{p} \equiv \term{q}}{\term{p} , \term{q} : \term{x}~\relation{\sqsubseteq_{\bot}}~\term{y}}}
  \end{equation}
\end{defn}

\subsubsection{Delay monad to Sequences}
We define sequences, and show they are equal to the delay monad (\thmref{seq-eq-delay}). We then extend this equality to an equality between the types quotient by weak bisimilarity (\thmref{delay-to-seq-quotient}). We start by defining the type of sequences.
\label{sec:delay-monad-to-sequences}
\begin{defn}
  We define
  \begin{equation}
    \typeformer{Seq}_{\type{R}} = \sum_{(\function{s} : \mathbb{N} \rightarrow \type{R} + \unit)} \function{isMon}~\function{s}
  \end{equation}
  where
  \begin{equation}
    \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} (\function{s}_n \equiv \function{s}_{n+1})  + ((\function{s}_n \equiv \mathtt{inr}~\unitelem) \times (\function{s}_{n+1} \not\equiv \mathtt{inr}~\unitelem))
  \end{equation}
  meaning a sequences is \(\mathtt{inr}~\unitelem\) until it reaches a point where it switches to \(\mathtt{inl}~\term{r}\) for some value \(\term{r}\). There are also the special cases of already terminated, meaning only \(\mathtt{inl}~\term{r}\) and never teminating meaning only \(\mathtt{inr}~\unitelem\).
\end{defn}
\noindent For each index in a sequence, the element at that index \(\function{s}_n\) is either not terminated \(\function{s}_n \equiv \mathtt{inr}~\unitelem\), which we denote as \(\function{s}_n \uparrow_{\type{R} + \unit}\), or it is terminated \(\function{s}_n \equiv \mathtt{inl}~\term{r}\) with some value \(r\), denoted by \(\function{s}_n \downarrow_{\type{R} + \unit} \term{r}\) or just \(\function{s}_n \downarrow_{\type{R} + \unit}\) to mean \(\function{s}_n \not\equiv \mathtt{inr}~\unitelem\). Thus we can write \(\function{isMon}\) as
\begin{equation}
  \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} (\function{s}_n \equiv \function{s}_{n+1})  + ((\function{s}_n \uparrow_{\type{R} + \unit}) \times (\function{s}_{n+1} \downarrow_{\type{R} + \unit}))
\end{equation}
We also introduce notation for the two special cases of sequences given above
\begin{equation}
  \function{now}_{\typeformer{Seq}}~\term{r} = (\lambda\,\_, \mathtt{inl}~\term{r}) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl})
\end{equation}
\begin{equation}
  \constant{never}_{\typeformer{Seq}} = (\lambda\,\_, \mathtt{inr}~\unitelem) , (\lambda\,\_, \mathtt{inl}~\mathtt{refl})
\end{equation}
\begin{defn}
  We can shift a sequence \((\function{s},\function{q})\) by inserting an element (and an equality) \((\term{z_s},\term{z_q})\) at \(n = 0\),
  \begin{equation}
    \function{shift}~(\function{s} , \function{q})~(\term{z_s} , \term{z_q}) = \begin{cases} \term{z_s} & n = 0 \\ \function{s}_m & n = m + 1 \end{cases} , \begin{cases} \term{z_q} & n = 0\\ \function{q}_m & n = m + 1 \end{cases},
  \end{equation}
\end{defn}
\begin{defn}
  We can unshift a sequence by removing the first element of the sequence
  \begin{equation}
    \begin{aligned}
      \function{unshift}&~(\function{s} , \function{q}) = \function{s} \circ \constructor{succ} , \function{q} \circ \constructor{succ}.
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  The function
  \begin{equation}
    \function{shift\text{-}unshift}~(\function{s},\function{q}) = \function{shift}~(\function{unshift}~(\function{s},\function{q}))~(\function{s}_0,\function{q}_0)
  \end{equation}
  is equal to the identity function.
  \begin{proof}
    Unshifting a value followed by a shift, where we reintroduce the value we just remove, gives the sequence we started  with.
  \end{proof}
\end{lem}
\begin{lem}
  The function
  \begin{equation}
    \function{unshift\text{-}shift}~(\function{s},\function{q})=\function{unshift}~(\function{shift}~(\function{s},\function{q})~\_)
  \end{equation}
  is equal to the identity function.
  \begin{proof}
    If we shift followed by an unshift, we just introduce a value to instantly remove it, meaning the value does not matter.
  \end{proof}
\end{lem}
\begin{lem}[\(\constant{inl{\not\equiv}inr}\)]
  For any two elements \(\term{x} = \mathtt{inl}~\term{a}\) and \(\term{y} = \mathtt{inr}~\term{b}\) then \(\term{x} \not\equiv \term{y}\).
  \begin{proof}
    The constructors \texttt{inl} and \texttt{inr} are disjoint, so there does not exists a path between them, meaning constructing one is a contradiction.
  \end{proof}
\end{lem}
\noindent We now define an equivalence between \(\typeformer{delay}~\type{R}\) and \(\typeformer{Seq}_{\type{R}}\), where \(\constructor{later}\) are equivalent to shifts, and \(\constructor{now}~\term{r}\) is equivalent terminated sequence with value \(\term{r}\). We do this by defining equivalence functions, and the left and right identities.
\begin{defn}
  We define a function from \(\typeformer{Delay}~\type{R}\) to \(\typeformer{Seq}_{\type{R}}\)
  \begin{equation}
    \begin{aligned}
      \function{Delay{\rightarrow}Seq}&~(\constructor{now}~\term{r}) = \function{now}_{\typeformer{Seq}}~\term{r} \\
      \function{Delay{\rightarrow}Seq}&~(\constructor{later}~\term{x}) = \\[-3mm]
      & \strut\hspace{-8mm}\function{shift}~(\function{Delay{\rightarrow}Seq}~\term{x})~\left(\mathtt{inr}~\unitelem , \begin{cases} \mathtt{inr}~(\mathtt{refl} , \constant{inl{\not\equiv}inr}) & \term{x} = \constructor{now}~\_ \\ \mathtt{inl}~\mathtt{refl} & \term{x} = \constructor{later}~\_ \end{cases}\right)
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  We define function from \(\typeformer{Seq}_{\type{R}}\) to \(\typeformer{Delay}~\type{R}\)
    \begin{equation}
      \begin{aligned}
        \function{Seq{\rightarrow}Delay}&~(\function{s} , \function{q}) = \begin{cases} \constructor{now}~\term{r} & \function{s}_0 = \mathtt{inl}~\term{r} \\ \constructor{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s} , \function{q}))) & \function{s}_0 = \mathtt{inr}~\unitelem \end{cases}
      \end{aligned}
    \end{equation}
\end{defn}
\begin{thm}
  \label{thm:seq-eq-delay}
  The type \(\typeformer{Delay}~\type{R}\) is equal to \(\typeformer{Seq}_{\type{R}}\)
  \begin{proof}  
    We define right and left identity, saying that for any sequence \((\function{s},\function{q})\), we get
    \begin{equation}
      \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{s},\function{q})) \equiv (\function{s},\function{q})
    \end{equation}
    defined by cases analysis on \(\function{s}_0\), if \(\function{s}_0 = \mathtt{inl}~\term{r}\) then we need to show
    \begin{equation}
      \function{now}_{\typeformer{Seq}}~\term{r} \equiv (\function{s},\function{q})
    \end{equation}
    This is true, since \((\function{s},\function{q})\) is a monotone sequence and \(\mathtt{inl}~\term{r}\) is the top element of the order, then all elements of the sequence are \(\mathtt{inl}~\term{r}\). If \(\function{s}_0 = \mathtt{inr}~\unitelem\) then, we need to show
    \begin{equation}
      \function{shift}~(\function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s},\function{q}))))~(\mathtt{inr}~\unitelem,\_) \equiv (\function{s},\function{q})
    \end{equation}
    by the induction hypothesis we get
    \begin{equation}
      \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{s},\function{q}))) \equiv \function{unshift}~(\function{s},\function{q})
    \end{equation}
    since shift and unshift are inverse, we get the needed equality. For the left identity, we need to show that for any delay monad \(\term{t}\) we get
    \begin{equation}
      \function{Seq{\rightarrow}Delay}~(\function{Delay{\rightarrow}Seq}~\term{t}) \equiv \term{t}
    \end{equation}
    We do case analysis on \(\term{t}\), if \(\term{t} = \constructor{now}~a\) then the equality is \(\mathtt{refl}\). If \(\term{t} = \constructor{later}~\term{x}\) then we need to show
    \begin{equation}
      \constructor{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{shift}~(\function{Delay{\rightarrow}Seq}~x)))) \equiv \constructor{later}~x
    \end{equation}
    from unshift and shift being inverse and the induction hypothesis, we get the wanted equality. We have now defined a left and right identity function, so we get the wanted equality.
  \end{proof}
\end{thm}
\begin{defn}
  We define the weak bisimulation relation for the delay monad
  \begin{center}
    \strut
    \hfill
    \begin{minipage}[h]{0.375\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sim_{now}}]{\constructor{now}~\term{a}~\relation{\sim_{Delay}}~\constructor{now}~\term{b}}{\term{a} \equiv \term{b}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}[h]{0.375\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sim_{later_l}}]{(\constructor{later}~\term{x})~\relation{\sim_{Delay}}~\term{y}}{\term{x}~\relation{\sim_{Delay}}~\term{y}}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{center}
  \begin{center}
    \strut
    \hfill
    \begin{minipage}[h]{0.375\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sim_{later_r}}]{\term{x}~\relation{\sim_{Delay}}~(\constructor{later}~\term{y})}{\term{x}~\relation{\sim_{Delay}}~\term{y}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}[h]{0.425\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sim_{later}}]{\constructor{later}~\term{x}~\relation{\sim_{Delay}}~\constructor{later}~\term{y}}{\term{x}~\relation{\sim_{Delay}}~\term{y}}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{center}
\end{defn}
\noindent We define weak bisimulation for sequences from the following definitions.
\begin{defn}[Sequence Termination]
  The following relations says that a sequence \((\function{s},\function{q}) : \typeformer{Seq}_{\type{R}}\) terminates with a given value \(\term{r} : \type{R}\),
  \begin{equation}
    (\function{s},\function{q})~\relation{\downarrow_{Seq}}~\term{r} = \sum_{(n : \mathbb{N})} \function{s}_n~\relation{\downarrow_{\type{R} + \unit}}~\term{r}.
  \end{equation}
\end{defn}
\begin{defn}[Sequence Ordering] We define an ordering of sequences as
  \begin{equation}
    (\function{s},\function{q})~\relation{\sqsubseteq_{Seq}}~(\function{t},\function{p}) = \prod_{(\term{a} : \type{R})} \left(\|\function{s}~\relation{\downarrow_{Seq}}~\term{a}\| \rightarrow \| \function{t}~\relation{\downarrow_{Seq}}~\term{a}\|\right)
  \end{equation}
  where \(\| \cdot \|\) is propositional truncation.
\end{defn}
\begin{defn} We define weak bisimilarity for sequences as
  \begin{equation}
    (\function{s},\function{q})~\relation{\sim_{Seq}}~(\function{t},\function{p}) = (\function{s},\function{q})~\relation{\sqsubseteq_{Seq}}~(\function{t},\function{p}) \times (\function{t},\function{p})~\relation{\sqsubseteq_{Seq}}~(\function{s},\function{q})
  \end{equation}
\end{defn}
\begin{thm}
  \label{thm:delay-to-seq-quotient}
  The types \(\typeformer{Delay}~\type{R}/\relation{\sim_{Delay}}\) and \(\typeformer{Seq}_{\type{R}}/\relation{\sim_{Seq}}\) are equal.
  \begin{proof}
    We show that transporting across the equality from \thmref{seq-eq-delay}, respects weak bisimilarity, starting by showing if \(\term{x}~\relation{\sim_{Delay}}~\term{y}\) then \(\function{Delay{\rightarrow}Seq}~\term{x}~\relation{\sim_{Seq}}~\function{Delay{\rightarrow}Seq}~\term{y}\), by case. If the weak bisimilarity is \(\constructor{\sim_{now}}\), then we need to construct \(\function{now}_{\typeformer{Seq}}~\term{a}~\relation{\sim_{Seq}}~\function{now}_{\typeformer{Seq}}~\term{b}\), given a path \(\pathterm{p} : \term{a} \equiv \term{b}\), since \(\relation{\sim_{Seq}}\) is reflexive, we get \(\function{now}_{\typeformer{Seq}}~\term{a}~\relation{\sim_{Seq}}~\function{now}_{\typeformer{Seq}}~\term{a}\), which gives us \(\function{now}_{\typeformer{Seq}}~\term{a}~\relation{\sim_{Seq}}~\function{now}_{\typeformer{Seq}}~\term{b}\) by transporting over \(\pathterm{p}\). If we have \(\constructor{\sim_{later_l}}\)  then by induction we get \(\function{Delay{\rightarrow}Seq}~\term{x}~\relation{\sim_{Seq}}~\function{Delay{\rightarrow}Seq}~y\), we can extend the equality by a shift, which interacts with \(\function{Delay{\rightarrow}Seq}\) to add a \(\constructor{later}\) before the argument that is we get \(\function{Delay{\rightarrow}Seq}~(\constructor{later}~\term{x})~\relation{\sim_{Seq}}~\function{Delay{\rightarrow}Seq}~y\), which is what we needed to show. By a symmetric argument we get \(\relation{\sim_{later_r}}\). To construct \(\constructor{\sim_{later}}\) we add a later to both sites of the bisimilarity.
    \begin{equation}
      \begin{aligned}
        &\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~(\constructor{\sim_{now}}~\term{a}~\term{b}~\pathterm{p}) = \mathtt{subst}~(\lambda\,\term{k},~\function{now}_{\typeformer{Seq}}~\term{a}~\relation{\sim_{Seq}}~\term{k})~\pathterm{p}~(\constructor{\sim_{refl}}~\term{a}) \\
        &\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~(\constructor{\sim_{later_l}}~\term{x}~\term{y}~\term{r}) = \function{\sim_{shift}}~(\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~\term{r}) \\
        &\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~(\constructor{\sim_{later_r}}~\term{x}~\term{y}~\term{r}) = \function{\sim_{sym}}~(\function{\sim_{shift}}~(\function{\sim_{sym}}~(\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~\term{r})) \\
        &\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~(\constructor{\sim_{later}}~\term{x}~\term{y}~\term{r}) = \function{\sim_{sym}}~(\function{\sim_{shift}}~(\function{\sim_{sym}}~(\function{\sim_{shift}}~(\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}~\term{r}))) \\
      \end{aligned}
    \end{equation}
    We show if \((\function{s},\function{q})~\relation{\sim_{Seq}}~(\function{t},\function{p})\) then \(\function{Seq{\rightarrow}Delay}~(\function{s},\function{q})~\relation{\sim_{Seq}}~\function{Seq{\rightarrow}Delay}~(\function{t},\function{p})\) by case on \(\function{s}~0\) and \(\function{t}~0\). If both are terminated meaning \(\function{s}~0 = \mathtt{inl}~\term{a}\) and \(\function{t}~0 = \mathtt{inl}~\term{b}\) then there is a \(\pathterm{p} : \term{a} \equiv \term{b}\) \todo{details?}, meaning we get \(\constructor{\sim_{now}}~\pathterm{p}\). If two sequences are weakly bisimilar, then shifting or unshifting either of them will not break the bisimilarity. We can therefore do the rest of the cases by induction. \todo{text or proof term?}
    \\ \\
    We know that if \(\function{s}~0 = \mathtt{inl}~\term{r}\), then \((\function{s},\function{q}) = \function{now}_{\mathtt{Seq}}~r\) and \((\function{s},\function{q})~\relation{\downarrow_{Seq}}~\term{r}\). If two sequences are weakly bisimilar and they terminate to different values, then the values are equal, we therefore get
    \begin{equation}
      \function{\sim_{seq\text{-}val}} : \function{now}_{\mathtt{Seq}}~\term{a}~\relation{\sim_{Seq}}~\function{now}_{\mathtt{Seq}}~\term{b} \rightarrow \term{a} \equiv \term{b}
    \end{equation}
    We can now define the function taking weakly bisimilar sequences to weakly bisimilar elements of the delay monad
    \begin{equation}
      \begin{aligned}
        &\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{now}_{\mathtt{Seq}}~\term{a})~(\function{now}_{\mathtt{Seq}}~\term{b})~\term{r} = \constructor{\sim_{now}}~\term{a}~\term{b}~(\function{\sim_{seq\text{-}val}}~\term{r}) \\[1mm]
        &\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{now}_{\mathtt{Seq}}~\term{a})~(\function{t},\function{p})~\term{r} = \\[-1mm]
        &\quad\constructor{\sim_{later_r}}~(\function{Seq{\rightarrow}Delay}~(\function{s},\function{q}))~(\function{Seq{\rightarrow}Delay}~(\function{shift}~(\function{t},\function{p})~\_))~(\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{\sim_{shift_r}}~r)) \\[1mm]
        &\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{s},\function{q})~(\function{now}_{\mathtt{Seq}}~\term{b})~\term{r} = \\[-1mm]
        &\quad\constructor{\sim_{later_l}}~(\function{Seq{\rightarrow}Delay}~(\function{shift}~(\function{s},\function{q})~\_))~(\function{Seq{\rightarrow}Delay}~(\function{t},\function{p}))~(\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{\sim_{shift_l}}~r)) \\[1mm]
        &\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{s},\function{q})~(\function{p},\function{t})~\term{r} = \\[-1mm]
        &\quad\constructor{\sim_{later}}~(\function{Seq{\rightarrow}Delay}~(\function{shift}~(\function{s},\function{q})~\_))~(\function{Seq{\rightarrow}Delay}~(\function{shift}~(\function{t},\function{p})~\_))\\[-1mm]
        &\quad\quad~(\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}~(\function{\sim_{shift}}~r))
    \end{aligned}
  \end{equation}
  Now we show the right and left identity for \(\function{{\sim}_{Delay}{\rightarrow}{\sim}_{Seq}}\) and \(\function{{\sim}_{Seq}{\rightarrow}{\sim}_{Delay}}\) \todo{Do this}
  \begin{equation}
    TODOz
  \end{equation}
  We have shown that weakly bisimilar relations for the delay monad and sequences respects the equality given in \thmref{seq-eq-delay}, meaning that the quotiented types are also equal. \todo{There is a bit more work to show this, how much into depth should I go?}
  \end{proof}
\end{thm}

\subsubsection{Sequence to Partiality Monad}
\label{sec:sequences-to-partiality-monad}
In this section we will show that assuming the axiom of choice, we get an equivalence between sequences quotiented by weak bisimilarity and the partiality monad (\thmref{sequence-partiality-monad-eq}). We start with some useful definitions.
\begin{defn} There is a function from \(\type{R} + \unit\) to the partiality monad \(\type{R}_\bot\)
  \begin{equation}
    \begin{aligned}
      &\function{Maybe{\rightarrow}(-)_\bot}~(\mathtt{inl}~\term{r}) = \constructor{\eta}~\term{r} \\
      &\function{Maybe{\rightarrow}(-)_\bot}~(\mathtt{inr}~\unitelem) = \constructor{\bot}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}[Maybe Ordering]
  \label{eq:maybe-order}
  We define an ordering relation on \(\type{R} + \unit\) as 
  \begin{equation}
    \term{x}~\relation{\sqsubseteq_{\type{R} + \unit}}~\term{y} = (\term{x} \equiv \term{y}) + ((\term{x}  \downarrow_{\type{R} + \unit}) \times (\term{y} \uparrow_{\type{R} + \unit}))
  \end{equation}
\end{defn}
\noindent This ordering definition is basically \(\function{isMon}\) at a specific index, so we can again rewrite \(\function{isMon}\) as
\begin{equation}
  \function{isMon}~\function{s} = \prod_{(n : \mathbb{N})} \function{s}_n~\relation{\sqsubseteq_{\type{R} + \unit}}~\function{s}_{n+1}
\end{equation}
This rewriting confirms that if \(\function{isMon}~\function{s}\), then \(\function{s}\) is monotone, and therefore a sequence of partial values\todo{there exists non-monotone sequences, it just follows our definition of a sequence.}.
\begin{lem}
  The function \(\function{Maybe{\rightarrow}(-)_\bot}\) is monotone, that is, if \(\term{x}~\relation{\sqsubseteq_{\type{R} + \unit}}~\term{y}\), for some \(\term{x}\) and \(\term{y}\), then \((\function{Maybe{\rightarrow}(-)_\bot}~\term{x})~\relation{\sqsubseteq_{\bot}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{y})\).
  \begin{proof}
    We do the proof by case.
    \begin{equation}
      \begin{aligned}
        &\function{Maybe{\rightarrow}(-)_\bot\text{-}mono}~(\function{inl}~\pathterm{p}) = \\[-1mm]
        &\qquad\qquad \mathtt{subst}~(\lambda\,\term{a},~\function{Maybe{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Maybe{\rightarrow}(-)_\bot}~\term{a})~\pathterm{p}~(\constructor{\sqsubseteq_{refl}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{x})) \\[1mm]
        &\function{Maybe{\rightarrow}(-)_\bot\text{-}mono}~(\function{inr}~(\pathterm{p}, \_)) = \\[-1mm]
        &\qquad\qquad \mathtt{subst}~(\lambda\,\term{a},~\function{Maybe{\rightarrow}(-)_\bot}~\term{a}~\relation{\sqsubseteq_{\bot}}~\function{Maybe{\rightarrow}(-)_\bot}~\term{y})~\sym{\pathterm{p}}~(\constructor{\sqsubseteq_{never}}~(\function{Maybe{\rightarrow}(-)_\bot}~\term{y}))
      \end{aligned}
    \end{equation}
  \end{proof}
\end{lem}
\begin{defn}
  There is a function taking a sequence to an increasing sequence of partiality monads
  \begin{equation}
      \function{Seq{\rightarrow}incSeq}~(\function{s} , \function{q}) = \function{Maybe{\rightarrow}(-)_\bot} \circ \function{s} , \function{Maybe{\rightarrow}(-)_\bot\text{-}mono} \circ \function{q}
  \end{equation}
\end{defn}
\begin{defn}
  There is a function taking a sequence to the partiality monad
  \begin{equation}
    \begin{aligned}
      &\function{Seq{\rightarrow}(-)_\bot} : \typeformer{Seq}_{\type{R}} \rightarrow \type{R}_{\bot} \\
      &\function{Seq{\rightarrow}(-)_\bot}~(\function{g},\function{q}) = \bigsqcup \circ~\function{Seq{\rightarrow}incSeq}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{lem}
  The function \(\function{Seq{\rightarrow}(-)_\bot}\) is monotone. 
  \begin{equation}
    \function{Seq{\rightarrow}(-)_\bot\text{-}mono} : (\term{x}~\term{y} : \typeformer{Seq}_{\type{R}}) \rightarrow \term{x}~\relation{\sqsubseteq_{seq}}~\term{y} \rightarrow \function{Seq{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}
\end{equation}
  \begin{proof}
    Given two sequences, where one is smaller than the another, then taking the least upper bounds of each sequence respect the ordering. \todo{should this be formalized entirely (There is alot of work here.. but not interesting.)} \todo{removed "isSet A", where is it used?}
  \end{proof}
\end{lem}
\begin{lem}
  If two sequences \(\term{x},\term{y}\) are weakly bisimular, then \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\)
  \begin{proof} We know that the \(\function{Seq{\rightarrow}(-)_{\bot}}\) is monotone, so we can use this monotonicity principle on \(p : \term{x}~\relation{\sqsubseteq_{seq}}~\term{y}\) and \(q : \term{y}~\relation{\sqsubseteq_{seq}}~\term{x}\) given by the bisimilarity, to get \(\function{Seq{\rightarrow}(-)_\bot}~\term{x}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}\) and \(\function{Seq{\rightarrow}(-)_\bot}~\term{y}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{x}\) by using \(\constructor{\alpha_{\bot}}\) we get the equality \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\). We denote this construction as the function \(\function{Seq{\rightarrow}(-)_\bot\text{-}{\approx}{\rightarrow}{\equiv}}\)
  \end{proof}
\end{lem}
\noindent The recursor for quotients \defref{quotient-recursor} allows us to lift the function \(\function{Seq{\rightarrow}(-)_\bot}\) to the quotient
\begin{defn}
  \label{eq:QuotientedSeqToPartialityMonad}
  We define a function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) from \(\typeformer{Seq}_{\type{R}}\) to \(\type{R}_{\bot}\)
  \begin{equation}
    \function{Seq/{\sim}{\rightarrow}(-)_\bot} = \function{rec}~\function{Seq{\rightarrow}(-)_\bot}~(\function{Seq{\rightarrow}(-)_\bot\text{-}{\approx}{\rightarrow}{\equiv}})~\constructor{(-)_\bot\text{-}isSet}
  \end{equation} 
\end{defn}
\begin{lem}
  \label{eq:injectivity-lemma}
  Given two sequences \(\term{s}\) and \(\term{t}\), if \(\function{Seq{\rightarrow}(-)_\bot}~\term{s} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{t}\), then \(\term{s}~\relation{\sim_{seq}}~\term{t}\).
  \begin{proof}
    We can reduce the burden of the proof, since
    \begin{equation}
      \term{s}~\relation{\sim_{seq}}~\term{t} = \left(\prod_{(\term{r} : \type{R})} \| \term{x}~\relation{\downarrow_{seq}}~\term{r} \| \rightarrow \| \term{y}~\relation{\downarrow_{seq}}~\term{r} \|\right) \times \left(\prod_{(\term{r} : \type{R})} \| \term{y}~\relation{\downarrow_{seq}}~\term{r} \| \rightarrow \| \term{x}~\relation{\downarrow_{seq}}~\term{r} \|\right)
    \end{equation}
    meaning we can show one part and get the other for free by symmetry. We assume \(\| \term{x}~\relation{\downarrow_{seq}}~\term{r} \|\), to show \(\| \term{y}~\relation{\downarrow_{seq}}~\term{r} \|\). By the mapping property of propositional truncation, we reduce the proof to defining a function \(\term{x}~\relation{\downarrow_{seq}}~\term{r} \rightarrow \term{y}~\relation{\downarrow_{seq}}~\term{r}\). Since \(\term{x}~\relation{\downarrow_{seq}}~\term{r}\), then \(\constructor{\eta}~\term{r}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{x}\), but we have assumed \(\function{Seq{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq{\rightarrow}(-)_\bot}~\term{y}\), so we get \(\constructor{\eta}~\term{r}~\relation{\sqsubseteq_{\bot}}~\function{Seq{\rightarrow}(-)_\bot}~\term{y}\), and thereby \(\term{y}~\relation{\downarrow_{seq}}~\term{r}\).
  \end{proof}
\end{lem}
\begin{lem}
  \label{lem:sequence-to-partiality-monad-injectivity}
  The function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is injective.
  \begin{proof}
    We use propositional elimination of quotients (see \defref{propositional-elimination-quotient}) to show injectivity, meaning for all \(\term{x}, \term{y} : \typeformer{Seq}_{\type{R}} / \relation{\sim_{seq}}\) we get \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{y} \rightarrow \term{x} \equiv \term{y}\). We do propositional eliminating of \(\term{x}\), followed by propositional elimination of \(y\). We use \defref{propositional-elimination-quotient}, with
    \begin{equation}
\typeformer{P} = \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{x} \equiv \function{Seq/{\sim}{\rightarrow}(-)_\bot}~\term{y} \rightarrow \term{x} \equiv \term{y}
\end{equation}
\begin{equation}
\function{P_{prop}} = \function{isProp\Pi}~(\lambda\,\_, \constructor{squash/}~\term{x}~\term{y})
\end{equation}
where we index by \(\term{x}\) for the first elimination, and by \(\term{y}\) for the second with \(\term{x} = \quotientconstructor{a}\). The proof is then completed by
    \begin{equation}
      \function{elimProp}~(\lambda\,\term{a},~\function{elimProp}~(\lambda\,\term{b},~(\constructor{eq/}~\term{a}~\term{b}) \circ (\function{Seq{\rightarrow}(-)_\bot\text{-}{\equiv}{\rightarrow}{\sim}}~\term{a}~\term{b}))~\term{y})~\term{x}
    \end{equation}
    where \(\function{Seq{\rightarrow}(-)_\bot\text{-}{\equiv}{\rightarrow}{\sim}}\) is \eqref{eq:injectivity-lemma}, 
  \end{proof}
\end{lem}
\begin{lem}
  \label{eq:constant-sequence-equality}
  For all constant sequences \(\term{s}\), where all elements have the same value \(\term{v}\), we get \(\function{Seq{\rightarrow}(-)_\bot}~\term{s} \equiv \function{Maybe{\rightarrow}(-)_\bot}~\term{v}\).
  \begin{proof}
    The left side of the equality reduces to \(\function{Maybe{\rightarrow}(-)_\bot}\) applied on the least upper bound of the constant sequence, which is exactly the right hand side of the equality.
  \end{proof}
\end{lem}
\begin{defn}[Propositional eliminator for \((-)_{\bot}\)]
  Given a dependent type \(\typeformer{P} : \type{R}_{\bot} \rightarrow \universe{\mathcal{U}}\) that is a proposition at all points \(\function{P_{prop}} : \prod_{(\term{x} : \type{R}_{\bot})} \mathtt{isProp}~(\typeformer{P}~\term{x})\), then given a proof for the base cases \(\term{P_{\bot}} : \typeformer{P}~\constructor{\bot}\) and \(\function{P_{\eta}} : \prod_{(a : \type{R})}\typeformer{P}~(\constructor{\eta}~a)\), and a proof \(\function{P_{\sqcup}}\) that for all \((\function{s},\function{q}) : \sum_{(\function{s} : \mathbb{N} \rightarrow \type{R}_{\bot})} \prod_{(n : \mathbb{N})} \function{s}\,n\,\relation{\sqsubseteq_{\bot}}\,\function{s}\,(n+1)\) we get \(\big( \prod_{(n : \mathbb{N})} \typeformer{P}~(\function{s}~n)\big) \rightarrow \typeformer{P}~\constructor{\bigsqcup} (\function{s},\function{q})\). Then we get a function from any \(\term{x} : \type{R}_{\bot}\) to \(\typeformer{P}~\term{x}\)
  \begin{equation}
    \begin{aligned}
      &\function{elimProp_{\bot}}~\constructor{\bot} = \term{P_{\bot}} \\
      &\function{elimProp_{\bot}}~(\constructor{\eta}~\term{a}) = \function{P_{\eta}}~\term{a} \\
      &\function{elimProp_{\bot}}~\constructor{\sqcup~(\function{s},\function{q})} = \term{P_{\sqcup}} (\function{s},\function{q})~(\function{elimProp_{\bot}} \circ s) \\[1mm]
      &\function{elimProp_{\bot}}~(\constructor{\alpha}~\pathterm{p}~\pathterm{q}~i) = \\
      &\quad\function{isProp{\rightarrow}isDepProp}~\function{P_{prop}}~(\function{elimProp_{\bot}}~\term{x})~(\function{elimProp_{\bot}}~\term{y})~(\constructor{\alpha}~\pathterm{p}~\pathterm{q})~i \\[1mm]
      &\function{elimProp_{\bot}}~(\constructor{\bot\text{-}isSet}~\term{x}~\term{y}~\pathterm{p}~\pathterm{q}~i~j) = \\
      &\quad\function{isSet{\rightarrow}isDepSet}~(\function{isProp{\rightarrow}isSet} \circ \function{P_{prop}})~(\function{elimProp_{\bot}}~\term{x})~(\function{elimProp_{\bot}}~\term{y}) \\
      &\quad\quad(\mathtt{ap}~\function{elimProp_{\bot}}~\pathterm{p})~(\mathtt{ap}~\function{elimProp_{\bot}}~\pathterm{q})~(\constructor{\bot\text{-}isSet}~\term{x}~\term{y}~\pathterm{p}~\pathterm{q})~i~j \\
    \end{aligned}
  \end{equation}
  where \(\term{x}\) and \(\term{y}\) in the \(\constructor{\alpha}\) case are the endpoints of the paths \(\pathterm{p}\) and \(\pathterm{q}\).
\end{defn}
\begin{lem}
  The function \(\function{Seq{\rightarrow}(-)_{\bot}}\) is surjective, assuming the axiom of choice.
  \begin{proof}
    We do the proof by using the propositional eliminator for the partiality monad, with
    \begin{equation}
      \typeformer{P} = \lambda \term{y}, \bigg\| \sum_{(\term{x} : \typeformer{Seq}_{\type{R}})} \function{Seq{\rightarrow}\bot}~\term{x} \equiv \term{y} \bigg\|
    \end{equation}
    and \(\function{P_{prop}}\) follows from the propositional truncation. For \(\constructor{\bot}\) and \(\constructor{\eta}~\term{a}\), we use \(\function{now}_{\typeformer{Seq}}~\term{a}\) and \(\constant{never}_{\typeformer{Seq}}\) respectively, and by \eqref{eq:constant-sequence-equality} we get \(\typeformer{P}~\constructor{\bot}\) and \(\typeformer{P}~(\constructor{\eta}~\term{a})\). For the least upper bound \(\constructor{\bigsqcup} (\function{s},\function{q})\), we may assume \(\prod_{(n : \mathbb{N})}~\typeformer{P}~(\function{s}~n)\) which gives us a pointwise equivalence
    \begin{equation}
    \prod_{(n : \mathbb{N})} \bigg\| \sum_{(\function{f} : \mathbb{N} \rightarrow \typeformer{Seq}_{\type{R}})} \function{Seq{\rightarrow}{\bot}}~(\function{f}~n) \equiv \function{s}~n) \bigg\|
  \end{equation}
  which by the axiom of choice becomes
  \begin{equation}
    \bigg\| \prod_{(n : \mathbb{N})} \sum_{(\function{f} : \mathbb{N} \rightarrow \typeformer{Seq}_{\type{R}})} \function{Seq{\rightarrow}{\bot}}~(\function{f}~n) \equiv \function{s}~n) \bigg\|
  \end{equation}
  Since we have a pointwise equivalence, we get an equivalence for the upper bound \todo{Should I go into more depth about pointwise equivalence?}
  \begin{equation}
    \bigg\| \sum_{(\function{x} : \typeformer{Seq}_{\type{R}})} \function{Seq{\rightarrow}{\bot}}~\term{x} \equiv {\textstyle{\bigsqcup}}(\function{s},\function{q})) \bigg\|
  \end{equation}
  Thus we have shown all the cases needed to invoke the propositional eliminator for the partiality monad, completing the proof of surjectivity.
  \end{proof}
\end{lem}
\begin{cor}
  \label{cor:sequence-partiality-monad-surjective}
  The function \(\function{Seq/{\sim}{\rightarrow}(-)_{\bot}}\) is surjective assuming the axiom of choice.
  \begin{proof}
    Since \(\function{Seq{\rightarrow}(-)_{\bot}}\) is surjective, we can map into the quotient with \(\quotientconstructor{{\cdot}}\).
  \end{proof}
\end{cor}
\begin{thm}
  \label{thm:sequence-partiality-monad-eq}
  Sequences quotiented by weak bisimilarity is equivalent to the partiality monad \(Seq_{\type{R}} / \relation{\sim_{seq}} \equiv \type{R}_{\bot}\), assuming the axiom of choice.
  \begin{proof}
 The function \(\function{Seq/{\sim}{\rightarrow}(-)_\bot}\) is injective (\lemref{sequence-to-partiality-monad-injectivity}) and surjective (\corref{sequence-partiality-monad-surjective}) assuming the axiom of choice, meaning we get an equivalence, since we are working in hSets.
\end{proof}
\end{thm}

\section{How should Q\texttt{M}-types be defined}
We want to define what a Q\texttt{M}-type means in general, we draw inspiration from Q\texttt{W}-types \cite{DBLP:Constructing-QIITs}, quotient containers \cite{DBLP:quotient-container} and quotient polynomial functors (QPF) \cite{DBLP:QM-lean}. From what we have seen as examples in the previous section, equality construction between Set Quotiented \texttt{M}-types and QIITs are given as
\begin{itemize}
\item A function \function{QM{\rightarrow}QIIT} from QM to QIIT
\item A proof \(\function{QM{\rightarrow}QIIT\text{-}{\sim}{\rightarrow}{\equiv}}\) that \(\term{x}~\relation{\sim_{QM}}~\term{y}\) implies \(\function{QM{\rightarrow}QIIT}~\term{x} \equiv \function{QM{\rightarrow}QIIT}~\term{y}\)
\item Lifting \(\function{QM{\rightarrow}QIIT}\) to \(\function{QM/{\sim}{\rightarrow}QIIT}\) using the quotient recursor with \(\function{QM{\rightarrow}QIIT\text{-}{\sim}{\rightarrow}{\equiv}}\) and \(\constructor{QIIT\text{-}isSet}\)
\item Showing injectivity by using propositional elimination of the quotient together with the inverse of \(\function{QM{\rightarrow}QIIT\text{-}{\sim}{\rightarrow}{\equiv}}\), namely \(\function{QM{\rightarrow}QIIT\text{-}injective}\) saying that \(\function{QM{\rightarrow}QIIT}~\term{x} \equiv \function{QM{\rightarrow}QIIT}~\term{y}\) implies \(\term{x}~\relation{\sim_{QM}}~\term{y}\).
\item Lastly we show surjectivity by induction using the eliminator of QIIT and the axiom of choice and the surjectivity of \(\quotientconstructor{{\cdot}}\) \cite[6.10.2]{hottbook}.
\end{itemize}

\subsection{Lifting Quotient Construction from Containers}
An alternative to directly set quotienting the \texttt{M}-types we have defined, is to do the quotienting on the underlying container \cite{DBLP:quotient-container} / polynomial functor \cite{DBLP:QM-lean}, and then do the fixed point construction we did for polynomial functors, but on the quotiented functor instead. We start by defining quotiented polynomial functors
% quotients on containers.
% \begin{defn}
%   Given a container \(\containerpair{\type{A}}{\typeformer{B}}\), and a relation \(\relation{R} : \prod_{(\term{a} : \type{A})} {\typeformer{B}~\term{a}} \rightarrow \typeformer{B}~\term{a} \rightarrow \universe{\mathcal{U}}\), \todo{...} we can form a quotiented container \(\containerpair{\type{A}}{\typeformer{B} / \relation{R}}\) as
%   \begin{equation}
    
%   \end{equation}
%   \todo{Complete definition} \todo{"The category of containers lacks good coequalisers" - \cite{DBLP:CategoryOfContainers}}
% \end{defn}
% \noindent Which gives us the following definition of a polynomial functor.
\begin{defn}
  Given a container \(\containerpair{\type{A}}{\typeformer{B}}\) and for all \(\type{X}\) a family of relations \(\relation{\sim}_{\term{a}} : (\typeformer{B}\,\term{a} \rightarrow \type{X}) \rightarrow (\typeformer{B}\,\term{a} \rightarrow \type{X}) \rightarrow \universe{\mathcal{U}}\) indexed by \(\type{A}\), we can define a quotiented polynomial functor (QPF). We define it for types as
  \begin{equation}
    \functor{F}\,\type{X} =  \sum_{\term{a} : \type{A}} ((\typeformer{B}\,\term{a} \rightarrow \type{X}) / \relation{\sim}_{\term{a}})
  \end{equation}
  and for a function \(\function{f} : \type{X} \rightarrow \type{Y}\), we use the quotient eliminator from \defref{quotient-eliminator}, with \(\typeformer{P} = \lambda\,\_, (\typeformer{B}\,\term{a} \rightarrow \type{Y})/\relation{\sim}_{\term{a}}\) which is a set \(\constructor{squash/}\), since we are using set truncated quotients. The base case \(\function{f} = \lambda\,\_,\quotientconstructor{\function{f} \circ \function{g}}\) and equality case \(\function{f_{eq}} = \lambda\,\function{x}\,\function{y}\,\term{r},~\constructor{eq/}~(\function{f} \circ \function{x})~(\function{f} \circ \function{y})~(\function{\sim_{ap}}~\function{f}~\term{r})\), where \(\function{\sim_{ap}}\) says that given \(\function{x}~\relation{\sim}_{\term{a}}~\function{y}\) and a function \(\function{f}\) then \(\function{f} \circ \function{x}~\relation{\sim}_{\term{a}}~\function{g} \circ \function{y}\). With this the definition for the quotient polynomial functor for functions is
  \begin{equation}
    \begin{aligned}
      &\functor{F}\,\function{f}~(\term{a} , \function{g}) = (\term{a} , \function{elim}~\function{g})
    \end{aligned} 
  \end{equation}
  completing the definition of a quotiented polynomial functor.
\end{defn}
\noindent If there is a function \(\function{abs}_{\type{X}} : \functor{P}\,\type{X} \rightarrow \functor{F}\,\type{X}\) that makes the diagram in \figref{QPF-diagram} commute (as in \cite{DBLP:QM-lean}), then we can construct the final \(\functor{F}\)-coalgebra, to get another notion of quotiented \texttt{M}-type.
\begin{figure}[h]
  \centering
  \begin{tikzcd}
    \functor{P}\,\type{X} \ar[r,"\functor{P}\,\function{f}"] \ar[d,"\function{abs}_{\type{X}}"'] & \functor{P}\,\type{Y} \ar[d,"\function{abs}_{\type{Y}}"] \\
    \functor{F}\,\type{X} \ar[r,"\functor{F}\,\function{f}"] & \functor{F}\,\type{Y}
  \end{tikzcd}
  \caption{Quotiented polynomial function}
  \label{fig:QPF-diagram}
\end{figure}
If \(\function{abs}\) is surjective, then the square will commute, so we just have to define a relation that has the \function{\sim_{ap}} property, and a surjective function \(\function{abs}_{\type{X}}\) to construct a quotient \texttt{M}-type. The quotiented \texttt{M}-type has a surjective function \(\function{QM\text{-}intro} : \typeformer{M}_{\container{S}} \rightarrow \typeformer{M}_{\container{S}} / \relation{\sim}\), given as \(\functor{F}^{\infty} \circ \function{abs}_{\typeformer{M}}\), where \(\functor{F}^\infty\) is the function into the limit. As an example, lets try and construct the Q\texttt{M}-type and the QPF for multisets, with this alternative approach
\begin{exmp}
  We have the following polynomial functor for \(\type{A}\)-valued \(\mathbb{N}\)-branching trees
  \begin{equation}
    \functor{P}\,\type{X} = \sum_{\term{a} : \type{A} + \unit} \begin{cases} \empt \rightarrow \type{X} & \term{a} = \mathtt{inl}~\term{r} \\ \mathbb{N} \rightarrow \type{X} & \term{a} = \mathtt{inr}~\unitelem \end{cases}
  \end{equation}
  for which we define the family of relations \((\relation{\sim_{PT}})_{(\term{a} : \type{A} + \unit)}\), if \(\term{a} = \mathtt{inl}~\term{r}\) then the equality relations is just the trivial equalities, since the relation is between elements of type \(\empt \rightarrow \type{X}\), which is contractive. On the other hand if \(\term{a} = \mathtt{inr}~\unitelem\), then we define the relation as
  \begin{equation}
    \vcenter{\infer{\function{f}~\relation{\sim_{PT}}~\function{h}}{\function{f}, \function{h} : \mathbb{N} \rightarrow \type{X} & \function{g} : \mathbb{N} \rightarrow \mathbb{N} & \function{isIso}~\function{g} & \function{f} \circ \function{g} \equiv \function{h}}}
  \end{equation}
  we can see with this approach, we only need to define the non-trival equalities, meaning those that are not just reflexivity. This relations fulfills the \(\function{\sim_{ap}}\) property, since if \(\term{a} = \mathtt{inl}~\term{r}\) then it holds trivially, and if \(\term{a} = \mathtt{inr}~\unitelem\) then we have \(f~\relation{\sim_{PT}}~h\) and want to show \(\function{k} \circ \function{f}~\relation{\sim_{PT}}~\function{k} \circ \function{h}\) for any function \(\function{k}\), which just boils down to showing \(\function{k} \circ \function{f} \circ \function{g} \equiv \function{k} \circ \function{h}\) given \(\pathterm{p} : \function{f} \circ \function{g} \equiv \function{h}\), which is done by \(\mathtt{ap}~\function{k}~\pathterm{p}\). We therefore have a QPF \(\functor{F}\). Now we want to define \(\function{abs}\),
  \begin{equation}
    \begin{aligned}
      &\function{abs}~(\mathtt{inl}~\term{r}~,~\lambda\,(\,)) = (\mathtt{inl}~\term{r}~,~\quotientconstructor{\lambda\,(\,)}) \\
      &\function{abs}~(\mathtt{inr}~\unitelem~,~\function{f}) = (\mathtt{inr}~\unitelem~,~\quotientconstructor{\function{f}})
    \end{aligned}
  \end{equation}
  and show that it is surjective, which follows directly from the surjectivity of \(\quotientconstructor{{\cdot}}\). Taking the limit we get the commuting square in \figref{QPF-limit-multiset}.
  \begin{figure}[h]
  \centering
  \begin{tikzcd}
    \typeformer{T}~\type{A} \ar[r,"\function{out}"] \ar[d,"\function{QM\text{-}intro}"'] & \functor{P}~(\typeformer{T}~\type{A}) \ar[d,"\function{abs}_{\functor{P}\,(\typeformer{T}\,\type{A})}"] \\
    \typeformer{MS}~\type{A} \ar[r,"\function{out_{QM}}"] & \functor{F}\,(\typeformer{MS}~\type{A})
  \end{tikzcd}
  \caption{QPF and limit diagram for multiset construction}
  \label{fig:QPF-limit-multiset}
\end{figure}
\end{exmp}
\noindent We have just postulated that the quotiented \texttt{M}-type, is a final \(\functor{F}\)-coalgebra, however this is not necessarily the case. When trying to proof this we need to show that given \(\function{fq} : (\typeformer{B}~\term{a} \rightarrow \type{X}) / \relation{R}\) then we can construct a function \((\typeformer{B}~\term{a} \rightarrow \type{X})\), however this requires the axiom of choice in general. We therefore does not get around the axiom of choice with this construction, however it is an alternative way of defining the quotient, and we get some more structure using it.
\\ \\
The construction of Q\texttt{W}-types in \cite{DBLP:Constructing-QIITs} got around using the axiom of choice by using QIIT, that is defining the type and the relation to quotient it by at the same time. As we have seen in the examples in this thesis, using QIITs gets around the use of the axiom of choice without adding much complexity, and if we use another construction and assume the axiom of choice, that construction will be equal to the QIIT \todo{Complete construction of Q\texttt{W} inspired Q\texttt{M}-types?}

\chapter{Conclusion}
\label{ch:conclusion}

We have described the construction of \texttt{M}-types as the limit of a sequence defined from repeated application of a polynomial functor for a container. We have showed that \texttt{M}-types are a final coalgebra, and used this to define a coinduction principle for \texttt{M}-types, giving us an equality relation from (strong) bisimulation. This work has been formalized in the cubical agda proof assistant, and part of the formalization has been accepted to the Cubical Agda github repository. We have used this formalization to construct a couple of examples of \texttt{M}-types, to make the theory of \texttt{M}-types more accessible, and given some rules for how to construct a container, that will give an \texttt{M}-type, with the wanted set of constructors/destructors. We have also explored the concept of quotiented \texttt{M}-types (Q\texttt{M}-types), and shown examples where we need the axiom of choice, to lift the constructor to the quotient. We have shown this problem can be solved by using quotient inductive-inductive types (QIITs), and shown that the type that arise from this construction is equal to the quotiented \texttt{M}-type, if we assume the axiom of choice. We show an alternative construction of Q\texttt{M}-types, where we quotient the polynomial functor before taking the limit, however this construction also encounters the same problem as quotienting the \texttt{M}-type directly, namely it needs the axiom of choice to work.

\todo[inline]{conclude on the problem statement from the introduction}

\section{Future Work}
In this work we have described \texttt{M}-types, however we have not looked at the notion of indexed \texttt{M}-types, which are coinductive types indexed by another type. \todo{cite indexed types} We hope that what is done in this thesis can be generalized to work for indexed \texttt{M}-types, but formally showing this is future work.
\\
We similarly only discussed that types defined as (coinductive) records should be equal to types defined as \texttt{M}-types, but we did not discuss how exactly to formulate this equality and proof it. One thing to do is should the construction of \texttt{M}-types equal to a construction of \texttt{M}-types as a record. This would give us the external interpretation of constructors in records, to be able to use more features of the termination checker and the likes in the Cubical Agda proof assistant.
\\ \\
When looking at Q\texttt{M}-types, we did not formalize the alternative construction of quotiented \texttt{M}-types as the limit of a quotiented polynomial functor, this should follow the same lines as the construction of M-types from polynomial functors, however it is not enough, since we need the axiom of choice for this construction. Formalizing this and comparing it to the directly quotiented version of Q\texttt{M}-types would be interesting. We would also like to get a formal description/proof of how to construct the quotient inductive-inductive types representing the quotient of a given \texttt{M}-type over a given relation.
\\ \\
We would also like to explore how these constructions behave in a guarded cubical type theory (GCTT), and whether there are any improvements to gain from using a GCTT in this regard.

\todo[inline]{Remove red text}
\textcolor{red}{
We have not proof the equality between types defined as (coinducitve) records and \texttt{M}-types.
\\ \\
All the work done here, should generalize to indexed \texttt{M}-types, which would be nice to have formalized.
\\ \\
Building the weak bisimulation on the \texttt{M}-type as a \texttt{M}-type - Is this possible? Yes! Should it be included?
\\
Define the weak bisimilarity relations as \texttt{M}-types, since these are also coindcutve types. However this seems to need something more general than "Index \texttt{M}-types"
\\ \\
We have removed the section of strong bisimulations, should it be re-added. Should the section about properties of M-types (stream) be re-added?
\\ \\
Building the Partiality Monad as a limit (Dialgebra?) - Is this possible?
\\
Cofree Coalgebra / Dialgebra -- Is this relevant? 
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}
% \todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\appendix

\chapter{The Technical Details}
≠≤≥×·÷±∓√\string~≈≅⇔¬∧∨∀∃∅∈∉⊆⊂∪∩∆ℕℤℝℂ∞Σ∑∏∫π
Part of the formalization of this work has been accepted to the Cubical Agda github in the pull request \url{https://github.com/agda/cubical/pull/245}.
\section{Examples of M-types}
\subsection{Stream}
\lstinputlisting[language=agda]{stream.agda}

\end{document}

% read / cite : QUOTIENT INDUCTIVE-INDUCTIVE TYPES (https://arxiv.org/pdf/1612.02346.pdf)
% Compare lean paper to this body of work.
% read / cite : Quotiented containers
% [Abbott et al. 2005]
% if a type theory has W-types [Abbott et al.2005], then it has allinductive types
% read / cite : Constructing Quotient Inductive-Inductive Types (https://akaposi.github.io/finitaryqiit.pdf)
% tt in tt, http://www.cs.nott.ac.uk/~psztxa/publ/tt-in-tt.pdf
% http://cs.ioc.ee/ewscs/2017/studsess/veltri-slides.pdf

% Buzz words / key words:
% generalised algebraic theory
% non-well founded set
% inductive definition (also equalities)

% read up on "synthetic" homotopy theory

% On academic writing : https://oac.cdlib.org/findaid/ark:/13030/kt287035zn/entire_text/
% Mathematical Writing (CS 209) Videorecordings (V0174). Dept. of Special Collections and University Archives, Stanford University Libraries, Stanford, Calif.
% http://askarov.net/on-writing-and-presenting.html

% https://www.cs.le.ac.uk/people/mabbott/docs/thesis.pdf
% https://arxiv.org/pdf/1504.05531.pdf
% https://www.cs.nott.ac.uk/~psztxa/publ/indexed-containers.pdf

% https://www.cs.le.ac.uk/people/mabbott/
% http://strictlypositive.org/dfordata.pdf
%https://d1wqtxts1xzle7.cloudfront.net/30914822/Roland_Backhouse_DatatypeGeneric_Programming_sc.pdf?1363044821=&response-content-disposition=inline%3B+filename%3DDatatype-generic_programming.pdf&Expires=1591636564&Signature=EJttqxfFNohkRS4fr3jC5iBTwWaR7qtFeoVhjlNZj4aUpvCRbFtQ2R0l2WGUvUdxbudM-14rs0o5ZY9HYB0gCX9k13nRQDY7MN6Zz3HDA~Y8i7kkevfmMhExeAcBf5Mbqb11rmsAUs2RLcLQuq4e-MWtoPOzNZc3CTWZLWuaYI5ZBARJR1HfWxWRlfI6ZPLb~CYNIOsWOOvWLEweY~vktw7zY5M7FuEV-dLR02VbpGUV~vJsttUl3dZ7tnSFsce-YjkgLCBxPBiKCRpXUKbNUE062IYY9zA3iKUtMo4DHzBYSqZkB02pJo8z0rBTwzzDWCkIATsi7W6OAjycZTUbWw__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA#page=219
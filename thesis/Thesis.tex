\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command
\usepackage{proof} % \infer command
\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction


\allowdisplaybreaks % allow breaks in align and equation (a new page for example) 

\usepackage{amsthm}

\theoremstyle{plain} % default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% Custom commands

\newcommand*{\lemref}[1]{Lemma~\ref{lem:#1}}
\newcommand*{\figref}[1]{Figure~\ref{fig:#1}}


\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{blue!80!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
\newcommand*{\dependenttype}[1]{\textcolor{magenta!70!black}{#1}}
\newcommand*{\container}[1]{\textcolor{red}{#1}}
\newcommand*{\containerpair}[2]{\textcolor{red}{(}#1\,\textcolor{red}{,}\,#2\textcolor{red}{)}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\relation}[1]{\textcolor{gray}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constant}[1]{\textcolor{orange!60!black}{\ensuremath{\mathtt{#1}}}}

\newcommand*{\function}[1]{\textcolor{blue!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\typeformer}[1]{\ensuremath{\mathtt{#1}}}
\newcommand*{\functor}[1]{\ensuremath{\mathbf{\mathtt{#1}}}}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

% \mathord

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
  {\Huge\sf \texttt{M}-types and Coinduction in HoTT and Cubical Type Theory}\\[2ex]
  {\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
  \noindent\rule{\linewidth}{1mm}\\[4ex]
  \noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
    \today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo[inline]{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo[inline]{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo[inline]{\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Introduction}
\label{ch:intro}

\todo[inline]{motivate and explain the problem to be addressed}

\todo[inline]{example of a citation: \cite{amin2018}}
\todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{\texttt{M}-types}
\label{ch:m-types}

\section{Containers / Signatures}
\begin{defn}
  A Container (or Signature) is a pair \(\container{S} = (\type{A},\type{B})\) of types \(\vdash \type{A} : \universe{\mathcal{U}}\) and \(\term{a} : \type{A} \vdash \dependenttype{B}(\term{a}) : \universe{\mathcal{U}}\). From a container we can define a polynomial functor, defined for objects (types) as
  \begin{equation}
    \begin{aligned}
      \functor{P}_{\container{S}} &: \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
      \functor{P}(\type{X}) := \functor{P}_{\container{S}}(\type{X}) &= \sum_{\term{a} : \type{A}} \dependenttype{B}(\term{a}) \rightarrow \type{X}
    \end{aligned}
  \end{equation}
  and for a function \(\term{f} : \type{X} \rightarrow \type{Y}\) as
  \begin{equation}
    \begin{aligned}
      \functor{P}\term{f} &: \functor{P}\type{X} \rightarrow \functor{P}\type{Y} \\
      \functor{P}\term{f}(\term{a},\term{g}) &= (a, \term{f} \circ \term{g}).
    \end{aligned}
  \end{equation}
\end{defn}
\begin{exmp}
  The type for streams over the type \(\type{A}\) is defined by the container \(\container{S} = (\type{A},\lambda\,\_, \unit)\), applying the polynomial functor we get
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X},
  \end{equation}
  since we are working in a Category with exponentials, we get \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\). Furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\), so this will be equivalent to the definition
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \type{A} \times \type{X}.
  \end{equation}
\end{exmp}
\begin{defn}
  The coalgebra for the functor \functor{P} is defined as
  \begin{equation}
    \typeformer{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow \functor{P}\type{C}.
  \end{equation}
  We denote a coalgera of \(\type{C}\) and \(\term{\gamma}\) as \(\coalg{\type{C}}{\term{\gamma}}\). The coalgebra morphisms are defined as
  \begin{equation}
    \begin{aligned}
      \cdot~\function{\Rightarrow}~\cdot &: \typeformer{Coalg}_{\container{S}} \rightarrow \typeformer{Coalg}_{\container{S}} \\
      \coalg{\type{C}}{\term{\gamma}}~\function{\Rightarrow}~\coalg{\type{D}}{\term{\delta}} &= \sum_{\term{f} : \type{C} \rightarrow \type{D}} \term{\delta} \circ \term{f} = \functor{P} \term{f} \circ \term{\gamma}
    \end{aligned}
  \end{equation}
\end{defn}
\begin{defn}
  \(\mathtt{M}\)-types can now be defined from a container \(\container{S}\) as the type \(\typeformer{M}_{\container{S}}\) such that the coalgebra for \(\typeformer{M}_{\container{S}}\) and \(\function{out} : \typeformer{M}_{\container{S}} \rightarrow \functor{P}_{\container{S}}(\typeformer{M}_{\container{S}})\) fulfills the property
  \begin{equation}
    \typeformer{Final}_{\container{S}} := \sum_{(\coalg{\type{X}}{\term{\rho}} : \mathtt{Coalg}_{\container{S}})} \prod_{(\coalg{\type{C}}{\term{\term{\gamma}}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}(\coalg{\type{C}}{\term{\gamma}} \Rightarrow \coalg{\type{X}}{\term{\rho}})
  \end{equation}
  that is \(\prod_{(\coalg{\type{C}}{\term{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}(\coalg{\type{C}}{\term{\gamma}} \Rightarrow \coalg{\typeformer{M}_{\container{S}}}{\function{out}})\). We denote this construction of the \texttt{M}-type as \(\typeformer{M}_{\containerpair{\type{A}}{\type{B}}}\) or \(\typeformer{M}_{\container{S}}\) or just \(\typeformer{M}\) when the Container is clear from the context.
\end{defn}
\begin{exmp}
  If we continue our example for streams this will give us the \(\mathtt{M}\)-type, we can see that \(\functor{P}_{\container{S}}(\typeformer{M}) = \type{A} \times \typeformer{M}\), meaning we have the following diagram,
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{A} & \type{A} \times \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \\
      & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[ul,"\function{hd}"] \ar[u,"\function{out}"'] \ar[ur,"\function{tl}"']
    \end{tikzcd}
    \caption{\texttt{M}-types of streams}
  \end{figure}
  where \(\function{out}\) is an isomorphism (because of the finality of the coalgebra), with inverse \(\function{in} : \functor{P}_{\container{S}}(\typeformer{M}) \rightarrow \typeformer{M}\). We now have a semantic for the rules we would expect for streams, if we let \(\function{cons} = \function{in}\) and \(\typeformer{stream}~\type{A} = \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\),
  \begin{equation}
    \infer[\mathtt{E}_{\function{hd}}]{\function{hd}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{E}_{\function{tl}}]{\function{tl}~\term{s} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{I}_{\function{cons}}]{\term{\function{cons}}~\term{x}~\term{xs} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \typeformer{stream}~\type{A}}
  \end{equation}  
\end{exmp}
\begin{lem} \label{lem:limit-collapse}
  Given \(\ell : \prod_{(n : \mathbb{N})} (X_{n} \rightarrow X_{n+1})\) and \(y : \sum_{x : \prod_{(n : \mathbb{N})} X_n} x_{n + 1} \equiv l_n (x_n)\) we can collapse the chain \(\mathcal{L} \equiv X_0\). We define this collapse by the equivalence
  \begin{align}
    \function{fun}_{\mathcal{L}collapse}~(x , r) &= x_0 \\
    \function{inv}_{\mathcal{L}collapse}~x_0 &= (\lambda n, \function{transport}~\ell^n~x_0) , (\lambda\,n, \mathtt{refl}_{\function{transport}~\ell^{(n+1)}~x_0}) \\
    \function{rinv}~x_0 &= \mathtt{refl}_{x_0} \\
  \end{align}
  For \(\function{linv}~(x , r)\) we define a fiber \((X , z, l)\) over \(\mathbb{N}\) given some \(z : X_0\). Then any element of the type \(\sum_{x : \prod_{(n : \mathbb{N})} X_n} x_{n + 1} \equiv l_n (x_n)\) is equal to a section over this fiber, specifically \(y\) is equal to a fiber. Since this section is defined over \(\mathbb{N}\) which is an initial algebra for the functor \(GY = \unit + Y\), we get that the section are contractible, meaning \(y \equiv \function{inv}_{\mathcal{L}collapse} (\function{fun}_{\mathcal{L}collapse}~y)\), since both are equal to such sections.
\end{lem}
\begin{thm}
  We want to proof the construction of \function{in} and \function{out} for the container \(\containerpair{A}{B}\) more precisely we want to define the equality
  \begin{equation}
    shift : \mathcal{L} \equiv P\mathcal{L}    
  \end{equation}
  where \(P\mathcal{L}\) is the limit of a shifted sequence. We do this we the two helper lemmas
  \begin{equation}
    \alpha : \mathcal{L}^P \equiv P\mathcal{L}
  \end{equation}
  \begin{equation}
    \mathcal{L}unique : \mathcal{L} \equiv \mathcal{L}^P
  \end{equation}
  We can define \(\mathcal{L}unique\) by the equivalence
  \begin{align}
    \function{fun}_{\mathcal{L}unique}~(a , b) &= \left( \lambda\,n, \begin{cases} \constant{tt} & n = 0 \\ a~m & n = m + 1 \end{cases}\right) , \left(\lambda\,n \begin{cases} \mathtt{refl}_{\constant{tt}} & n = 0 \\ b~m & n = m + 1 \end{cases}\right) \\
    \function{inv}_{\mathcal{L}unique}~(a , b) &= a \circ \function{incr} , b \circ \function{incr} \\
    \function{rinv}_{\mathcal{L}unique}~(a , b) &= \mathtt{refl} \\
    \function{linv}_{Lunique}~(a , b) &= \mathtt{refl}
  \end{align}
  The definition of \(\alpha\) follows from \lemref{limit-collapse}, 
  \begin{align}
    \mathcal{L}^P &\equiv \sum_{(u : \mathcal{L}_{(\lambda\_,A,\function{id})})} \prod_{(n : \mathbb{N})} \pi_{(n)} \circ u_{n+1} \equiv_{\lambda\,x, B(\pi_2\,a\,n\,x) \rightarrow X_n} u_n \\
        &\equiv \sum_{(a : A)} \sum_{(u : \prod_{(n : \mathbb{N})} B a \rightarrow X_n)} \prod_{(n : \mathbb{N})} \pi_{(n)} \circ u_{n+1} \equiv u_n \\
        &\equiv P\mathcal{L}
  \end{align}
  We can then define \(shift\) as
  \begin{equation}
    shift = \function{sym}~\alpha \cdot \mathcal{L}unique
  \end{equation}
  Then we define \(\function{in} = \function{transport}~shift\) and \(\function{out} = \function{transport}~(\function{sym}~shift)\), since \function{in} and \function{out} are part of an equality relation (\(shift\)), they become embeddings.
\end{thm}
\section{Closure properties of \texttt{M}-types}
We want to show that \texttt{M}-types are closed under simple operations, we start by looking at the product.
\subsection{Product of \texttt{M}-types}
We start with containers and work up to \texttt{M}-types.
\begin{defn}
  The product of two containers is defined as
  \begin{equation}
    \containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}} \equiv \containerpair{\type{A} \times \type{C}}{\lambda\,(\term{a} , \term{c}), \typeformer{B}~\term{a} \times \typeformer{D}~\term{c}}.
  \end{equation}
\end{defn}
\noindent We can lift this rule, through the diagram in \figref{container-products}, used to define \texttt{M}-types.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{A} & \type{A} \times \type{C} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \type{C} \\
    \functor{P} (\typeformer{M}_{\containerpair{\type{A}}{\type{B}}}) \ar[u,"\pi_1"'] & \functor{P}(\typeformer{M}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}) \ar[l] \ar[r] \ar[u,"\pi_1"'] & \functor{P} (\typeformer{M}_{\containerpair{\type{C}}{\type{D}}}) \ar[u,"\pi_1"'] \\
    \typeformer{M}_{\containerpair{\type{A}}{\type{B}}} \ar[u,"\function{out}"'] \ar[d,"\pi_{(!)}"] & \typeformer{M}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}} \ar[l] \ar[r] \ar[u,"\function{out}"'] \ar[d,"\pi_{(!)}"] & \typeformer{M}_{\containerpair{\type{C}}{\type{D}}} \ar[u,"\function{out}"'] \ar[d,"\pi_{(!)}"] \\
    {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^n~\unit \ar[d,"\pi_{(n)}"] & {\functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}}^n~\unit \ar[l] \ar[r] \ar[d,"\pi_{(n)}"] & {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^n~\unit \ar[d,"\pi_{(n)}"] \\
    \vdots \ar[d,"\pi_{(1)}"] & \vdots \ar[d,"\pi_{(1)}"] & \vdots \ar[d,"\pi_{(1)}"] \\
    \functor{P}_{\containerpair{\type{A}}{\type{B}}}~\unit \ar[d,"\pi_{(0)}"] & \functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}~\unit \ar[l] \ar[r] \ar[d,"\pi_{(0)}"] & \functor{P}_{\containerpair{\type{C}}{\type{D}}}~\unit \ar[d,"\pi_{(0)}"] \\
    \unit & \unit \ar[l,"\texttt{refl}"] \ar[r,"\texttt{refl}"'] & \unit
  \end{tikzcd}
  \caption{Diagram for products of chains}
  \label{fig:container-products}
\end{figure}

\begin{thm}
  For any \(n : \mathbb{N}\) the following is true
  \begin{equation}
    {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^n~\unit \times {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^n~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}}^n~\unit. \label{eq:polynomial-functor-product}
  \end{equation}
  
  \begin{proof}
    We do induction on \(n\), for \(n = 0\), we have \(\unit \times \unit \equiv \unit\). For \(n = m + 1\), we may assume
    \begin{equation}
      {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^m~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}}^m~\unit,
    \end{equation}
    in the following
    \begin{align}
      &~ {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^{m+1}~\unit \times {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^{m+1}~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\type{B}}} ({\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^m~\unit) \times \functor{P}_{\containerpair{\type{C}}{\type{D}}} ({\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} : \type{A}} \type{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^m~\unit \times \sum_{\term{c} : \type{C}} \type{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} (\type{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^m~\unit) \times (\type{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \type{B}~\term{a} \times \type{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\type{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\type{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \type{B}~\term{a} \times \type{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}}^m~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}} ({\functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}}^m~\unit) \\
      \equiv&~ {\functor{P}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}}^{m+1}~\unit
    \end{align}
  \end{proof}
  taking the limit of \eqref{eq:polynomial-functor-product} we get
  \begin{equation}
    \typeformer{M}_{\containerpair{\type{A}}{\type{B}}} \times \typeformer{M}_{\containerpair{\type{C}}{\type{D}}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\type{B}} \times \containerpair{\type{C}}{\type{D}}}.
  \end{equation}
\end{thm}
\begin{exmp} For streams we get
\begin{equation}
  \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit}} \times \typeformer{M}_{\containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit} \times \containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{stream}~(\type{A} \times \type{B}) \label{eq:zip-equality}
\end{equation}
as expected. Transporting along \eqref{eq:zip-equality} gives us a definition for \function{zip}.
\end{exmp}

\section{Co-induction Principle for \texttt{M}-types}
We can now construct a bisimulation

\begin{defn}
  Forall coalgebras \(\coalg{\type{C}}{\term{\gamma}} : \typeformer{Coalg}_{\container{S}}\), given a relation \(\relation{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\) and a type \(\type{\overline{\mathcal{R}}} = \sum_{\term{a} : \type{C}} \sum_{\term{b} : \type{C}} \term{a}~\relation{\mathcal{R}}~\term{b}\), such that \(\type{\overline{\mathcal{R}}}\) and \(\term{\alpha}_{\relation{\mathcal{R}}} : \type{\overline{\mathcal{R}}} \rightarrow \functor{P}(\type{\overline{\mathcal{R}}})\) forms a \(\functor{P}\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} : \mathtt{Coalg}_{\container{S}}\), making the diagram in \figref{coalgebra-coinduction-definition} commute (\(\Longrightarrow\) represents \(\functor{P}\)-coalgebra morphisms).  
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\type{C}}{\term{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\term{\gamma}}
    \end{tikzcd}
    \caption{Bisimulation for a coalgebra}
    \label{fig:coalgebra-coinduction-definition}
  \end{figure}
\end{defn}
\begin{defn}[Co-induction principle]
  \noindent Given a relation \(\relation{\mathcal{R}}\), that is part of a bisimulation over a final \(\functor{P}\)-coalgebra \(\coalg{\typeformer{M}}{\term{\mathtt{out}}}:\mathtt{Coalg}_{\container{S}}\) we get the diagram in \figref{final-coalgebra-coinduction},
  
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Bisimulation principle for final coalgebra}
    \label{fig:final-coalgebra-coinduction}
  \end{figure}
  \noindent where \(\pi_1^{\type{\overline{\mathcal{R}}}} = ~! = \pi_2^{\type{\overline{\mathcal{R}}}}\), which means given \(\term{r} : \term{m}~\relation{\mathcal{R}}~\term{m'}\) we get the equation
  \begin{equation}
    \term{m} = \pi_1^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \pi_2^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \term{m'}.
  \end{equation}
\end{defn}
\todo[inline]{What makes a relation a bisimulation? Is bisim and equality equal. Try to complete the construction of equality from any bisimulation relation over an \texttt{M}-type}

\section{Quotient \texttt{M}-type}
Since we know that \texttt{M}-types preserves the H-level, we can use set-truncated quotients, to define quotient \texttt{M}-types, for examples we can define weak bisimulation of the delay monad as
\todo[inline]{Quotients of the delay monad}

\section{TODO}
\begin{itemize}
\item Resumption Monad transformer
\item coinduction in Coq is broken
\item bisim \(\Rightarrow\) eq
\item copattern matching
\item cubical agda. Relation between \texttt{M}-types defined by coinduction/copattern matching and contructed from W-types
\item   In agda, coinductive types are defined using Record types, which are Sigma-types. 
\item   In cubical agda, 3.2.2 the issue of productivity is discussed. This can probably be made precise using guarded types.
\item streams defined by guarded recursion vs coinduction in guarded cubical agda. 
\item    p3 of the guarded cubical agda paper describes how semantic productivity improves over syntactic productivity
\item Reduction of co-inductive types in Coq/agda to (indexed) \texttt{M}-types. Like reduction of strictly positive inductive types to W-types. https://ncatlab.org/nlab/show/W-type
\item QIITs have been formalized in agda using private types. Can this also be done in cubical agda (ie without cheating).
\item   Show that this is the final (quotiented) coalgebra. Does this generalize to Q\texttt{M}-types, and what are those constructively ??
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Contractive}
We want to show that
\begin{align}
  &\sum_{(a : A)} \sum_{(u : \prod_{(n : \mathbb{N})} B~a \rightarrow X_n)} \prod_{(n : \mathbb{N})} \pi_{(n)} \circ (u_{n + 1}) \equiv u_n \\
  \equiv& \sum_{(a : \sum_{(a : (n : \mathbb{N}) \rightarrow A)} \prod_{(n : \mathbb{N})} a_{n+1} \equiv a_n)} \sum_{(u : (n : \mathbb{N}) \rightarrow B~(\pi_1~a)_n \rightarrow X_n)} \prod_{(n : \mathbb{N})} \pi_{(n)} \circ u_{n+1} \equiv_{(\lambda\,x, B~((\pi_2~a)_n~x)) \rightarrow X_n)} u_n
\end{align}
we have the two functions
\begin{equation}
  \function{fun}~(x , y) := ((\lambda\,n, x) , (\lambda\,n~i, x)) , y
\end{equation}
and its inverse (we use the notation \(y_{(!n)} = y_{n} \cdot y_{n-1} \cdot ~\dots~ \cdot y_1 \cdot y_0\))
\begin{equation}
  \function{inv}~((x , y) , (z , w)) := x_0 , ((\lambda\,n~a , z~n~(\mathtt{subst}~B~y_{(!n)}~a)) , (\lambda\,n~i~a, w~n~i~(\mathtt{subst}~B~?~a)))
\end{equation}

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    x , (z , w) \ar[r,"\function{fun}"] \ar[d,"\texttt{refl}"] & (\lambda\,n, x , \lambda\,n~i, x) , (z , w) \ar[d,"\function{inv}"] \\
    x , (z , w) & x , ((\lambda\,n~a, z~n~(\texttt{transport}~y_?~a)) , (\lambda\,n~i~a,w~n~i~(\texttt{transport}~?~a))) \ar[l,"refl"]
  \end{tikzcd}
  \caption{Left inverse}
  \label{fig:contractive}
\end{figure}

so we want
\begin{align}
  &~\function{invhelper0}~((\lambda\,n, (x , y) , \lambda\,n~i, (x , y)) , (z , w)) \\
  \equiv&~\lambda n, \begin{cases} \constant{tt} & n = 0 \\  \end{cases} \\
  \equiv&~z
\end{align}
\begin{equation}
  \function{invhelper1}~((\lambda\,n, (x , y) , \lambda\,n~i, (x , y)) , (z , w)) \equiv w
\end{equation}

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    (x , y) , (z , w) \ar[r,"\function{inv}"] \ar[d,"\texttt{refl}"] & x_0 , (\texttt{subst}~B~?~z , \texttt{subst}~B~?~w) \ar[d,"\function{fun}"] \\
    (x , y) , (z , w) & ((\lambda\,n,~x_0) , (\lambda\,n~i,~x_0)) , (\texttt{subst}~B~?~z , \texttt{subst}~B~?~w) \ar[l,"refl"]
  \end{tikzcd}
  \caption{Right inverse}
  \label{fig:contractive}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Examples of \texttt{M}-types}
\section{TODO: Place these subsections}
\subsection{Identity Bisimulation}
Lets start with a simple example of a bisimulation namely the one given by the identity relation for any \texttt{M}-type.
\begin{lem}
  The identity relation \((\cdot \equiv \cdot)\) is a bisimulation for any final coalgebra \(\coalg{\typeformer{M}_{\container{S}}}{\function{out}}\) defined over an \texttt{M}-type.
  
  \begin{proof}
  We first define the function
  \begin{equation}
    \begin{aligned}
      \function{\alpha}_{\equiv} &: \type{\overline{\equiv}} \rightarrow \functor{P}(\type{\overline{\equiv}}) \\
      \function{\alpha}_{\equiv} (x , y) &:= \pi_1~(\function{out}~x)~,~(\lambda\,b, (\pi_2~(\function{out}~x)~b \,,\, \texttt{refl}_{(\pi_2\,(\function{out}\,x)\,b)}))
    \end{aligned}
  \end{equation}
  and the two projections
  \begin{align}
    \pi_1^{\type{\overline{\equiv}}} &= \texttt{funExt}~\lambda\,(a,b,r), \texttt{refl}_{\function{out}\,a} \\
    \pi_2^{\type{\overline{\equiv}}} &= \texttt{funExt}~\lambda\,(a,b,r), \texttt{cong}_{\function{out}}~(\texttt{sym}~r).
  \end{align}
  This defines the bisimulation, given by the diagram in \figref{id-bisim}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\equiv}}}{\term{\alpha}_{\equiv}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\equiv}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\equiv}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Identity bisimulation}
    \label{fig:id-bisim}
  \end{figure}
\end{proof}
\end{lem}
\subsection{Bisimulation of Streams}
\todo[inline]{TODO}
\subsection{Bisimulation of Delay monad}
We want to define a bisimulation relation \(\relation{\approx_{delay}}\) for the delay monad, 
\begin{defn}
  The relation \(\relation{\approx_{delay}}\) is defined by the following rules
  \begin{equation}
    \infer[\mathtt{EqNow}]{\function{now}~\term{r}~\relation{\approx_{delay}}~\function{now}~\term{r} : \universe{\mathcal{U}}}{\type{R} : \universe{U} & \term{r} : \type{R}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{EqLater}]{\function{later}~t~\relation{\approx_{delay}}~\function{later}~u : \universe{\mathcal{U}}}{\type{R} : \universe{\mathcal{U}} & \term{t} : \typeformer{delay}~\type{R} & \term{u} : \typeformer{delay}~\type{R} & \term{t}~\relation{\approx^{\infty}_{delay}}~\term{u} : \universe{\mathcal{U}}}
  \end{equation}
  where \(\relation{\approx^{\infty}_{delay}}\) is defined as
  \begin{equation}
    \infer[\mathtt{force}]{x~\relation{\approx^{\infty}_{delay}}~y}{x~\relation{\approx_{delay}}~y}
  \end{equation}
\end{defn}
\begin{lem}
  The relation \(\relation{\approx_{delay}}\) is reflexive, meaning \(\forall\,(x : \typeformer{delay}~\type{R}), x~\relation{\approx_{delay}}~x\).
  \begin{proof}
    We do case analysis on \(x\). We start by \(x = \function{now}~r\) meaning we have to show
    \begin{equation}
      \function{now}~r~\relation{\approx_{delay}}~\function{now}~r
    \end{equation}
    which is true, by \texttt{EqNow}. For \(x = \function{later}~t\), we get
    \begin{equation}
      \function{later}~t~\relation{\approx_{delay}}~\function{later}~t
    \end{equation}
    which by \texttt{EqLater}, becomes \(t~\relation{\approx^\infty_{delay}}~t\). Meaning we must show \(\relation{\approx^\infty_{delay}}\) is reflexive, but this follows directly by \texttt{force} the induction hypothesis that \(\relation{\approx_{delay}}\) is reflexive.
  \end{proof}
\end{lem}
\begin{thm}
  The relation \(\approx_{delay}\) is a bisimulation for \(\typeformer{delay}~\type{R}\).
  \begin{proof}
    First we define the function
    \begin{equation}
      \begin{aligned}
        \function{\alpha}_{\relation{\approx_{delay}}} &: \type{\overline{\approx_{delay}}} \rightarrow \functor{P} (\type{\overline{\approx_{delay}}}) \\
        \function{\alpha}_{\relation{\approx_{delay}}} (x , y) &:= \pi_1~(\function{out}~x)~,~(\lambda\,b, (\pi_2~(\function{out}~x)~b \,,\, \texttt{refl}_{(\pi_2\,(\function{out}\,x)\,b)}))
      \end{aligned}
    \end{equation}
    then we define the projections
      \begin{align}
        \pi_1^{\type{\overline{\equiv}}} &= \texttt{funExt}~\lambda\,(a,b,r), \texttt{refl}_{\function{out}\,a} \\
        \pi_2^{\type{\overline{\equiv}}} &= \texttt{funExt}~\lambda\,(a,b,r), \texttt{cong}_{\function{out}}~(R_{eq}~r),
      \end{align}
      where
      \begin{equation}
        R_{eq}~(a , b , r) = \begin{cases} \mathtt{refl} & r = \mathtt{EqNow} \\ \mathtt{refl} & r = \mathtt{EqLater}~r' \end{cases}
      \end{equation}
  \end{proof}
\end{thm}

\subsection{Bisimulation of ITrees}
We define our bisimulation coalgebra from the strong bisimulation relation \(\mathcal{R}\), defined by the following rules.
\begin{equation}
  \infer[\mathtt{EqRet}]{\mathtt{Ret}~\term{a} \cong \mathtt{Ret}~\term{b}}{\term{a},\term{b} : \type{R} & \term{a} \equiv_{\type{R}} \term{b}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqTau}]{\mathtt{Tau}~\term{t} \cong \mathtt{Tau}~\term{u}}{\term{t},\term{u} : \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqVis}]{\mathtt{Vis}~\term{e}~\term{k_1} \cong \mathtt{Tau}~\term{e}~\term{k_2}}{\type{A} : \universe{\mathcal{U}} & \term{e} : \typeformer{E}~\type{A} & \term{k_1},\term{k_2} : \type{A} \rightarrow \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
Now we just need to define \(\term{\alpha}_{\relation{\mathcal{R}}}\) \todo{define the \(\alpha_{\relation{R}}\) function}. Now we have a bisimulation relation, which is equivalent to equality, using what we showed in the previous section.

\subsection{Zip Function}
We want the diagram in \figref{zip-computation-rules} to commute,
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    & A \times B & \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[ur,"\function{hd} \times \function{hd}"'] \ar[rr,"\function{zip}"] \ar[d,"\function{tl} \times \function{tl}"] & & \typeformer{stream}~(\type{A} \times \type{B}) \ar[ul,"\function{hd}"] \ar[d,"\function{tl}"] \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[rr,"\function{zip}"] & & \typeformer{stream}~(\type{A} \times \type{B})
  \end{tikzcd}
  \caption{TODO}
  \label{fig:zip-computation-rules}
\end{figure}
meaning we get the computation rules
\begin{equation}
  (\function{hd} \times \function{hd}) \equiv \function{hd} \circ \function{zip}
\end{equation}
\begin{equation}
  \function{zip} \circ (\function{tl} \times \function{tl}) \equiv \function{tl} \circ \function{zip}
\end{equation}
we can define the zip function as we did in the end of the last section. Another way to define the zip function is more directly, using the following lifting property of \texttt{M}-types
\begin{equation}
  \begin{aligned}
    &\function{lift_M}~\left(x : \prod_{n : \mathbb{N}} (\type{A} \rightarrow {\functor{P}_{\container{S}}}^n~\unit)\right)~\left(u : \prod_{n : \mathbb{N}} (\type{A} \rightarrow \pi_n (x_{n+1} a) \equiv x_n a)\right) (a : \type{A}) : \function{M}~\container{S} := \\
    &\qquad\qquad (\lambda\,n, x~n~a) , (\lambda\,n~i, p~n~a~i).
  \end{aligned} \label{eq:M-lift}
\end{equation}
To use this definition, we first define some helper functions
\begin{equation}
  \function{zip}_{X}~n~(x , y) = \begin{cases} \unit & \mathtt{if}~n = 0 \\ (\function{hd}~x , \function{hd}~y) , (\lambda\,\_, \function{zip}_{X}~m~(\function{tl}~x,\function{tl}~y)) , & \mathtt{if}~n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{zip}_{\pi}~n~(x , y) = \begin{cases} \function{refl} & \mathtt{if}~n = 0 \\ \lambda\,i,(\function{hd}~x , \function{hd}~y) , (\lambda\,\_, \function{zip}_{\pi}~m~(\function{tl}~x,\function{tl}~y)~i) , & \mathtt{if}~n = m + 1 \end{cases},
\end{equation}
we can then define
\begin{equation}
  \function{zip}_{lift}~(x , y) := \function{lift_M}~\function{zip}_X~\function{zip}~(x,y).
\end{equation}
\subsubsection{Equality of Zip Definitions}
We would expect that the two definitions for zip are equal
\begin{align}
  \texttt{transport}_{?}~a &\equiv \function{zip}_{lift}~a \\
                           &\equiv \function{lift_M}~\function{zip}_X~\function{zip}_\pi~(x,y) \\
                           &\equiv (\lambda\,n, \function{zip}_X~n~(x,y)) , (\lambda\,n~i, \function{zip}_\pi~n~(x,y)~i)
\end{align}
zero case \(X\)
\begin{equation}
  \function{zip}_X~0~(x,y) \equiv \unit
\end{equation}
Sucessor case \(X\)
\begin{align} 
  \function{zip}_X~(m+1)~(x,y) &\equiv (\function{hd}~x, \function{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\function{tl}~x,\function{tl}~y)) \\
                               &\equiv (\function{hd}~x, \function{hd}~y),(\lambda\,\_, {?}~(\function{tl}~a)) \\
                               &\equiv (\function{hd}~(\texttt{transport}_{?} a)),(\lambda\,\_, \texttt{transport}_{?} (\function{tl}~a)) \\
                               &\equiv \mathtt{transport}_?~a \\
\end{align}
Zero case \(\pi\): \((\lambda\,i, \function{zip}_\pi~0~(x,y)~i \equiv refl)\).
\begin{align}
  &\equiv () , (\lambda\,i, \function{zip}_\pi~0~(x,y)~i) \\
  &\equiv \unit , \function{refl} \\
\end{align}
successor case
\begin{align}
  &\equiv (\function{zip}_X~(m+1)~(x,y)) , (\lambda\,i, \function{zip}_\pi~(m+1)~(x,y)~i) \\
  &\equiv ((\function{hd}~x, \function{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\function{tl}~x,\function{tl}~y))) , (\lambda\,i, (\function{hd}~x, \function{hd}~y),(\lambda\,\_,\function{zip}_\pi~m~(\function{tl}~x,\function{tl}~y)~i))
\end{align}
\todo[inline]{Complete this proof}

\subsection{Examples of Fixed Points}
\subsubsection{Zeros}
Let us try to define the zero stream, we do this by lifting the functions
\begin{equation}
  \function{const_X}~(n : \type{\mathbb{N}})~(c : \type{\mathbb{N}})  := \begin{cases} \unit & n = 0 \\ (c , \lambda\,\_, \function{const_X}~m~c) & n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{const_\pi}~(n : \type{\mathbb{N}})~(c : \type{\mathbb{N}}) := \begin{cases} \mathtt{refl} & n = 0 \\ \lambda\,i,(c , \lambda\,\_, \function{const_\pi}~m~c~i) & n = m + 1 \end{cases}
\end{equation}
to get the definition of zero stream
\begin{equation}
  \mathtt{zeros} := \function{lift_M}~\function{const_X}~\function{const_\pi}~0.
\end{equation}
We want to show that we get the expected properties, such as
\begin{align}
  \function{hd}~\mathtt{zeros} &\equiv 0 \\
  \function{tl}~\mathtt{zeros} &\equiv \mathtt{zeros}
\end{align}

\subsubsection{Spin}
We want to define spin, as being the fixed point \(\mathtt{spin} = \mathtt{later}~\mathtt{spin}\), so that is again a final coalgebra, but of a \texttt{M}-type (which is a final coalgebra)

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \function{spin} \ar[d,"\function{later}"] \\
    \function{later}~\function{spin}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Since it is final, it also must be unique, meaning that there is just one program that spins forever, without returning a value, meaning every other program must return a value. If we just

\section{Stream Formalization using \texttt{M}-types}
As described earlier, given a type \(\type{A}\) we define the stream of that type as
\begin{equation}
  \typeformer{stream}~\type{A} := \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}
\end{equation}
When taking the head of a stream, we get
\begin{align}
  \function{hd}~(\function{cons}~x~xs) &\equiv \pi_1~\function{out}~(\function{cons}~x~xs) \\
                                       &\equiv \pi_1~\function{out}~(\function{in}~(x , \lambda\,\_,xs)) \\
                                       &\equiv \pi_1~(x , \lambda\,\_,xs) \\
                                       &\equiv x
\end{align}
and similarly for the tail of the stream
\begin{align}
  \function{tl}~(\function{cons}~x~xs) &\equiv \pi_2~\function{out}~(\function{cons}~x~xs) \\
                                       &\equiv \pi_2~\function{out}~(\function{in}~(x , \lambda\,\_,xs)) \\
                                       &\equiv \pi_2~(x , \lambda\,\_,xs) \\
                                       &\equiv xs
\end{align}
and the other direction is also true
\begin{align}
  \function{cons}(\function{hd}~s , \function{tl}~s) &\equiv \function{in}~(\function{hd}~s , \function{tl}~s) \\
                                                     &\equiv \function{in}~(\pi_1~(\function{out}~s) , \pi_2~(\function{out}~s)) \\
                                                     &\equiv \function{in}~(\function{out}~s) \\
                                                     &\equiv s.
\end{align}
When forming elements of the \texttt{M}-type, we want to do it by lifting it though the definition of the \texttt{M}-type, meaning we want to define a function \(\function{cons'} : (\type{\mathbb{N}} \rightarrow \type{A}) \rightarrow \typeformer{stream}~\type{A}\) as
\begin{equation}
  \function{cons'} f = \function{lift_M}~(\lambda\,c\,n, f~c)
\end{equation}
\begin{equation}
  \function{cons'} f = \function{lift_M}~(\lambda\,c\,n, f~c)
\end{equation}

\section{ITrees as \texttt{M}-types}
We want the following rules for ITrees
\begin{equation}
  \infer[\mathtt{I}_{\function{Ret}}]{\function{Ret}~\term{r} : \typeformer{itree}~\typeformer{E}~\type{R}}{r : \type{R}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_{\function{Vis}}]{\function{Vis}~\term{a}~\term{f} : \typeformer{itree}~\typeformer{E}~\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \typeformer{E}~\type{A} & \term{f} : \type{A} \rightarrow \typeformer{itree}~\typeformer{E}~\type{R}}.
\end{equation}
Elimination rules
\begin{equation}
  \infer[\mathtt{E}_{\function{Tau}}]{\function{Tau}~\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}{\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}.
\end{equation}

\subsection{Delay Monad}
We start by looking at itrees without the \(\function{Vis}\) constructor, this type is also know as the delay monad\todo{check this statement}. We construct this type by letting \(\container{S} = (\unit + \type{R},\lambda \{ \texttt{inl}~\_ \rightarrow \unit~;~\texttt{inr}~\_ \rightarrow \empt \})\), we then get the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{x} : \unit + \type{R}} \lambda \{ \texttt{inl}~\_ \rightarrow \unit ; \texttt{inr}~\_ \rightarrow \empt\}~\term{x} \rightarrow \type{X},
\end{equation}
which is equal to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R} \times (\empt \rightarrow \type{X}).
\end{equation}
We know that \(\empt \rightarrow \type{X} \equiv \unit\), so we can reduce further to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R}
\end{equation}
meaning we get the following diagram.

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\function{now}"'] \ar[r,"\texttt{inl}"] & \type{R} + \typeformer{M}  & \typeformer{M} \ar[l,"\texttt{inr}"'] \ar[dl,"\function{later}"] \\
    & \typeformer{M} \ar[u,"\function{out}"']
  \end{tikzcd}
  \caption{Delay monad}
\end{figure}
\noindent Meaning we can define the operations \(\function{now}\) and \(\function{later}\) using \(\function{in} = \function{out}^{-1}\) together with the injections \(\mathtt{inl}\) and \(\mathtt{inr}\). \todo{(Later = Tau, Ret = Now)}

\subsection{Tree}
Now lets look at the example where we remove the \(\function{Tau}\) constructor. We let
\begin{equation}
  \container{S} = \left(\type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A}~,~\lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \} \right).
\end{equation}
This will give us the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{x} : \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A}} \lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \}~\term{x} \rightarrow \type{X},
\end{equation}
which simplifies to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X})),
\end{equation}
and further
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X}).
\end{equation}
We get the following diagram for the \(\functor{P}\)-coalgebra.

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\function{Ret}"'] \ar[r,"\texttt{inl}"] & \type{R} + \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})  & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[l,"\texttt{inr}"'] \ar[dl,"\function{Vis}"] \\
    & \typeformer{M} \ar[u,"\function{out}"]
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Again we can define \(\function{Ret}\) and \(\function{Vis}\) using the \(\function{in}\) function.

\subsection{ITrees}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types. We define ITrees by the container
\begin{equation}
  \container{S} = \left( \unit+\type{R}+\sum_{\type{A}:\universe{\mathcal{U}}} (\typeformer{E}~\type{A}) ~~,~~ \lambda\left\{ \texttt{inl}~(\texttt{inl}~\_) \rightarrow \unit ~;~ \texttt{inl}~(\texttt{inr}~\_) \rightarrow \empt ~;~ \texttt{inr} (\type{A},\_)  \rightarrow \type{A} \right\} \right).
\end{equation}
Such that the (reduced) polynomial functor becomes
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} ((\typeformer{E}~\type{A}) \times (\type{A} \rightarrow \type{X}))
\end{equation}
Giving us the diagram
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[ddrr,"\function{Ret}"'] \ar[r,"\texttt{inl}\,\circ\,\texttt{inr}"] & \typeformer{M} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} (\typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})) & & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[ll,"\texttt{inr}"'] \ar[ddl,"\function{Vis}"] \\
    & & \typeformer{M} \ar[ul,"\texttt{inl}\,\circ\,\texttt{inl}"'] \ar[d,"\function{Tau}"'] \\
    & & \typeformer{M} \ar[uul,"\function{out}"]
  \end{tikzcd}
  \caption{TODO}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Additions to the Cubical Agda Library}
\section{\(\function{\Sigma ap}\)}
\begin{equation}
  \function{\Sigma ap} : \left(\sum_{x : X} Y x \equiv \sum_{x' : X'} Y' x' \right) ~ \equiv ~ \left( \sum_{p : X \equiv X'} Y \equiv_p Y' \right)
\end{equation}
\todo[inline]{Describe the proof of this? / Is this relevant / Should it be in the appendix?}

\chapter{Conclusion}
\label{ch:conclusion}

\todo[inline]{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo[inline]{\dots}

\end{document}


\documentclass[twoside,11pt,openright]{report}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage[hidelinks]{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\usepackage{marvosym}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Custom packages added:

\usepackage{fullpage}
\setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command
\usepackage{proof} % \infer command
\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction

% allow breaks in align and equation (a new page for example) 
\allowdisplaybreaks

\usepackage{amsthm}

\theoremstyle{plain} % default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section] 
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% Custom commands

\newcommand*{\lemref}[1]{Lemma~\ref{lem:#1}}
\newcommand*{\figref}[1]{Figure~\ref{fig:#1}}

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{green!30!black}{#1}} % \textcolor{green!70!black} \textcolor{blue!80!black}
\newcommand*{\pathterm}[1]{\textcolor{green!40!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
% \newcommand*{\dependenttype}[1]{\textcolor{magenta!70!black}{#1}}
\newcommand*{\container}[1]{\textcolor{red}{#1}}
\newcommand*{\containerpair}[2]{\textcolor{red}{(}#1\,\textcolor{red}{,}\,#2\textcolor{red}{)}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\relation}[1]{\textcolor{gray}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constant}[1]{\textcolor{orange!60!black}{\ensuremath{\mathtt{#1}}}}

\newcommand*{\function}[1]{\textcolor{blue!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\typeformer}[1]{\ensuremath{\mathtt{#1}}}
\newcommand*{\functor}[1]{\ensuremath{\mathbf{\mathtt{#1}}}}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

% Concatenation of paths taken from HoTT book
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\newcommand*{\sym}[1]{\ensuremath{#1^{-1}}}

% \mathord

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
  {\Huge\sf \texttt{M}-types and Coinduction in HoTT and Cubical Type Theory}\\[2ex]
  {\huge\sf Lasse Letager Hansen, 201912345}\\[2ex]
  \noindent\rule{\linewidth}{1mm}\\[4ex]
  \noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
    \today \\[1ex] Advisor: Bas Spitters\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo[inline]{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo[inline]{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo[inline]{\dots}

\vspace{2ex}
c\begin{flushright}
  \emph{Lasse Letager Hansen,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Introduction} % Everyone interested should be able to read this!
\label{ch:intro}
This work tries to formalize co-inductive types in the setting of homotopy type theory.

\todo[inline]{motivate and explain the problem to be addressed}

\todo[inline]{example of a citation:~\cite{amin2018}}
\todo[inline]{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Notation}
We use the following notation / font:
\begin{itemize}
\item Universe \(\universe{\mathcal{U}}_i\) or \(\universe{\mathcal{U}}\)
\item Type \(\type{A} : \universe{\mathcal{U}}\)
\item A type former or dependent type \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\)
\item A term \(\term{x} : \type{A}\) or for constants \(\constant{c} : \type{A}\)
\item A function \(\function{f} : \type{A} \rightarrow \type{C}\)
\item A path \(\pathterm{p} : \type{A} \equiv \type{C}\), heterogeneous paths are denotes \(\equiv_p\) or if the path is clear from context \(\equiv_*\).
\item A relation \(\relation{R} : \type{A} \rightarrow \type{A} \rightarrow \universe{\mathcal{U}}\) with notation \(\term{x}~\relation{R}~\term{y}\).
\item The unit type is \(\unit\) while the empty type is \(\empt\).
\item A functor \(\functor{P}\)
\item A container is denoted as \(\container{S}\) or \(\containerpair{\type{A}}{\typeformer{B}}\)
\item A coalgebra \(\coalg{\type{C}}{\function{\gamma}}\)
\item We denote the function giving the first and second projection of a dependent pair by \(\pi_1\) and \(\pi_2\).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Background Theory}
\section{Coinduction}
Coinduction is the dual concept (in a categorical manner) of induction. The induction principle is an equivalence principle for congruent elements in an initial algebra.

\section{Homotopy Type Theory (HoTT)}
Homotopy type theory 
\subsection{The HoTT Book}

\section{Cubical Type Theory}

\section{Cubical Agda}
\todo[inline]{Axioms of cubical Agda}
The theory of cubical Agda is a Cartesian closed category, meaning get exponentials.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{\texttt{M}-types}
\label{ch:m-types}
\section{Containers / Signatures}
In this section we will introduce containers (also known as signatures), and show how to use these to construct a coalgebra. 
\begin{defn}
  A Container (or signature) is a dependent pair \(\container{S} = (\type{A},\typeformer{B})\) for the types \(\type{A} : \universe{\mathcal{U}}\) and \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\).
\end{defn}
\noindent From a container we can define a polynomial functor.
\begin{defn}
  A polynomial functor is defined for objects (types) as
  \begin{equation}
    \begin{aligned}
      \functor{P}_{\container{S}} &: \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
      \functor{P}(\type{X}) := \functor{P}_{\container{S}}(\type{X}) &= \sum_{\term{a} : \type{A}} \typeformer{B}(\term{a}) \rightarrow \type{X}
    \end{aligned}
  \end{equation}
  and for a function \(\function{f} : \type{X} \rightarrow \type{Y}\) as
  \begin{equation}
    \begin{aligned}
      \functor{P}\function{f} &: \functor{P}\type{X} \rightarrow \functor{P}\type{Y} \\
      \functor{P}\function{f}(\term{a},\function{g}) &= (\term{a}, \function{f} \circ \function{g}).
    \end{aligned}
  \end{equation}
\end{defn}
\noindent Using these definitions we can now define the polynomial functor used to construct the type of streams.
\begin{exmp}
  The type for streams over the type \(\type{A}\) is defined by the container \(\container{S} = (\type{A},\lambda\,\_, \unit)\), applying the polynomial functor for the container \(\container{S}\), we get
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{a} : \type{A}} \unit \rightarrow \type{X}.
  \end{equation}
  Since we are working in a Category with exponentials, we get \(\unit \rightarrow \type{X} \equiv \type{X}^{\unit} \equiv \type{X}\). Furthermore \(\unit\) and \(\type{X}\) does not depend on \(\type{A}\), so this will be equivalent to the definition
  \begin{equation}
    \functor{P}_{\container{S}}(\type{X}) = \type{A} \times \type{X}.
  \end{equation}
\end{exmp}
\noindent We now construct the \(\functor{P}\)-coalgebra for a polynomial functor \(\functor{P}\).
\begin{defn}
  A \(\functor{P}\)-coalgebra is defined as
  \begin{equation}
    \typeformer{Coalg}_{\container{S}} = \sum_{\type{C} : \universe{\mathcal{U}}} \type{C} \rightarrow \functor{P}\type{C}.
  \end{equation}
  We denote a \(\functor{P}\)-coalgebra give by \(\type{C}\) and \(\function{\gamma}\) as \(\coalg{\type{C}}{\function{\gamma}}\). The coalgebra morphisms are defined as
  \begin{equation}
    \begin{aligned}
      \cdot \Rightarrow ~\cdot &: \typeformer{Coalg}_{\container{S}} \rightarrow \typeformer{Coalg}_{\container{S}} \\
      \coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{D}}{\function{\delta}} &= \sum_{\function{f} : \type{C} \rightarrow \type{D}} \function{\delta} \circ \function{f} = \functor{P} \function{f} \circ \function{\gamma}
    \end{aligned}
  \end{equation}
\end{defn}
\noindent We can now define \texttt{M}-types.
\begin{defn}
  Given a container \(\container{S}\), we define \(\mathtt{M}\)-types, as the type \(\typeformer{M}_{\container{S}}\), making the coalgebra given by \(\typeformer{M}_{\container{S}}\) and \(\function{out} : \typeformer{M}_{\container{S}} \rightarrow \functor{P}_{\container{S}}(\typeformer{M}_{\container{S}})\) fulfill the property
  \begin{equation}
    \typeformer{Final}_{\container{S}} := \sum_{(\coalg{\type{X}}{\function{\rho}} : \mathtt{Coalg}_{\container{S}})} \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{X}}{\function{\rho}}).
  \end{equation}
  That is \(\prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\typeformer{M}_{\container{S}}}{\function{out}})\). We denote the \texttt{M}-type as \(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}\) or \(\typeformer{M}_{\container{S}}\) or just \(\typeformer{M}\) when the Container is clear from the context.
\end{defn}
\noindent Continuing our example we now construct an \(\mathtt{M}\)-type for streams.
\begin{exmp} Given the polynomial functor \(\functor{P}_{\containerpair{\type{A}}{\lambda\,\_,\unit}} \typeformer{M} = \type{A} \times \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\) for streams, we get the diagram in \figref{stream-M-type},
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{A} & \type{A} \times \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \\
      & \typeformer{M}_{\containerpair{A}{\lambda\,\_,\unit}} \ar[ul,"\function{hd}"] \ar[u,"\function{out}"'] \ar[ur,"\function{tl}"']
    \end{tikzcd}
    \caption{\texttt{M}-types of streams}
    \label{fig:stream-M-type}
  \end{figure}
  where \(\function{out}\) is an isomorphism (because of the finality of the coalgebra), with inverse \(\function{in} : \functor{P}_{\container{S}}(\typeformer{M}) \rightarrow \typeformer{M}\). We now have a semantic for the rules, we would expect for streams, if we let \(\function{cons} = \function{in}\) and \(\typeformer{stream}~\type{A} = \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}\),
  \begin{equation}
    \infer[\mathtt{E}_{\function{hd}}]{\function{hd}~\term{s} : \type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{E}_{\function{tl}}]{\function{tl}~\term{s} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{s} : \typeformer{stream}~\type{A}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{I}_{\function{cons}}]{\term{\function{cons}}~\term{x}~\term{xs} : \typeformer{stream}~\type{A}}{\type{A} : \universe{\mathcal{U}} & \term{x} : \type{A} & \term{xs} : \typeformer{stream}~\type{A}}
  \end{equation}
  or more precisely \(\function{hd} = \pi_1 \circ \function{out}\) and \(\function{tl} = \pi_2 \circ \function{out}\).
\end{exmp}
\begin{defn}
  Chains are defined as ... \todo[inline]{define chains, \(\function{\pi}_{(n)}\) and \(\type{X}_n\)}
\end{defn}
\begin{lem}\label{lem:function-to-M-type-is-cone}
  For all coalgebras \(\coalg{\type{C}}{\function{\gamma}}\) for the container \(\container{S}\), we get \(\type{C} \rightarrow \typeformer{M}_{\container{S}} \equiv \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\), where \(\typeformer{Cone} = \sum_{(\function{f} : \prod_{(n : \type{\mathbb{N}})} \type{C} \rightarrow \type{X}_n)} \prod_{(n : \type{\mathbb{N}})} \function{\pi}_{(n)} \circ (\function{f}_{(n+1)}) \equiv f_n\)
  \begin{proof}
      %lemma10-Iso : ∀ {ℓ} {S : Container {ℓ}} {C,γ : Coalg₀ {S = S}} -> Iso (C,γ .fst -> M S) (Cone C,γ)
  %fun (lemma10-Iso) f = (λ n z → projection n (f z)) , λ n i a → β n (f a) i
  %inv (lemma10-Iso) (u , q) z = (λ n → u n z) , (λ n → funExt⁻ (q n) z)
  %rightInv (lemma10-Iso) = refl-fun
  %leftInv (lemma10-Iso) = refl-fun
    \todo[inline]{Complete proof}
  \end{proof}
\end{lem}
\begin{lem}\label{lem:limit-collapse}
  Given \(\function{\ell} : \prod_{(n : \type{\mathbb{N}})} (\type{X}_{n} \rightarrow \type{X}_{n+1})\) and \(\term{y} : \sum_{\left(\term{x} : \prod_{(n : \type{\mathbb{N}})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \term{l}_n~\term{x}_n\) the chain collapses as the equality \(\type{\mathcal{L}} \equiv \type{X}_0\).
  \begin{proof}
    We define this collapse by the equivalence
    \begin{align}
      \function{fun}_{\mathcal{L}collapse}~(\term{x} , \pathterm{r}) &= \term{x}_0 \\
      \function{inv}_{\mathcal{L}collapse}~\term{x}_0 &= (\lambda\,n,~\function{\ell}^n~\term{x}_0)~,~(\lambda\,n,~\mathtt{refl}_{(\function{\ell}^{(n+1)}\,\term{x}_0)}) \\
      \function{rinv}~\term{x}_0 &= \mathtt{refl}_{\term{x}_0}
    \end{align}
    where \(\function{\ell}^n = \function{\ell}_n \circ \function{\ell}_{n-1} \circ \dots \circ \function{\ell}_1 \circ \function{\ell}_0\). To define \(\function{linv}~(\term{x} , \pathterm{r})\), we first define a fiber \((\type{X} , \term{z}, \function{\ell})\) over \(\type{\mathbb{N}}\) given some \(\term{z} : \type{X}_0\). Then any element of the type \(\sum_{\left(\term{x} : \prod_{(n : \type{\mathbb{N}})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) is equal to a section over the fiber we defined. This means \(\term{y}\) is equal to a section. Since the sections are defined over \(\type{\mathbb{N}}\), which is an initial algebra for the functor \(\functor{G}\type{Y} = \unit + \type{Y}\), we get that sections are contractible, meaning \(\term{y} \equiv \function{inv}_{\mathcal{L}collapse} (\function{fun}_{\mathcal{L}collapse}~\term{y})\), since both are equal to sections over \(\type{\mathbb{N}}\).
\end{proof}
\end{lem}
\noindent We can now define the construction of \function{in} and \function{out}.
\begin{thm}
   Given the container \(\containerpair{\type{A}}{\typeformer{B}}\) we define the equality
  \begin{equation}
    \pathterm{shift} : \type{\mathcal{L}} \equiv \functor{P}\type{\mathcal{L}}
  \end{equation}
  where \(\functor{P}\type{\mathcal{L}}\) is the limit of a shifted sequence. Then
  \begin{equation}
    \function{in} = \mathtt{transport}~\pathterm{shift}
  \end{equation}
  \begin{equation}
    \function{out} = \mathtt{transport}~(\sym{\pathterm{shift}}).
  \end{equation}
  \begin{proof}
    The proof is done using the two helper lemmas
    \begin{equation}
      \pathterm{\alpha} : \type{\mathcal{L}}^{\functor{P}} \equiv \functor{P}\type{\mathcal{L}}
    \end{equation}
    \begin{equation}
      \pathterm{\mathcal{L}unique} : \type{\mathcal{L}} \equiv \type{\mathcal{L}}^{\functor{P}}
    \end{equation}
    We define \(\pathterm{\mathcal{L}unique}\) by the equivalence
    \begin{align}
      \function{fun}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \left( \lambda\,n, \begin{cases} \constant{tt} & n = 0 \\ \function{a}~m & n = m + 1 \end{cases}\right) , \left(\lambda\,n \begin{cases} \mathtt{refl}_{\constant{tt}} & n = 0 \\ \function{b}~m & n = m + 1 \end{cases}\right) \\
    \function{inv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \function{a} \circ \function{incr}~,~b \circ \function{incr} \\
    \function{rinv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})} \\
    \function{linv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})}
    \end{align}
    The definition of \(\pathterm{\alpha}\) is then, 
    \begin{align}
      \type{\mathcal{L}}^{\functor{P}} &\equiv \sum_{(\term{x} : \prod_{(n : \type{\mathbb{N}})} \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{X}_n)} \prod_{(n : \type{\mathbb{N}})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \\
      &\equiv \sum_{(\term{x} : \sum_{(\term{a} : \prod_{(n : \type{\mathbb{N}})} \type{A})} \prod_{(n : \type{\mathbb{N}})} \term{a}_{n+1} \equiv \term{a}_n)} \sum_{(\function{u} : \prod_{(n : \type{\mathbb{N}})} \typeformer{B}\,{(\pi_1\,\term{x})}_n \rightarrow \type{X}_n)} \prod_{(n : \type{\mathbb{N}})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv_* \function{u}_n \label{eq:alpha-unfold} \\
      &\equiv \sum_{(\term{a} : \type{A})} \sum_{(\function{u} : \prod_{(n : \type{\mathbb{N}})} \typeformer{B}\,a \rightarrow \type{X}_n)} \prod_{(n : \type{\mathbb{N}})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n \label{eq:alpha-limit-collapse} \\
      &\equiv \sum_{\term{a} : \type{A}} \typeformer{B}~\term{a} \rightarrow \type{\mathcal{L}} \label{eq:alpha-cone}\\
      &\equiv \functor{P}\type{\mathcal{L}}
    \end{align}
    To collapse \(\sum_{(\term{a} : \prod_{(n : \type{\mathbb{N}})} \type{A})} \prod_{(n : \type{\mathbb{N}})} \term{a}_{n+1} \equiv \term{a}_n\) to \(\type{A}\) between \eqref{eq:alpha-unfold} and \eqref{eq:alpha-limit-collapse} we use \lemref{limit-collapse} . We use \lemref{function-to-M-type-is-cone} for the equality between \eqref{eq:alpha-limit-collapse} and \eqref{eq:alpha-cone}. The rest of the equalities are given by a simple isomorphism or by definition. The definition of \(\pathterm{shift}\) is
    \begin{equation}
      \pathterm{shift} = \sym{\pathterm{\alpha}} \ct \pathterm{\mathcal{L}unique}.
    \end{equation}
    We furthermore get the definitions \(\function{in} = \mathtt{transport}~\pathterm{shift}\) and \(\function{out} = \mathtt{transport}~(\sym{\pathterm{shift}})\), since \function{in} and \function{out} are part of an equality relation (\(\pathterm{shift}\)), they are both surjective and embeddings.
    \end{proof}
\end{thm}

\section{Coinduction Principle for \texttt{M}-types}
We can now construct a coinduction principle given a bisimulation relation
% Let (S;  S) and (T;  T) be F-systems. A subsetRSTof the Cartesianproduct ofSandTis called anF-bisimulationbetweenSandTif there exists anF-transition structureR:R!F(R) such that the projections fromRtoSandTareF-homomorphisms

\begin{defn}
  For all coalgebras \(\coalg{\type{C}}{\term{\gamma}} : \typeformer{Coalg}_{\container{S}}\), given a relation \(\relation{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\) and a type \(\type{\overline{\mathcal{R}}} = \sum_{\term{a} : \type{C}} \sum_{\term{b} : \type{C}} \term{a}~\relation{\mathcal{R}}~\term{b}\), such that \(\type{\overline{\mathcal{R}}}\) and \(\term{\alpha}_{\relation{\mathcal{R}}} : \type{\overline{\mathcal{R}}} \rightarrow \functor{P}(\type{\overline{\mathcal{R}}})\) forms a \(\functor{P}\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} : \mathtt{Coalg}_{\container{S}}\), making the diagram in \figref{coalgebra-coinduction-definition} commute (\(\Longrightarrow\) represents \(\functor{P}\)-coalgebra morphisms).  
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\type{C}}{\term{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\term{\gamma}}
    \end{tikzcd}
    \caption{Bisimulation for a coalgebra}
    \label{fig:coalgebra-coinduction-definition}
  \end{figure}
\end{defn}
\begin{defn}[Coinduction principle]
  \noindent Given a relation \(\relation{\mathcal{R}}\), that is part of a bisimulation over a final \(\functor{P}\)-coalgebra \(\coalg{\typeformer{M}}{\term{\mathtt{out}}}:\mathtt{Coalg}_{\container{S}}\) we get the diagram in \figref{final-coalgebra-coinduction},
  
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\mathcal{R}}}}{\term{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Bisimulation principle for final coalgebra}
    \label{fig:final-coalgebra-coinduction}
  \end{figure}
  \noindent where \(\pi_1^{\type{\overline{\mathcal{R}}}} = ~! = \pi_2^{\type{\overline{\mathcal{R}}}}\), which means given \(\term{r} : \term{m}~\relation{\mathcal{R}}~\term{m'}\) we get the equation
  \begin{equation}
    \term{m} = \pi_1^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \pi_2^{\type{\overline{\mathcal{R}}}} (\term{m}, \term{m'}, \term{r}) = \term{m'}.
  \end{equation}
\end{defn}

\section{Quotient \texttt{M}-type}
We want to construct a quotient \texttt{M}-type, and we know that \texttt{M}-types are an algebraic theory? Meaning we want to define quotient algebra...

We want to construct a quotiented M type, which is given as a final bisimulation and a final coalgebra, and relations between them. This is a special case for a cofree coalgebra, namely starting at \(X = \unit\).
\\ \\
Since we know that \texttt{M}-types preserves the H-level, we can use set-truncated quotients, to define quotient \texttt{M}-types, for examples we can define weak bisimulation of the delay monad ...
\todo[inline]{Quotients of the delay monad}

\subsection{Quotient inductive-inductive types (QIITs)}
"A quotient inductive-inductive type (QIIT) can be seen as a multi-sorted algebraic theory where sorts can be indexed over each other" - "Constructing Quotient Inductive-Inductive Types"

"W-types can be seen informally as the free algebras for signatures with operations of possibly infinite arity, but no equations." -- \url{https://arxiv.org/pdf/1201.3898.pdf}

A quotient inductive-inductive type (QIIT) is a type together with a relation defined on that type, and then quotiented by that relation.
\todo[inline]{What is a QIIT concretely?}
\subsubsection{Partiality monad}
A simple example of a quotient inductive-inductive type is the partiality monad \((-)_\bot\) over a type \(\type{R}\), defined by the constructors
\begin{equation}
  \infer{\type{R}_\bot : \universe{\mathcal{U}}}{}
\end{equation}
\begin{equation}
  \infer{\constant{\bot} : \type{R}_\bot}{}
\end{equation}
\begin{equation}
  \infer{\function{\eta}~\term{a} : \type{R}_\bot}{\term{a} : \type{R}}
\end{equation}
together with a relation \((\cdot \sqsubseteq \cdot)\) (indexed twice over \(\type{R}_\bot\)) and properties
\begin{equation}
  \infer{\bigsqcup~(s,b) : \type{R}_\bot}{s : \mathbb{N} \rightarrow \type{R}_\bot & b : \prod_{(n : \mathbb{N})} s_n \sqsubseteq s_{n+1} }
\end{equation}
\begin{equation}
  \infer{\alpha~p~q : x \equiv y}{x,y : \type{R}_\bot & p : x \sqsubseteq y & q : y \sqsubseteq x}
\end{equation}
\begin{equation}
  \infer[\sqsubseteq_{refl}]{x \sqsubseteq x}{}
\end{equation}
\begin{equation}
  \infer[\sqsubseteq_{trans}]{x \sqsubseteq z}{x \sqsubseteq y & y \sqsubseteq z}
\end{equation}
\begin{equation}
  \infer[\sqsubseteq_{never}]{\bot \sqsubseteq x}{}
\end{equation}
\begin{equation}
  \infer{\prod_{(n:\mathbb{N})} s_n \sqsubseteq \bigsqcup(s,p)}{}
\end{equation}
\begin{equation}
  \infer{\bigsqcup(s,p) \sqsubseteq x}{\prod_{(n:\mathbb{N})} s_n \sqsubseteq x}
\end{equation}
and then set truncated
\begin{equation}
  \infer{p \equiv q}{p , q : x \sqsubseteq y}
\end{equation}

\subsubsection{Delay monad to Sequences}
We define
\begin{equation}
  \typeformer{Seq}_{\type{A}} = \sum_{(\function{g} : \type{\mathbb{N}} \rightarrow \type{A} + \unit)} \function{isMon}~g
\end{equation}
where
\begin{equation}
  \function{isMon}~g = \prod_{(n : \type{\mathbb{N}})} (\function{g}_n \equiv \function{g}_{n+1})  + ((\function{g}_n \equiv \mathtt{inr}~\constant{tt}) \times (\function{g}_{n+1} \not\equiv \mathtt{inr}~\constant{tt}))
\end{equation}
that is sequences are \(\mathtt{inr}~\constant{tt}\) until they reach a point where it switches to \(\mathtt{inl}~\term{r}\) for some value \(\term{r}\). There are also the special cases of already terminated, meaning only \(\mathtt{inl}~\term{r}\) and never teminating meaning only \(\mathtt{inr}~\constant{tt}\). \todo[inline]{Some comment about decidable equivalence needed to show that \(\function{g}_{n+1} \not\equiv \mathtt{inr}~\constant{tt}\)} We define an operation to shift the sequence by inserting an element at \(n = 0\)
\begin{equation}
  \begin{aligned}
    \function{shift} &: ((\function{g} , \function{q}) : \mathtt{Seq}_A) \rightarrow \sum_{(\term{z_g} : A + \unit)} \left(\function{isMon}~\left(\lambda\,n, \begin{cases} \term{z_g} & n = 0 \\ \function{g}_m & n = m + 1 \end{cases}\right) 0\right) \rightarrow \mathtt{Seq}_A \\
    \function{shift}&~(\function{g} , \function{q})~(\term{z_g} , \term{z_q}) = \begin{cases} \term{z_g} & n = 0 \\ \function{g}_m & n = m + 1 \end{cases} , \begin{cases} \term{z_q} & n = 0\\ \function{q}_m & n = m + 1 \end{cases},
  \end{aligned}
\end{equation}
and a function to remove the first element
\begin{equation}
  \begin{aligned}
    \function{unshift} &: \mathtt{Seq}_A \rightarrow \mathtt{Seq}_A \\
    \function{unshift}&~(\function{g} , \function{q}) = \function{g} \circ \mathtt{suc} , \function{q} \circ \mathtt{suc}.
  \end{aligned}
\end{equation}
These two functions are inverse, since unshifting a value followed by a shift, where we reintroduce the value we just remove, does not change the value, said in another way the function
\begin{equation}
  \lambda\,(\function{g},\function{a}), \function{shift}~(\function{unshift}~(\function{g},\function{a}))~(\function{g}_0,\function{a}_0)
\end{equation}
is equal to the identity function. Similarly if we shift followed by an unshift, we just introduce a value to instantly remove it, meaning the value does not matter, again the function
\begin{equation}
  \lambda\,(\function{g},\function{a}),~\function{unshift}~(\function{shift}~(\function{g},\function{a})~\_)
\end{equation}
is equal to the identity function. We can now define an equivalence between \(\typeformer{delay}~\type{R}\) and \(\typeformer{Seq}_{\type{R}}\), where later are equivalent to shifts, and \(\function{now}~\term{r}\) is equivalent to the infinite sequence of \(\mathtt{inl}~\term{r}\). We define
\begin{equation}
  \begin{aligned}
    \function{Delay{\rightarrow}Seq} &: \typeformer{Delay}~R \rightarrow \typeformer{Seq}_A \\
    \function{Delay{\rightarrow}Seq}&~(\function{now}~\term{a}) = (\lambda\,\_,\mathtt{inl}~\term{a}) , (\lambda\,\_,\mathtt{inl}~\mathtt{refl}) \\
    \function{Delay{\rightarrow}Seq}&~(\function{later}~\term{x}) = \function{shift}~(\function{Delay{\rightarrow}Seq}~\term{x})~\_
  \end{aligned}
\end{equation}
\todo[inline]{what should \_ be here?}
\begin{equation}
  \begin{aligned}
    \function{Seq{\rightarrow}Delay} &: \typeformer{Seq}_A \rightarrow \typeformer{Delay}~R \\
    \function{Seq{\rightarrow}Delay}&~(\function{g} , \function{q}) = \begin{cases} \function{now}~\term{r} & \function{g}_0 = \mathtt{inl}~\term{r} \\ \function{later}~(\function{Seq{\rightarrow}Delay}~(\function{unshift}~(\function{g} , \function{q}))) & \function{g}_0 = \mathtt{inr}~\constant{tt} \end{cases}
  \end{aligned}
\end{equation}
with the right identity
\begin{equation}
  \begin{aligned}
    \function{Seq\text{-}Delay} &: \forall\,(\function{g},\function{q}) \rightarrow \function{Delay{\rightarrow}Seq}~(\function{Seq{\rightarrow}Delay}~(\function{g},\function{q})) \equiv (\function{g},\function{q}) \\
    \function{Seq\text{-}Delay}&~(\function{g},\function{q}) = \begin{cases} \mathtt{refl}  & \function{g}_0 = \mathtt{inl}~\term{r} \\ \mathtt{cong}~\function{shift}~(\function{Seq\text{-}Delay}~(\function{unshift}~(\function{g} , \function{q}))) \ct \function{shift\text{-}unshift}~(\function{g} , \function{q}) & \function{g}_0 = \mathtt{inr}~\constant{tt} \end{cases}
  \end{aligned}
\end{equation}
and left identity
\begin{equation}
  \begin{aligned}
    \function{Delay\text{-}Seq} &: \forall\,\term{t} \rightarrow \function{Seq{\rightarrow}Delay}~(\function{Delay{\rightarrow}Seq}~\term{t}) \equiv \term{t} \\
    \function{Delay\text{-}Seq}&~(\function{now}~\term{a}) = \mathtt{refl} \\
    \function{Delay\text{-}Seq}&~(\function{later}~\term{x}) = \mathtt{cong}~(\function{later} \circ \function{h})~\function{unshift\text{-}shift} \ct \mathtt{cong}~\function{later}~(\function{Delay\text{-}Seq}~\term{x})
  \end{aligned}
\end{equation}
\subsubsection{Sequence to Partiality monad}
We define a termination relation for sequences
\begin{equation}
  \begin{aligned}
    \relation{\downarrow_{\mathtt{Seq}}} &: \typeformer{Seq}_{\type{A}} \rightarrow \type{A} \rightarrow \universe{\mathcal{U}} \\
    (s,q)~\relation{\downarrow_{\mathtt{Seq}}}&~a = \sum_{(n : \mathbb{N})} s_n \equiv \mathtt{inl}~a
  \end{aligned}
\end{equation}
We define an ordering relation on a sequence
\begin{equation}
  (s,q)~\relation{\sqsubseteq_{\mathtt{Seq}}}~(t,p) = \prod_{(a : \type{A})} \left(\|s~\relation{\downarrow_{\mathtt{Seq}}}~a\| \rightarrow \| t~\relation{\downarrow_{\mathtt{Seq}}}~a\|\right)
\end{equation}
the bottom element \(\constant{\bot}\) of the ordering is the never terminating sequence, where all values are \(\mathtt{inr}~\constant{tt}\). The unit \(\function{\eta}\) is defined, given some \(\term{r}\), as the terminated sequence of all \(\mathtt{inl}~\term{r}\).
\todo[inline]{\(\alpha_{\mathtt{Seq}}\) and \(\bigsqcup_{\mathtt{Seq}}\)}
We define a conversion from \(\type{A} + \unit\) to the partiality monad
\begin{equation}
  \begin{aligned}
    &\function{Maybe{\rightarrow}\bot} : \type{A} + \unit \rightarrow \type{A}_\bot \\
    &\function{Maybe{\rightarrow}\bot}~(\function{inl}~a) = \function{\eta}~a \\
    &\function{Maybe{\rightarrow}\bot}~(\function{inr}~\constant{tt}) = \constant{\bot}
  \end{aligned}
\end{equation}
we also define an ordering on \(\type{A} + \unit\)
\begin{equation}
  \begin{aligned}
    &\relation{\sqsubseteq_{\type{A} + \unit}} : \type{A} + \unit \rightarrow \type{A} + \unit \rightarrow \universe{\mathcal{U}} \\
    x~&\relation{\sqsubseteq_{\type{A} + \unit}}~y = (x \equiv y) + ((x \equiv \function{inr}~\constant{tt}) \times (y \not\equiv \function{inr}~\constant{tt}))
  \end{aligned}
\end{equation}
the function \(\function{Maybe{\rightarrow}\bot}\) is monotone
\begin{equation}
  \begin{aligned}
    &\function{Maybe{\rightarrow}\bot\text{-}mono} : x~\relation{\sqsubseteq_{\type{A} + \unit}}~y \rightarrow (\function{Maybe{\rightarrow}\bot}~x)~\relation{\sqsubseteq_\bot}~(\function{Maybe{\rightarrow}\bot}~y) \\[1mm]
    &\function{Maybe{\rightarrow}\bot\text{-}mono}~(\function{inl}~\pathterm{p}) = \\[-1mm]
    &\quad \mathtt{subst}~(\lambda\,a, \function{Maybe{\rightarrow}\bot}~x~\relation{\sqsubseteq_\bot}~\function{Maybe{\rightarrow}\bot}~a)~\pathterm{p}~(\function{\sqsubseteq_{refl}} (\function{Maybe{\rightarrow}\bot}~x)) \\[1mm]
    &\function{Maybe{\rightarrow}\bot\text{-}mono}~(\function{inr}~(\pathterm{p}, \_)) = \\[-1mm]
    &\quad \mathtt{subst}~(\lambda\,a, \function{Maybe{\rightarrow}\bot}~a~\relation{\sqsubseteq_\bot}~\function{Maybe{\rightarrow}\bot}~y)~\sym{\pathterm{p}}~(\function{\sqsubseteq_{never}} (\function{Maybe{\rightarrow}\bot}~y))
  \end{aligned}
\end{equation}
we define a function taking a sequence to an increasing sequence
\begin{equation}
  \begin{aligned}
    &\function{Seq{\rightarrow}incSeq} \\
    &\function{Seq{\rightarrow}incSeq}~(\function{g} , \function{q}) = \function{Maybe{\rightarrow}\bot} \circ \function{g} , \function{Maybe{\rightarrow}\bot\text{-}mono} \circ \function{q}
  \end{aligned}
\end{equation}
we can now define the function taking a sequence to the partiality monad
\begin{equation}
  \begin{aligned}
    &\function{Seq{\rightarrow}\bot} : \typeformer{Seq}_{\type{A}} \rightarrow \type{A}_{\bot} \\
    &\function{Seq{\rightarrow}\bot}~(\function{g},\function{q}) = \bigsqcup \circ~\function{Seq{\rightarrow}incSeq}
  \end{aligned}
\end{equation}
this function is again monotone, if a sequence is smaller than another sequence, then the least upper bounds of each sequence respect the ordering, meaning we get the function \todo{should this be formalized entirely, or should there just be a comment about monotonicity? Does not seem relevant?}
\begin{equation}
    \function{Seq{\rightarrow}\bot\text{-}mono} : \typeformer{isSet} \type{A} \rightarrow (x~y : \typeformer{Seq}~\type{A}) \rightarrow x~\relation{\sqsubseteq_{seq}}~y \rightarrow \function{Seq{\rightarrow}\bot}~x~\relation{\sqsubseteq_\bot}~\function{Seq{\rightarrow}\bot}~y
\end{equation}
we define a function for weak extensionality \todo{is this weak extensionality for sequences? NO! it is the inverse of weak effective} for sequences. 
\begin{equation}
  \begin{aligned}
    &\function{Seq{\rightarrow}\bot\text{-}{\approx}{\rightarrow}{\equiv}} : \typeformer{isSet}~\type{A} \rightarrow (x~y : \typeformer{Seq}_{\type{A}}) \rightarrow x~\relation{\sim_{Seq}}~y \rightarrow \function{Seq{\rightarrow}\bot}~x \equiv \function{Seq{\rightarrow}\bot}~y \\
    &\function{Seq{\rightarrow}\bot\text{-}{\approx}{\rightarrow}{\equiv}}~A_{set}~\term{x}~\term{y}~(p , q)~= \function{\alpha_{\bot}}~(\function{Seq{\rightarrow}\bot\text{-}mono}~A_{set}~x~y~p)~(\function{Seq{\rightarrow}\bot\text{-}mono}~A_{set}~y~x~q)
  \end{aligned}
\end{equation}
we define a recursor (???) \todo{is this a recorsor, and for what? The quotient?}
\begin{equation}
  \begin{aligned}
    &\function{rec}~: (\term{x}~\term{y} : \typeformer{Seq}~\type{A}) \rightarrow (\function{f} : \type{A} \rightarrow \type{B}) \rightarrow (\function{g} : \term{x}~\relation{R}~\term{y} \rightarrow \function{f}~\term{x} \equiv \function{f}~\term{y}) \\
    &\quad~ \rightarrow (\term{B_{set}} : \typeformer{isSet}~\type{B}) \rightarrow (\type{A} / \relation{R} \rightarrow \type{B}) \\
    &\function{rec}~\function{[}\,\term{z}\,\function{]} = \function{f}~\term{z} \\
    &\function{rec}~(\function{eq/}~\_~\_~\term{r}~i) = \function{g}~\term{r}~i \\
    &\function{rec}~(\function{squash/}~\term{a}~\term{b}~\pathterm{p}~\pathterm{q}~i~j) = \term{B_{set}}~(\function{rec}~\term{a})~(\function{rec}~\term{b})~(\mathtt{ap}~\function{rec}~\pathterm{p})~(\mathtt{ap}~\function{rec}~\pathterm{q})~i~j
\end{aligned}
\end{equation}
we then need to lift this to the quotient
\begin{equation}
  \begin{aligned}
    &\function{Seq/{\sim}{\rightarrow}\bot} : \typeformer{isSet}~\type{A} \rightarrow \typeformer{Seq}_{\type{A}} \rightarrow \type{A}_{\bot} \\
    &\function{Seq/{\sim}{\rightarrow}\bot}~\term{A_{set}} = \function{rec}~\function{Seq{\rightarrow}\bot}~(\lambda\,\term{x}\,\term{y}, \function{Seq{\rightarrow}\bot\text{-}{\approx}{\rightarrow}{\equiv}}~\term{A_{set}}~\term{x}~\term{y})~\function{\bot\text{-}isSet}
  \end{aligned}
\end{equation}
We can then show that this function makes an equivalence, by showing it is injective and surjective (since we are working in hSets). We start by showing that
\begin{equation}
  \begin{aligned}
    &\function{Seq{\rightarrow}\bot\text{-}isInjective\text{-}helper} : \typeformer{isSet}~\type{A} \rightarrow (s~t : \typeformer{Seq}_{\type{A}}) \rightarrow \function{Seq{\rightarrow}\bot}~s \equiv \function{Seq{\rightarrow}\bot}~t \\
    &\qquad\qquad\qquad\qquad\qquad\quad~~ \rightarrow (a : A) \rightarrow \| s~\relation{\downarrow_{seq}}~a \| \rightarrow \| t~\relation{\downarrow_{seq}}~a \| \\
    &\function{Seq{\rightarrow}\bot\text{-}isInjective\text{-}helper}~A_{set}~s~t~p~a~k = ?
  \end{aligned}
\end{equation}

\begin{equation}
  \begin{aligned}
    &\function{Seq{\rightarrow}\bot\text{-}isInjective} : \typeformer{isSet}~\type{A} \rightarrow (s~t : \typeformer{Seq}_{\type{A}}) \rightarrow \function{Seq{\rightarrow}\bot}~s \equiv \function{Seq{\rightarrow}\bot}~t \rightarrow s~\relation{\sim_{Seq}}~t \\
    &\function{Seq{\rightarrow}\bot\text{-}isInjective}~A_{set}~s~t~ = ?
  \end{aligned}
\end{equation}


\subsubsection{Building the Partiality Monad as an M-type (Dialgebra?)}
\todo[inline]{Is this possible?}
% We want an object \(\constant{\bot} : \type{A}_{\bot}\), which can be seen as a function \(\unit \rightarrow \type{A}_{\bot}\), as defined in \figref{partiality-monad-M-type-0}
% \begin{figure}[h]
%   \centering
%   \begin{tikzcd}[row sep=huge,column sep=huge]
%     \unit \ar[r] \ar[dr,"\bot"'] & A_{\bot} + \unit \ar[d,shift left,"\function{in}"] \\
%     & \type{A}_{\bot} \ar[u,shift left,"\function{out}"]
%   \end{tikzcd}
%   \caption{Partiality monad as M-type (0)}
%   \label{fig:partiality-monad-M-type-0}
% \end{figure}
% we then want to add the unit of the monad \(\eta : \type{A} \rightarrow \type{A}_\bot\), this is done in \figref{partiality-monad-M-type-1}
% \begin{figure}[h]
%   \centering
%   \begin{tikzcd}[row sep=huge,column sep=huge]
%     \unit \ar[r] \ar[dr,"\bot"'] & A_{\bot} + \unit + A \ar[d,shift left,"\function{in}"] & A \ar[l] \ar[ld,"\eta"] \\
%     & \type{A}_{\bot} \ar[u,shift left,"\function{out}"]
%   \end{tikzcd}
%   \caption{Partiality monad as M-type (1)}
%   \label{fig:partiality-monad-M-type-1}
% \end{figure}
% we now want to define an ordering on \(A\) as in \figref{partiality-monad-M-type-2}
% \begin{figure}[h]
%   \centering
%   \begin{tikzcd}[row sep=huge,column sep=huge]
%     \unit \ar[r] \ar[dr,"\bot"'] & \type{A}_{\bot} + \unit + \type{A} \ar[d,shift left,"\function{in}"] & \type{A} \ar[l] \ar[ld,"\eta"] \\
%     & \type{A}_{\bot} \ar[u,shift left,"\function{out}"] \\
%     & \unit + \type{A} \ar[u,shift left,bend left=60,""'{name=lear}] \ar[u, shift right,bend right=60, ""{name=riar}] \ar[Rightarrow,to path=(lear)--(riar)\tikztonodes,"\sqsubseteq"]
%   \end{tikzcd}
%   \caption{Partiality monad as M-type (2)}
%   \label{fig:partiality-monad-M-type-2}
% \end{figure}
% \begin{figure}[h]
%   \centering
%   \begin{tikzcd}[row sep=huge,column sep=huge]
%     \unit \ar[r] \ar[dr,"\bot"'] & \type{A}_{\bot} + \unit + \type{A} \ar[d,shift left,"\function{in}"] & \type{A} \ar[l] \ar[ld,"\eta"] \\
%     & \type{A}_{\bot} \ar[u,shift left,"\function{out}"] \ar[d,shift left] \ar[d,shift right] \\
%     & \type{A}_{\bot} \times \type{A}_{\bot} \ar[r,"\sqsubseteq"] & \universe{\mathcal{U}}
%   \end{tikzcd}
%   \caption{Partiality monad as M-type (3)}
%   \label{fig:partiality-monad-M-type-3}
% \end{figure}

\subsubsection{Partiality from Delay monad}
We want to define an ordering on the delay monad, we do this by counting the number of \texttt{later}s, letting the infinitely delayed element \texttt{never}, be the bottom element of the ordering. So we get
\begin{equation}
  \infer{\constant{never} \sqsubseteq \term{x}}{\term{x} : \typeformer{Delay}~\type{R}}
\end{equation}
\begin{equation}
  \infer[\sqsubseteq_{\mathtt{now}}]{\term{x} \sqsubseteq \function{now}~\term{a}}{\term{x} : \typeformer{Delay}~\type{R} & \term{a} : \type{R} & \term{x} \downarrow \term{a}}
\end{equation}
\begin{equation}
  \infer=[\sqsubseteq_{\mathtt{later}}]{\function{later}~\term{x} \sqsubseteq \function{later}~\term{y}}{\term{x} \sqsubseteq \term{y}}
\end{equation}
given these two rules, we want to show that we actually have an ordering. So first we want to show that we get reflexivity, we do the proof by structural induction.

\begin{lem}
  The bottom element of the relation \(\sqsubseteq\) is \(\constant{never}\), meaning for all \(\term{x}\) we get \(\constant{never} \sqsubseteq \term{x}\).
  \begin{proof}
    If \(\term{x} = \function{now}~\term{a}\) then we get \(???\)
    \todo[inline]{is this true by assumption}
  \end{proof}
\end{lem}
  
\begin{lem}
  The relation \(\sqsubseteq\) is reflexive.
  \begin{proof}
    If \(\term{x} = \function{now}~\term{a}\) then we know that \(\term{x} \downarrow \term{a}\) meaning by the rule \(\sqsubseteq_{\mathtt{now}}\), we have \(\function{now}~\term{a} \sqsubseteq \function{now}~\term{a}\). If we have \(\term{x} = \function{later}~\term{y}\) then by the rule \(\sqsubseteq_{\mathtt{later}}\) we just need to show \(\term{y} \sqsubseteq \term{y}\), which is true by the induction hypothesis.
  \end{proof}
\end{lem}

\begin{lem}
  For all \(\term{x} : \typeformer{Delay}~\type{R}\) we have \(\function{now}~\term{a} \sqsubseteq \term{x}\) implies that \(\term{x} = \function{now}~\term{a}\).
  \begin{proof}
    If \(\term{x} = \function{now}~\term{b}\), then \(\function{now}~\term{a} \downarrow \term{b}\), but this means that \(\term{a} \equiv \term{b}\). If  \(x = \function{later}~y\) we get a contradiction, since there is no constructor for \(\function{now}~a \sqsubseteq \function{later}~y\).
  \end{proof}
\end{lem}
% \(x \sqsubseteq y\) and \(x \downarrow a\) implies that \(y \downarrow a\)
\begin{lem}
  The relation \(\sqsubseteq\) is transitive.
  \begin{proof}
    We do case analysis on \(y\), if \(y = \function{now}~a\) then \(z = \function{now}~a = y\), , meaning \(x \sqsubseteq z = x \sqsubseteq y\). If \(y = later~v\), then \(z = now~a\) or \(z = later~w\). If \(z = now~a\) then \(y \downarrow a\), .
  \end{proof}
\end{lem}


% Sierpinski set
% Rosolini’s dominance

% non-termination monad -- Partiality monad - completely iterative monad (on 1 -> 1)

\subsection{QM-types}
A QM-type is a quotiented M-type, we try to define this as a quotient on containers. We define container quotients as
\begin{equation}
  ...
\end{equation}
\\ \\
We want to define QM-types as the final coalgebra satisfying a set of equations. The construction takes inspiration from \cite{Infinitary-QIITs}
\subsubsection{Cofree Coalgebra}
We want to define a cofree coalgebra over a container \(\containerpair{A}{\lambda\,\_, \empt}\).
\\ \\
This is defined as the left adjoint to the forgetful functor \(\function{U} : \coalg{\type{C}}{\term{\gamma}} \rightarrow \type{C}\) as \(\function{F} : \type{C} \rightarrow \coalg{\type{C}}{\term{\gamma}}\).

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \functor{P} \type{A} \ar[d] \ar[d,"\epsilon"] \\
    \type{A} & \type{M} \ar[l,"\alpha"] \ar[ul,"\alpha^\sharp"']
  \end{tikzcd}
  \caption{Cofree Coalgebra}
  \label{fig:cofree-coalgebra}
\end{figure}

A coalgebra PA is cofree on A iff for all coalgebras M and mappings \(\alpha : UM \rightarrow C\) there is a unique morphism \(\alpha^\sharp : M \rightarrow TC\) such that the diagram \figref{cofree-coalgebra} commutes

\subsubsection{Equation system}
We start by defining a equation system called a covariety \cite{Hughes} of a coalgebra (dual of variety of an algebra).
\\ \\
Complete covarities are closed under bisimulation.

\section{Strongly Extensional (Coalgebra)}

% https://en.wikipedia.org/wiki/Variety_(universal_algebra)
% Hughes
% Alexander Kurz

\begin{defn}
  A equation system is given by
  \begin{equation}
    EqSys : \sum_{(E : \universe{\mathcal{U}})} \sum_{(V : \type{E} \rightarrow \universe{\mathcal{U}})} ((e : E) \rightarrow T (V e)) \times ((e : E) \rightarrow T (V e))
  \end{equation}
  where \(\type{E}\) representing the equations, and variables for the given equations, given by the type \(\typeformer{V}\), and \(T\) is the free coalgebra.
\end{defn}

\subsection{in progress}
Let \(\functor{G}\) be functors and \(v : \functor{P} \rightarrow \functor{G}\) a natural transformation. Suppose that for any type \(\type{V}\), the functor \((\lambda\,\_ \rightarrow \type{V}) \times\functor{F}\) has a final coalgebra. Then there exists for any G-coalgebra \(\coalg{\type{C}}{\function{\gamma}}\) an \(P\)-coalgebra \(\coalg{S_C}{\alpha}\) and a \(\functor{G}\)-homomorphism \(\varepsilon:\coalg{S_C}{v_{S_C} \circ \alpha} \Rightarrow \coalg{C}{\gamma}\), satisfying the universal property: for any \(P\)-coalg \(\coalg{U}{\alpha_U}\) and any G-homomorphism \(f : \coalg{U}{v_U \circ \alpha_U} \Rightarrow \coalg{C}{\gamma}\) there exists a unique \(P\)-homomorphism \(\tilde{f} : \coalg{U}{\alpha_u} \Rightarrow \coalg{S_C}{\alpha}\) such that \(\varepsilon \circ \tilde{f} = f\). The \(P\)-coalg \(\coalg{S_c}{\alpha}\) (and \(\varepsilon\)) is called cofree on the G-coalgebra \(\coalg{C}{\gamma}\). \cite[theorem 17.1]{UniversalCoalgebra}.
\\ \\
The coalgebra generated by the polynomial functor over the container \(\containerpair{A}{B}\) is a cofree coalgebra. We can now define a quotient, by defining a equation system at the same time, as we define the \texttt{M}-type type. The equation systems is defined on a type \(E : \mathcal{U}\) with variables of type \(V : E \rightarrow \mathcal{U}\), each equation is given by functions \(l,r : C \rightarrow A\) for some type \(C\). A coalgebra satisfies the equation system iff \((t : B (l c) \rightarrow MQ) \rightarrow (s : B (r c) \rightarrow MQ) \rightarrow l c \equiv r c\) is inhabited.

\section{TODO}
\begin{itemize}
\item Resumption Monad transformer
\item coinduction in Coq is broken
\item bisim \(\Rightarrow\) eq
\item copattern matching
\item cubical Agda. Relation between \texttt{M}-types defined by coinduction/copattern matching and constructed from W-types
\item   In Agda, co-inductive types are defined using Record types, which are Sigma-types. 
\item   In cubical Agda, 3.2.2 the issue of productivity is discussed. This can probably be made precise using guarded types.
\item streams defined by guarded recursion vs coinduction in guarded cubical Agda. 
\item    p3 of the guarded cubical Agda paper describes how semantic productivity improves over syntactic productivity
\item Reduction of co-inductive types in Coq/Agda to (indexed) \texttt{M}-types. Like reduction of strictly positive inductive types to W-types. https://ncatlab.org/nlab/show/W-type
\item QIITs have been formalized in Agda using private types. Can this also be done in cubical Agda (ie without cheating).
\item   Show that this is the final (quotiented) coalgebra. Does this generalize to Q\texttt{M}-types, and what are those constructively ??
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Properties of M-types?}
\section{Closure properties of \texttt{M}-types}
We want to show that \texttt{M}-types are closed under simple operations, we start by looking at the product.
\subsection{Product of \texttt{M}-types}
We start with containers and work up to \texttt{M}-types.
\begin{defn}
  The product of two containers is defined as \cite{ContainerRules}
  \begin{equation}
    \containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}} \equiv \containerpair{\type{A} \times \type{C}}{\lambda\,(\term{a} , \term{c}), \typeformer{B}~\term{a} \times \typeformer{D}~\term{c}}.
  \end{equation}
\end{defn}
\noindent We can lift this rule, through the diagram in \figref{container-products}, used to define \texttt{M}-types.
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{A} & \type{A} \times \type{C} \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \type{C} \\
    \functor{P} (\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}) \ar[u,"\pi_1"'] & \functor{P}(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}) \ar[l] \ar[r] \ar[u,"\pi_1"'] & \functor{P} (\typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}}) \ar[u,"\pi_1"'] \\
    \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}} \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] & \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}} \ar[l] \ar[r] \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] & \typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}} \ar[u,"\function{out}"'] \ar[d,"\function{\pi}_{(!)}"] \\
    {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^n~\unit \ar[d,"\function{\pi}_{(n)}"] & {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \ar[l] \ar[r] \ar[d,"\function{\pi}_{(n)}"] & {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \ar[d,"\function{\pi}_{(n)}"] \\
    \vdots \ar[d,"\function{\pi}_{(1)}"] & \vdots \ar[d,"\function{\pi}_{(1)}"] & \vdots \ar[d,"\function{\pi}_{(1)}"] \\
    \functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}~\unit \ar[d,"\function{\pi}_{(0)}"] & \functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}~\unit \ar[l] \ar[r] \ar[d,"\function{\pi}_{(0)}"] & \functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}~\unit \ar[d,"\function{\pi}_{(0)}"] \\
    \unit & \unit \ar[l,"\texttt{refl}"] \ar[r,"\texttt{refl}"'] & \unit
  \end{tikzcd}
  \caption{Diagram for products of chains}
  \label{fig:container-products}
\end{figure}
\begin{thm}
  For any \(n : \type{\mathbb{N}}\) the following is true
  \begin{equation}
    {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^n~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^n~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^n~\unit. \label{eq:polynomial-functor-product}
  \end{equation}
  
  \begin{proof}
    We do induction on \(n\), for \(n = 0\), we have \(\unit \times \unit \equiv \unit\). For \(n = m + 1\), we may assume
    \begin{equation}
      {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \equiv {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit,
    \end{equation}
    in the following
    \begin{align}
      &~ {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^{m+1}~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^{m+1}~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\typeformer{B}}} ({\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit) \times \functor{P}_{\containerpair{\type{C}}{\typeformer{D}}} ({\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} : \type{A}} \typeformer{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times \sum_{\term{c} : \type{C}} \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} (\typeformer{B}~\term{a} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit) \times (\typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \typeformer{B}~\term{a} \times \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}}}}^m~\unit \times {\functor{P}_{\containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \sum_{\term{a} , \term{c} : \type{A} \times \type{C}} \typeformer{B}~\term{a} \times \typeformer{D}~\term{c} \rightarrow {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit \\
      \equiv&~ \functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}} ({\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^m~\unit) \\
      \equiv&~ {\functor{P}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}}^{m+1}~\unit
    \end{align}
    taking the limit of \eqref{eq:polynomial-functor-product} we get
  \begin{equation}
    \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}} \times \typeformer{M}_{\containerpair{\type{C}}{\typeformer{D}}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}} \times \containerpair{\type{C}}{\typeformer{D}}}.
  \end{equation}
  \end{proof}
\end{thm}
\begin{exmp} For streams we get
\begin{equation}
  \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit}} \times \typeformer{M}_{\containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{M}_{\containerpair{\type{A}}{\lambda~\_,\unit} \times \containerpair{\type{B}}{\lambda~\_,\unit}} \equiv \typeformer{stream}~(\type{A} \times \type{B}) \label{eq:zip-equality}
\end{equation}
as expected. Transporting along \eqref{eq:zip-equality} gives us a definition for \function{zip}.
\end{exmp}

\subsection{Co-product}
\todo[inline]{Coproducts?}

\subsection{...}
\todo[inline]{The rest of the closures defined in "Categories of Containers" \cite{ContainerRules}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Examples of \texttt{M}-types}

\section{Automaton}
An automaton is defined as a set of state \(\type{V}\) and an alphabet \(\type{\alpha}\) and a transition function \(\function{\delta} : \type{V} \rightarrow \type{\alpha} \rightarrow \type{V}\). This gives us the diagram in \figref{automaton}
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \type{V} \times (\type{V} \rightarrow \type{\alpha} \rightarrow \type{V}) \ar[dr,"build"'] \ar[r] & M & M \ar[dl,"step"] \\
    & M
  \end{tikzcd}
  \caption{automaton}
  \label{fig:automaton}
\end{figure}

\section{The Partiality monad}
To construct the partiality monad, we start with the delay monad, and the preorder
\begin{equation}
\forall x, \bot \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x, x \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x\,y\,z, x \sqsubseteq y \rightarrow y \sqsubseteq z \rightarrow x \sqsubseteq z
\end{equation}
we can then define the partiality monad

The partiality monad \((-)_\bot\) is a way of adding partiality to a given computation. Along with the partiality monad, we also get a partial ordering \((\cdot \sqsubseteq \cdot)\), by
\begin{equation}
\forall x, \bot \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x, x \sqsubseteq x
\end{equation}
\begin{equation}
\forall\,x\,y\,z, x \sqsubseteq y \rightarrow y \sqsubseteq z \rightarrow x \sqsubseteq z
\end{equation}
\begin{equation}
\forall\,x\,y, x \sqsubseteq y \rightarrow y \sqsubseteq x \rightarrow x \equiv y
\end{equation}
We now want to show that we can construct the partiality monad from the delay monad. We need an operation that given an element of the delay monad, maps to an element of the partiality monad.
\begin{equation}
  \function{now}~x = x + \unit
\end{equation}
\begin{equation}
  \function{later}~y = y
\end{equation}

\section{TODO: Place these subsections}
\todo[inline]{What makes a relation a bisimulation? Is bisim and equality equal.}
\subsection{Identity Bisimulation}
Lets start with a simple example of a bisimulation namely the one given by the identity relation for any \texttt{M}-type.
\begin{lem}
  The identity relation \((\cdot \equiv \cdot)\) is a bisimulation for any final coalgebra \(\coalg{\typeformer{M}_{\container{S}}}{\function{out}}\) defined over an \texttt{M}-type.
  
  \begin{proof}
  We first define the function
  \begin{equation}
    \begin{aligned}
      \function{\alpha}_{\equiv} &: \type{\overline{\equiv}} \rightarrow \functor{P}(\type{\overline{\equiv}}) \\
      \function{\alpha}_{\equiv} (x , y) &:= \pi_1~(\function{out}~x)~,~(\lambda\,b, (\pi_2~(\function{out}~x)~b \,,\, \texttt{refl}_{(\pi_2\,(\function{out}\,x)\,b)}))
    \end{aligned}
  \end{equation}
  and the two projections
  \begin{align}
    \pi_1^{\type{\overline{\equiv}}} &= (\pi_1 , \texttt{funExt}~\lambda\,(a,b,r), \texttt{refl}_{\function{out}\,a}) \\
    \pi_2^{\type{\overline{\equiv}}} &= (\pi_2 , \texttt{funExt}~\lambda\,(a,b,r), \texttt{cong}_{\function{out}}~(\sym{r})).
  \end{align}
  This defines the bisimulation, given by the diagram in \figref{id-bisim}.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\equiv}}}{\function{\alpha}_{\equiv}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\equiv}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\equiv}}}"] & \coalg{\typeformer{M}}{\function{out}}
    \end{tikzcd}
    \caption{Identity bisimulation}
    \label{fig:id-bisim}
  \end{figure}
\end{proof}
\end{lem}
\subsection{Bisimulation of Streams}
\todo[inline]{TODO}
\subsection{Bisimulation of Delay Monad}
We want to define a strong bisimulation relation \(\relation{\sim_{delay}}\) for the delay monad, 
\begin{defn}
  The relation \(\relation{\sim_{delay}}\) is defined by the following rules
  \begin{equation}
    \infer[\mathtt{now}{\sim}]{\function{now}~\term{r}~\relation{\sim_{delay}}~\function{now}~\term{r} : \universe{\mathcal{U}}}{\type{R} : \universe{U} & \term{r} : \type{R}}
  \end{equation}
  \begin{equation}
    \infer[\mathtt{later}{\sim}]{\function{later}~\term{t}~\relation{\sim_{delay}}~\function{later}~\term{u} : \universe{\mathcal{U}}}{\type{R} : \universe{\mathcal{U}} & \term{t} : \typeformer{delay}~\type{R} & \term{u} : \typeformer{delay}~\type{R} & \term{t}~\relation{\sim_{delay}}~\term{u} : \universe{\mathcal{U}}}
  \end{equation}
\end{defn}
\begin{thm}
  The relation \(\relation{\sim_{delay}}\) is a bisimulation for \(\typeformer{delay}~\type{R}\).
  \begin{proof}
    First we define the function
    \begin{equation}
      \begin{aligned}
        \function{\alpha}_{\relation{\sim_{delay}}} &: \type{\overline{\sim_{delay}}} \rightarrow \functor{P} (\type{\overline{\sim_{delay}}}) \\
        \function{\alpha}_{\relation{\sim_{delay}}}~(\term{a} , \term{b} , \mathtt{now}{\sim}~\term{r}) &:= (\mathtt{inr}~\term{r} , \lambda\,(\,)) \\
        \function{\alpha}_{\relation{\sim_{delay}}}~(\term{a} , \term{b} , \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}) &:= (\mathtt{inl}~\constant{tt} , \lambda\,\_, (\term{x} , \term{y} , \term{q}))
      \end{aligned}
    \end{equation}
    then we define the projections
      \begin{align}
        \pi_1^{\type{\overline{\sim_{delay}}}} &= \left( \pi_1 ~~ , ~~ \texttt{funExt}~\lambda\,(\term{a},\term{b},p), \begin{cases} (\mathtt{inr}~\term{r} , \lambda\,(\,)) & p = \mathtt{now}{\sim}~\term{r} \\ (\mathtt{inl}~\constant{tt} , \lambda\,\_, x) & p = \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}\end{cases} \right) \\
        \pi_2^{\type{\overline{\sim_{delay}}}} &= \left( \pi_2 ~~ , ~~ \texttt{funExt}~\lambda\,(\term{a},\term{b},p), \begin{cases} (\mathtt{inr}~\term{r} , \lambda\,(\,)) & p = \mathtt{now}{\sim}~\term{r} \\ (\mathtt{inl}~\constant{tt} , \lambda\,\_, y) & p = \mathtt{later}{\sim}~\term{x}~\term{y}~\term{q}\end{cases} \right) \\
      \end{align}
      This defines the bisimulation, given by the diagram in \figref{delay-strong-bisim}.
      \begin{figure}[h]
        \centering
        \begin{tikzcd}[column sep = large]
          \coalg{\typeformer{delay}~\type{R}}{\function{out}} & \coalg{\type{\overline{\sim_{\texttt{delay}}}}}{\function{\alpha}_{\relation{\sim_{delay}}}} \ar[l,Rightarrow,"\pi_1^{\type{\overline{\sim_{delay}}}}"'] \ar[r,Rightarrow,"\pi_2^{\type{\overline{\sim_{delay}}}}"] & \coalg{\typeformer{delay}~\type{R}}{\function{out}}
        \end{tikzcd}
        \caption{Strong bisimulation for delay monad}
        \label{fig:delay-strong-bisim}
      \end{figure}
  \end{proof}
\end{thm}

\subsection{Bisimulation of ITrees}
We define our bisimulation coalgebra from the strong bisimulation relation \(\mathcal{R}\), defined by the following rules.
\begin{equation}
  \infer[\mathtt{EqRet}]{\mathtt{Ret}~\term{a} \cong \mathtt{Ret}~\term{b}}{\term{a},\term{b} : \type{R} & \term{a} \equiv_{\type{R}} \term{b}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqTau}]{\mathtt{Tau}~\term{t} \cong \mathtt{Tau}~\term{u}}{\term{t},\term{u} : \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
\begin{equation}
  \infer[\mathtt{EqVis}]{\mathtt{Vis}~\term{e}~\term{k_1} \cong \mathtt{Tau}~\term{e}~\term{k_2}}{\type{A} : \universe{\mathcal{U}} & \term{e} : \typeformer{E}~\type{A} & \term{k_1},\term{k_2} : \type{A} \rightarrow \mathtt{itree}~\typeformer{E}~\type{R} & \term{t} \cong \term{u}}
\end{equation}
Now we just need to define \(\term{\alpha}_{\relation{\mathcal{R}}}\) \todo[inline]{define the \(\alpha_{\relation{R}}\) function}. Now we have a bisimulation relation, which is equivalent to equality, using what we showed in the previous section.

\subsection{Zip Function}
We want the diagram in \figref{zip-computation-rules} to commute,
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    & A \times B & \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[ur,"\function{hd} \times \function{hd}"'] \ar[rr,"\function{zip}"] \ar[d,"\function{tl} \times \function{tl}"] & & \typeformer{stream}~(\type{A} \times \type{B}) \ar[ul,"\function{hd}"] \ar[d,"\function{tl}"] \\
    \typeformer{stream}~\type{A} \times \typeformer{stream}~\type{B} \ar[rr,"\function{zip}"] & & \typeformer{stream}~(\type{A} \times \type{B})
  \end{tikzcd}
  \caption{TODO}
  \label{fig:zip-computation-rules}
\end{figure}
meaning we get the computation rules
\begin{equation}
  (\function{hd} \times \function{hd}) \equiv \function{hd} \circ \function{zip}
\end{equation}
\begin{equation}
  \function{zip} \circ (\function{tl} \times \function{tl}) \equiv \function{tl} \circ \function{zip}
\end{equation}
we can define the zip function as we did in the end of the last section. Another way to define the zip function is more directly, using the following lifting property of \texttt{M}-types
\begin{equation}
  \begin{aligned}
    &\function{lift_M}~\left(x : \prod_{n : \mathbb{N}} (\type{A} \rightarrow {\functor{P}_{\container{S}}}^n~\unit)\right)~\left(u : \prod_{n : \mathbb{N}} (\type{A} \rightarrow \pi_n (x_{n+1} a) \equiv x_n a)\right) (a : \type{A}) : \function{M}~\container{S} := \\
    &\qquad\qquad (\lambda\,n, x~n~a) , (\lambda\,n~i, p~n~a~i).
  \end{aligned} \label{eq:M-lift}
\end{equation}
To use this definition, we first define some helper functions
\begin{equation}
  \function{zip}_{X}~n~(x , y) = \begin{cases} \unit & \mathtt{if}~n = 0 \\ (\function{hd}~x , \function{hd}~y) , (\lambda\,\_, \function{zip}_{X}~m~(\function{tl}~x,\function{tl}~y)) , & \mathtt{if}~n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{zip}_{\pi}~n~(x , y) = \begin{cases} \function{refl} & \mathtt{if}~n = 0 \\ \lambda\,i,(\function{hd}~x , \function{hd}~y) , (\lambda\,\_, \function{zip}_{\pi}~m~(\function{tl}~x,\function{tl}~y)~i) , & \mathtt{if}~n = m + 1 \end{cases},
\end{equation}
we can then define
\begin{equation}
  \function{zip}_{lift}~(x , y) := \function{lift_M}~\function{zip}_X~\function{zip}~(x,y).
\end{equation}
\subsubsection{Equality of Zip Definitions}
We would expect that the two definitions for zip are equal
\begin{align}
  \texttt{transport}_{?}~a &\equiv \function{zip}_{lift}~a \\
                           &\equiv \function{lift_M}~\function{zip}_X~\function{zip}_\pi~(x,y) \\
                           &\equiv (\lambda\,n, \function{zip}_X~n~(x,y)) , (\lambda\,n~i, \function{zip}_\pi~n~(x,y)~i)
\end{align}
zero case \(X\)
\begin{equation}
  \function{zip}_X~0~(x,y) \equiv \unit
\end{equation}
Successor case \(X\)
\begin{align} 
  \function{zip}_X~(m+1)~(x,y) &\equiv (\function{hd}~x, \function{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\function{tl}~x,\function{tl}~y)) \\
                               &\equiv (\function{hd}~x, \function{hd}~y),(\lambda\,\_, {?}~(\function{tl}~a)) \\
                               &\equiv (\function{hd}~(\texttt{transport}_{?} a)),(\lambda\,\_, \texttt{transport}_{?} (\function{tl}~a)) \\
                               &\equiv \mathtt{transport}_?~a \\
\end{align}
Zero case \(\pi\): \((\lambda\,i, \function{zip}_\pi~0~(x,y)~i \equiv refl)\).
\begin{align}
  &\equiv () , (\lambda\,i, \function{zip}_\pi~0~(x,y)~i) \\
  &\equiv \unit , \function{refl} \\
\end{align}
successor case
\begin{align}
  &\equiv (\function{zip}_X~(m+1)~(x,y)) , (\lambda\,i, \function{zip}_\pi~(m+1)~(x,y)~i) \\
  &\equiv ((\function{hd}~x, \function{hd}~y),(\lambda\,\_,\function{zip}_X~m~(\function{tl}~x,\function{tl}~y))) , (\lambda\,i, (\function{hd}~x, \function{hd}~y),(\lambda\,\_,\function{zip}_\pi~m~(\function{tl}~x,\function{tl}~y)~i))
\end{align}
\todo[inline]{Complete this proof}

\subsection{Examples of Fixed Points}
\subsubsection{Zeros}
Let us try to define the zero stream, we do this by lifting the functions
\begin{equation}
  \function{const_X}~(n : \type{\mathbb{N}})~(c : \type{\mathbb{N}})  := \begin{cases} \unit & n = 0 \\ (c , \lambda\,\_, \function{const_X}~m~c) & n = m + 1 \end{cases}
\end{equation}
\begin{equation}
  \function{const_\pi}~(n : \type{\mathbb{N}})~(c : \type{\mathbb{N}}) := \begin{cases} \mathtt{refl} & n = 0 \\ \lambda\,i,(c , \lambda\,\_, \function{const_\pi}~m~c~i) & n = m + 1 \end{cases}
\end{equation}
to get the definition of zero stream
\begin{equation}
  \mathtt{zeros} := \function{lift_M}~\function{const_X}~\function{const_\pi}~0.
\end{equation}
We want to show that we get the expected properties, such as
\begin{align}
  \function{hd}~\mathtt{zeros} &\equiv 0 \\
  \function{tl}~\mathtt{zeros} &\equiv \mathtt{zeros}
\end{align}

\subsubsection{Spin}
We want to define spin, as being the fixed point \(\mathtt{spin} = \mathtt{later}~\mathtt{spin}\), so that is again a final coalgebra, but of a \texttt{M}-type (which is a final coalgebra)

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=huge,column sep=huge]
    \function{spin} \ar[d,"\function{later}"] \\
    \function{later}~\function{spin}
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Since it is final, it also must be unique, meaning that there is just one program that spins forever, without returning a value, meaning every other program must return a value. If we just

\section{Stream Formalization using \texttt{M}-types}
As described earlier, given a type \(\type{A}\) we define the stream of that type as
\begin{equation}
  \typeformer{stream}~\type{A} := \typeformer{M}_{\containerpair{\type{A}}{\lambda\,\_,\unit}}
\end{equation}
When taking the head of a stream, we get
\begin{align}
  \function{hd}~(\function{cons}~x~xs) &\equiv \pi_1~\function{out}~(\function{cons}~x~xs) \\
                                       &\equiv \pi_1~\function{out}~(\function{in}~(x , \lambda\,\_,xs)) \\
                                       &\equiv \pi_1~(x , \lambda\,\_,xs) \\
                                       &\equiv x
\end{align}
and similarly for the tail of the stream
\begin{align}
  \function{tl}~(\function{cons}~x~xs) &\equiv \pi_2~\function{out}~(\function{cons}~x~xs) \\
                                       &\equiv \pi_2~\function{out}~(\function{in}~(x , \lambda\,\_,xs)) \\
                                       &\equiv \pi_2~(x , \lambda\,\_,xs) \\
                                       &\equiv xs
\end{align}
and the other direction is also true
\begin{align}
  \function{cons}(\function{hd}~s , \function{tl}~s) &\equiv \function{in}~(\function{hd}~s , \function{tl}~s) \\
                                                     &\equiv \function{in}~(\pi_1~(\function{out}~s) , \pi_2~(\function{out}~s)) \\
                                                     &\equiv \function{in}~(\function{out}~s) \\
                                                     &\equiv s.
\end{align}
When forming elements of the \texttt{M}-type, we want to do it by lifting it though the definition of the \texttt{M}-type, meaning we want to define a function \(\function{cons'} : (\type{\mathbb{N}} \rightarrow \type{A}) \rightarrow \typeformer{stream}~\type{A}\) as
\begin{equation}
  \function{cons'} f = \function{lift_M}~(\lambda\,c\,n, f~c)
\end{equation}
\begin{equation}
  \function{cons'} f = \function{lift_M}~(\lambda\,c\,n, f~c)
\end{equation}

\section{ITrees as \texttt{M}-types}
We want the following rules for ITrees
\begin{equation}
  \infer[\mathtt{I}_{\function{Ret}}]{\function{Ret}~\term{r} : \typeformer{itree}~\typeformer{E}~\type{R}}{r : \type{R}}
\end{equation}
\begin{equation}
  \infer[\mathtt{I}_{\function{Vis}}]{\function{Vis}~\term{a}~\term{f} : \typeformer{itree}~\typeformer{E}~\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \typeformer{E}~\type{A} & \term{f} : \type{A} \rightarrow \typeformer{itree}~\typeformer{E}~\type{R}}.
\end{equation}
Elimination rules
\begin{equation}
  \infer[\mathtt{E}_{\function{Tau}}]{\function{Tau}~\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}{\term{t} : \typeformer{itree}~\typeformer{E}~\type{R}}.
\end{equation}

\subsection{Delay Monad}
We start by looking at itrees without the \(\function{Vis}\) constructor, this type is also know as the delay monad\todo[inline]{check this statement}. We construct this type by letting \(\container{S} = (\unit + \type{R},\lambda \{ \texttt{inl}~\_ \rightarrow \unit~;~\texttt{inr}~\_ \rightarrow \empt \})\), we then get the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{x} : \unit + \type{R}} \lambda \{ \texttt{inl}~\_ \rightarrow \unit ; \texttt{inr}~\_ \rightarrow \empt\}~\term{x} \rightarrow \type{X},
\end{equation}
which is equal to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R} \times (\empt \rightarrow \type{X}).
\end{equation}
We know that \(\empt \rightarrow \type{X} \equiv \unit\), so we can reduce further to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R}
\end{equation}
meaning we get the following diagram.

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\function{now}"'] \ar[r,"\texttt{inl}"] & \type{R} + \typeformer{M}  & \typeformer{M} \ar[l,"\texttt{inr}"'] \ar[dl,"\function{later}"] \\
    & \typeformer{M} \ar[u,"\function{out}"']
  \end{tikzcd}
  \caption{Delay monad}
\end{figure}
\noindent Meaning we can define the operations \(\function{now}\) and \(\function{later}\) using \(\function{in} = \function{out}^{-1}\) together with the injections \(\mathtt{inl}\) and \(\mathtt{inr}\). \todo[inline]{(Later = Tau, Ret = Now)}

\subsection{Tree}
Now lets look at the example where we remove the \(\function{Tau}\) constructor. We let
\begin{equation}
  \container{S} = \left(\type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A}~,~\lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \} \right).
\end{equation}
This will give us the polynomial functor
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \sum_{\term{x} : \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A}} \lambda \{ \texttt{inl}~\_ \rightarrow \empt ~;~ \texttt{inr}~(\type{A},\term{e}) \rightarrow \type{A} \}~\term{x} \rightarrow \type{X},
\end{equation}
which simplifies to
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = (\type{R} \times (\empt \rightarrow \type{X})) + (\sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X})),
\end{equation}
and further
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \type{X}).
\end{equation}
We get the following diagram for the \(\functor{P}\)-coalgebra.

\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[dr,"\function{Ret}"'] \ar[r,"\texttt{inl}"] & \type{R} + \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})  & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[l,"\texttt{inr}"'] \ar[dl,"\function{Vis}"] \\
    & \typeformer{M} \ar[u,"\function{out}"]
  \end{tikzcd}
  \caption{TODO}
\end{figure}
\noindent Again we can define \(\function{Ret}\) and \(\function{Vis}\) using the \(\function{in}\) function.

\subsection{ITrees}
Now we should have all the knowledge needed to make ITrees using \texttt{M}-types. We define ITrees by the container
\begin{equation}
  \container{S} = \left( \unit+\type{R}+\sum_{\type{A}:\universe{\mathcal{U}}} (\typeformer{E}~\type{A}) ~~,~~ \lambda\left\{ \texttt{inl}~(\texttt{inl}~\_) \rightarrow \unit ~;~ \texttt{inl}~(\texttt{inr}~\_) \rightarrow \empt ~;~ \texttt{inr} (\type{A},\_)  \rightarrow \type{A} \right\} \right).
\end{equation}
Such that the (reduced) polynomial functor becomes
\begin{equation}
  \functor{P}_{\container{S}}(\type{X}) = \type{X} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} ((\typeformer{E}~\type{A}) \times (\type{A} \rightarrow \type{X}))
\end{equation}
Giving us the diagram
\begin{figure}[h]
  \centering
  \begin{tikzcd}[row sep=large,column sep=large]
    \type{R} \ar[ddrr,"\function{Ret}"'] \ar[r,"\texttt{inl}\,\circ\,\texttt{inr}"] & \typeformer{M} + \type{R} + \sum_{\type{A} : \universe{\mathcal{U}}} (\typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M})) & & \sum_{\type{A} : \universe{U}} \typeformer{E}~\type{A} \times (\type{A} \rightarrow \typeformer{M}) \ar[ll,"\texttt{inr}"'] \ar[ddl,"\function{Vis}"] \\
    & & \typeformer{M} \ar[ul,"\texttt{inl}\,\circ\,\texttt{inl}"'] \ar[d,"\function{Tau}"'] \\
    & & \typeformer{M} \ar[uul,"\function{out}"]
  \end{tikzcd}
  \caption{TODO}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Additions to the Cubical Agda Library}
\section{\(\function{\Sigma ap}\)}
\begin{equation}
  \function{\Sigma ap} : \left(\sum_{x : X} Y x \equiv \sum_{x' : X'} Y' x' \right) ~ \equiv ~ \left( \sum_{p : X \equiv X'} Y \equiv_p Y' \right)
\end{equation}
\todo[inline]{Describe the proof of this? / Is this relevant / Should it be in the appendix?}

\chapter{Conclusion}
\label{ch:conclusion}

\todo[inline]{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{Thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo[inline]{\dots}

\end{document}


\documentclass[xelatex,mathserif,serif,notheorems]{beamer} % ,notheorems
\mode<presentation>{
  %% BEAMER CONFIG %%
  \usetheme{Madrid}
  \setbeamertemplate{navigation symbols}{}
  \setbeamersize{text margin left=0.5cm,text margin right=0.5cm}
  \usefonttheme[onlymath]{serif}
}

% \usepackage[latin1]{inputenc}
\usepackage[english]{babel}
% \usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
% \usepackage{mathptmx} % Use Times New Romans as font?
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}

\usepackage{marvosym}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

%Information to be included in the title page:
\title{(Q)\texttt{M}-types and Coinduction in HoTT / CTT}
\subtitle{Master's Thesis, Computer Science}
\author{\large Lasse Letager Hansen, 201508114\\[1ex]{\small Supervisor: Bas Spitters}}
\institute{Aarhus University}
\date{\today}

\renewcommand{\insertshortauthor}{Lasse Letager Hansen}
\titlegraphic{
  \epsfig{file=logo.eps}
}

% Custom packages added:

% \usepackage{fullpage}
% \setlength\marginparwidth{0.7in}

\usepackage{todonotes} % \todo command

\usepackage{proof} % \infer command

\usepackage{tikz-cd}
\usepackage{xfrac} % \sfrac - sideways fraction


% \usepackage{mathtools} % multlined

% allow breaks in align and equation (a new page for example)
\allowdisplaybreaks

\renewcommand{\thefootnote}{\fnsymbol{footnote}} %footnote style

\usepackage{amsthm}

% \newtheoremstyle{plain}
%   {\abovedisplayskip}   % ABOVESPACE
%   {\belowdisplayskip}   % BELOWSPACE
%   {\itshape}  % BODYFONT
%   {0pt}       % INDENT (empty value is the same as 0pt)
%   {\bfseries} % HEADFONT
%   {.}         % HEADPUNCT
%   {5pt plus 1pt minus 1pt} % HEADSPACE
%   {}          % CUSTOM-HEAD-SPEC
\theoremstyle{plain} % default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}% [section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example} % [section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
% \newtheorem*{note}{Note} % Not used?
\newtheorem{case}{Case}

% Custom commands

\newcommand*{\thmref}[1]{\hyperref[thm:#1]{Theorem~\ref*{thm:#1}}} % Theorem~\ref
\newcommand*{\lemref}[1]{\hyperref[lem:#1]{Lemma~\ref*{lem:#1}}}
\newcommand*{\corref}[1]{\hyperref[cor:#1]{Corollary~\ref*{cor:#1}}}
\newcommand*{\defref}[1]{\hyperref[defn:#1]{Definition~\ref*{defn:#1}}}
\newcommand*{\figref}[1]{\hyperref[fig:#1]{Figure~\ref*{fig:#1}}}
\newcommand*{\tableref}[1]{\hyperref[table:#1]{Table~\ref*{table:#1}}}
\newcommand*{\exmpref}[1]{\hyperref[exmp:#1]{Example~\ref*{exmp:#1}}}
\newcommand*{\sectionref}[1]{\hyperref[sec:#1]{Section~\ref*{sec:#1}}}
\newcommand*{\subsectionref}[1]{\hyperref[sec:#1]{Subsection~\ref*{sec:#1}}}
\newcommand*{\chapterref}[1]{\hyperref[ch:#1]{Chapter~\ref*{ch:#1}}}

\newcommand*{\set}[1]{\left\{#1\right\}}
\newcommand*{\term}[1]{\textcolor{green!30!black}{#1}} % \textcolor{green!70!black} \textcolor{blue!80!black}
\newcommand*{\pathterm}[1]{\textcolor{green!65!red!75!black}{#1}}
\newcommand*{\type}[1]{\textcolor{magenta!90!black}{#1}}
% \newcommand*{\dependenttype}[1]{\textcolor{magenta!70!black}{#1}}
\newcommand*{\container}[1]{\textcolor{orange}{#1}}
\newcommand*{\containerpair}[2]{\ensuremath{\colorlet{savedleftcolor}{.}\color{orange}\left(\color{savedleftcolor}#1\,\textcolor{orange}{\mathbf{,}}\,#2\color{orange}\right)\color{savedleftcolor}}}
\newcommand*{\containerpairsimple}[2]{\containerpair{#1}{\lambda\,\_,\,#2}}
\newcommand*{\universe}[1]{\textcolor{orange!80!black}{#1}}
\newcommand*{\unit}{\type{\textbf{1}}}
\newcommand*{\empt}{\type{\textbf{0}}}
\newcommand*{\coalg}[2]{#1\texttt{-}#2}

\newcommand*{\relation}[1]{\textcolor{gray!75!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constant}[1]{\textcolor{orange!60!black}{\ensuremath{\mathtt{#1}}}}

\newcommand*{\function}[1]{\textcolor{blue!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\constructor}[1]{\textcolor{purple!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\destructor}[1]{\textcolor{yellow!60!black}{\ensuremath{\mathtt{#1}}}}
\newcommand*{\typeformer}[1]{\ensuremath{\mathtt{#1}}}
\newcommand*{\functor}[1]{\ensuremath{\mathbf{\mathtt{#1}}}}

\newcommand*{\unitelem}{\constant{\star}} % \constant{tt}
\newcommand*{\quotientconstructor}[1]{\constructor{[}\,#1\,\constructor{]}}

\newcommand*{\ssfrac}[2]{ {\LARGE \text{\sfrac{\ensuremath{#1}}{\ensuremath{#2}}}}}

\newcommand*{\natcases}[2]{\ensuremath{\mathbb{[\hspace{-.5mm}\rangle}~\ensuremath{#1}~,~\ensuremath{#2}~\mathbb{\langle\hspace{-.5mm}]}}}

% Concatenation of paths taken from HoTT book
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\newcommand*{\sym}[1]{\ensuremath{#1^{-1}}}

\newcommand{\setlengths}{
  \setlength{\abovedisplayskip}{4pt}
  \setlength{\belowdisplayskip}{4pt}
  \setlength{\abovedisplayshortskip}{2pt}
  \setlength{\belowdisplayshortskip}{2pt}
}
\newcommand{\startwitheq}{\vspace{-2.5mm}} % -\baselineskip

\begin{document}

\frame{\titlepage}

\section{Introduction}

\begin{frame}
  \frametitle{Overview}
  \tableofcontents[subsubsectionstyle=hide]
\end{frame}

\subsection{Background Theory}
\subsubsection{Inductive / Coinductive definitions}
\begin{frame}
  \frametitle{Inductive / Coinductive definitions}
  \framesubtitle{Inductive definition}
  We can define the natural numbers \emph{inductively} from the two constructors
  \begin{defn}[The Natural Numbers]\setlengths\startwitheq
    \strut
    \hfill
    \begin{minipage}{0.15\linewidth}
      \begin{equation}
        \vcenter{\infer{0 : \mathbb{N}}{\strut}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.225\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{succ}~n : \mathbb{N}}{n : \mathbb{N}}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{defn}
  for which we define an \emph{inductive} equivalence relation
  \begin{defn}[Equivalence for the Natural Number]\setlengths\startwitheq
    \strut
    \hfill
    \begin{minipage}{0.225\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sim_{0}}]{0 = 0}{\strut}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\linewidth}
      \begin{equation}
        \vcenter{\infer[\constructor{\sim_{succ}}]{\constructor{succ}~n~\relation{\sim_{\mathbb{N}}}~\constructor{succ}~m}{n~\relation{\sim_{\mathbb{N}}}~m}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{defn}
  which is also an equality relation.
\end{frame}

\begin{frame}
  \frametitle{Inductive / Coinductive definitions}
  \framesubtitle{Coinductive definition}
  We can define streams coinductively from the two constructors
  \begin{defn}[Stream]\setlengths\startwitheq
    \strut
    \hfill
    \begin{minipage}{0.275\linewidth}
      \begin{equation}
        \vcenter{\infer{\destructor{hd}~\term{s} : \type{A}}{\term{s} : \typeformer{stream}~\type{A}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}{0.3\linewidth}
      \begin{equation}
        \vcenter{\infer{\destructor{tl}~\term{s}: \typeformer{stream}~\type{A}}{\term{s} : \typeformer{stream}~\type{A}}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{defn}
  for which we can coinductively define an equivalence relation
  \begin{defn}[Equivalence for Streams]\setlengths %\startwitheq
    \begin{equation}
      \vcenter{\infer{\term{s}~\relation{\sim_{stream}}~\term{t}}{\destructor{hd}~\term{s} = \destructor{hd}~\term{t} & \destructor{tl}~\term{s}~\relation{\sim_{stream}}~\destructor{tl}~\term{t}}}
    \end{equation}
  \end{defn}
  however, this bisimulation does not give us equality.
\end{frame}

\subsubsection{Univalent Foundations}
\begin{frame}
  \frametitle{Univalent Foundations}
  \framesubtitle{The Univalence Axiom}
  The univalence axiom says that equivalence is equivalent to equality
  \begin{defn}[Univalence]\setlengths\startwitheq
    \begin{equation}
      (\type{A} = \type{B}) \simeq (\type{A} \simeq \type{B})
    \end{equation}
  \end{defn}
  so if we work in a type theory where this holds, then \(\relation{\sim_{stream}}\) becomes an equality relation for streams.
\end{frame}

\subsubsection{Homotopy Type Theory (HoTT)}
\begin{frame}
  \frametitle{Homotopy Type Theory (HoTT)}
  % \framesubtitle{HoTT}
  Homotopy Type Theory (HoTT)
  \begin{itemize}
  \item is an intensional dependent type theory (builts on MLTT)
  \item assumes the univalence axiom
  \item has higher inductive types (HITs)
  \end{itemize}
  Types can be seen as spaces and elements as points of a space, meaning we get non-trivial equalities, that is equalities that are not reflexivity. As such we can construct higher inductive types, where we have both point and equality constructors.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Cubical Type Theory (CTT)}
  HoTT is constructive, however the univalence axiom is not, since it is an axiom. We therefore use a Cubical Type Theory, where we can prove the univalence axiom and get constructivity. Cubical Type Theory is named after the composition principle, where given all but one side of a square, we get the entire square.
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \type{A} \ar[r,"\pathterm{p} \ct \pathterm{q} \ct \pathterm{r}",dashed] & \type{B} \\
      \type{C} \ar[u,"\pathterm{p}^{-1}"] \ar[r,"\pathterm{q}"'] & \type{D} \ar[u,"\pathterm{r}"']
    \end{tikzcd}
    \caption{Composition square}
    \label{fig:cubical-composition-square}
  \end{figure}
  This work has been formalized using the Cubical Agda proof assistant.
\end{frame}

\begin{frame}
  \frametitle{H-Levels}
  HoTT is proof relevant, so we can have two proofs of a statement that might not be equal. Types in HoTT is classified in H-levels starting at -2.
  \begin{itemize}
  \item[\((-2)\)] Contractible types, with an element equal to all other elements
  \item[\((-1)\)] Mere propositions / hProp, all elements in a type are equal, but the type might not be inhabited.
  \item[\((0)\)] hSets, given two elements, then all equalities between the two elements are equal.
    \\
    \strut\hspace{-5mm}\(\vdots\)
  \item[\((n)\)] all equalities at H-level \((n+1)\) are equal.
  \end{itemize}
\end{frame}

\subsubsection{Propositional Truncation}
\begin{frame}
  \frametitle{Propositional Truncation}
  We can truncate types to H-level \((-1)\) with propositional truncation, defined as the following HIT
  \begin{defn}[Propositional Truncation]\setlengths\startwitheq
    \strut
    \hfill
    \begin{minipage}[b]{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{|}\,\term{x}\,\constructor{|} : \| \type{A} \|}{\term{x} : \type{A}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.4\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{squash}~\term{x}~\term{y} : \term{x} \equiv \term{y}}{\term{x}, \term{y} : \|\type{A}\|}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
  \end{defn}
  which removes the proof relevance, since  when truncated all proofs of a statement only states that the type is inhabited.
\end{frame}

\subsubsection{Set Truncated Quotients}
\begin{frame}
  \frametitle{Set Truncated Quotients}
  We can define quotients as by the following HIT.
  \begin{defn}[Set truncated quotient]\setlengths \startwitheq
    \strut
    \hfill
    \begin{minipage}[b]{0.25\linewidth}
      \begin{equation}
        \vcenter{\infer{\quotientconstructor{\term{x}} : \type{A} / \relation{\mathcal{R}}}{\term{x} : \type{A}}}
      \end{equation}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.4\linewidth}
      \begin{equation}
        \vcenter{\infer{\constructor{eq/}~\term{x}~\term{y}~\term{r} : \term{x} \equiv \term{y}}{\term{x}, \term{y} : \type{A} / \relation{\mathcal{R}} & \term{r} : \term{x}~\relation{\mathcal{R}}~\term{y}}}
      \end{equation}
    \end{minipage}
    \hfill
    \strut
    \begin{equation}
      \vcenter{\infer{\constructor{squash/} :\texttt{isSet}~(\type{A} / \relation{R})}{\strut}}
    \end{equation}
  \end{defn}
\end{frame}

\subsubsection{Axiom of Choice}
\begin{frame}
  \frametitle{Axiom of Choice}
  The axiom of choice in HoTT
  \begin{defn}[Axiom of Choice]\setlengths
    \begin{equation}
      \prod_{(\term{x} : \type{X})} \big\| \typeformer{Y}~\term{x} \big\| \rightarrow \bigg\| \prod_{(\term{x} : \type{X})} \typeformer{Y}~\term{x} \bigg\|
    \end{equation}
  \end{defn}
  and the axiom of countable choice
  \begin{defn}[Axiom of countable choice]\setlengths
    \begin{equation}
      \prod_{(n : \mathbb{N})} \big\| \typeformer{Y}~n \big\| \rightarrow \bigg\| \prod_{(n : \mathbb{N})} \typeformer{Y}~n \bigg\|
    \end{equation}
  \end{defn}
\end{frame}

\section{\texttt{M}-types}

\begin{frame}
  \frametitle{Overview}
  \tableofcontents[currentsection,subsubsectionstyle=hide]
\end{frame}

\subsection{Defining \texttt{M}-types}
\subsubsection{Containers and Polynomial functors}
\begin{frame}
  \frametitle{Containers and Polynomial functors}
  \begin{defn}\setlengths
    A Container (or signature) is a dependent pair \(\container{S} = \containerpair{\type{A}}{\typeformer{B}}\) for the types \(\type{A} : \universe{\mathcal{U}}\) and \(\typeformer{B} : \type{A} \rightarrow \universe{\mathcal{U}}\). 
  \end{defn}
  \begin{defn}\setlengths
    A polynomial functor \(\functor{P}_{\container{S}}\) (or extension) for a container \(\container{S} = \containerpair{\type{A}}{\typeformer{B}}\) is defined, for types as
    \begin{equation}
      \begin{aligned}
        &\functor{P}_{\container{S}} : \universe{\mathcal{U}} \rightarrow \universe{\mathcal{U}} \\
        &\functor{P}_{\container{S}}\,\type{X} = \sum_{(\term{a} : \type{A})} \typeformer{B}\term{a} \rightarrow \type{X}
      \end{aligned}
    \end{equation}
    and for a function \(\function{f} : \type{X} \rightarrow \type{Y}\) as
    \begin{equation}
      \begin{aligned}
        &\functor{P}_{\container{S}}\,\function{f} : \functor{P}_{\container{S}}\type{X} \rightarrow \functor{P}_{\container{S}}\type{Y} \\
        &\functor{P}_{\container{S}}\,\function{f}~(\term{a},\function{g}) = (\term{a}, \function{f} \circ \function{g}).
      \end{aligned}
    \end{equation}
  \end{defn}
\end{frame}

\subsubsection{Coalgebra}
\begin{frame}
  \frametitle{Coalgebra}
  \begin{defn}\setlengths
    A \(\functor{P}_{\container{S}}\)-coalgebra is defined as
    \begin{equation}
      \typeformer{Coalg}_{\container{S}} = \sum_{(\type{C} : \universe{\mathcal{U}})} \type{C} \rightarrow \functor{P}_{\container{S}}\type{C}.
    \end{equation}
    where we denote a \(\functor{P}_{\container{S}}\)-coalgebra given by a type \(\type{C}\) and function \(\function{\gamma}\) as \(\coalg{\type{C}}{\function{\gamma}}\). Coalgebras morphisms are defined as
    \begin{equation}
      \begin{aligned}
        \coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{D}}{\function{\delta}} &= \sum_{(\function{f} : \type{C} \rightarrow \type{D})} \function{\delta} \circ \function{f} = \functor{P} \function{f} \circ \function{\gamma}
      \end{aligned}
    \end{equation}
  \end{defn}
\end{frame}

\subsubsection{Finality and Requirements of M-types}
\begin{frame}
  \frametitle{Final Coalgebra}
  \begin{defn}[Final Coalgebra / \texttt{M}-type]\setlengths
    A final coalgebra \(\coalg{\type{X}}{\function{\rho}}\), is a coalgebra that fulfills
    \begin{equation}
      \typeformer{Final}_{\container{S}} := \sum_{(\coalg{\type{X}}{\function{\rho}} : \mathtt{Coalg}_{\container{S}})} \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{X}}{\function{\rho}}).
    \end{equation}
    \label{defn:M-type-final-def}
    We define \texttt{M}-types as the coinductive type that fulfill the property
    \begin{equation}
      \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\typeformer{M}_{\container{S}}}{\function{out}})
    \end{equation}
    We denote \texttt{M}-types as \(\typeformer{M}_{\containerpair{\type{A}}{\typeformer{B}}}\), \(\typeformer{M}_{\container{S}}\) or just \(\typeformer{M}\) when the container is clear from the context.
  \end{defn}
\end{frame}

\subsubsection{Chain and Limits}
\begin{frame}[fragile]
  \frametitle{Chain}
  \begin{defn}[Chain]\setlengths
    We define a chain as a family of morphisms \(\function{\pi}_{(n)} : \type{X}_{n+1} \rightarrow \type{X}_{n}\), over a family of types \(\type{X}_{n}\). See figure.
  \end{defn}
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"]
    \end{tikzcd}
    \caption{Chain of types / functions}
    \label{fig:x-chain}
  \end{figure}
  \begin{defn}\setlengths
    The limit of a chain is given as
    \begin{equation}
      \type{\mathcal{L}} = \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n)} \prod_{(n : \mathbb{N})} (\function{\pi}_{(n)}~\term{x}_{n+1} \equiv \term{x}_n)
    \end{equation}
  \end{defn}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Helper Lemmas}
  \begin{lem}[Limit Collapse]\setlengths
    \label{lem:limit-collapse}
    Given \(\function{\ell} : \prod_{(n : \mathbb{N})} (\type{X}_{n} \rightarrow \type{X}_{n+1})\) and \(\term{y} : \sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) we get the equality \(\type{\mathcal{L}} \equiv \type{X}_0\).
  \end{lem}
  \begin{lem}[Cone and function to \texttt{M}-type equality]\setlengths
    \label{lem:function-to-M-type-is-cone}
    For all coalgebras \(\coalg{\type{C}}{\function{\gamma}}\) defined over the container \(\container{S}\), we get \(\type{C} \rightarrow \typeformer{M}_{\container{S}} \equiv \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\), where \(\typeformer{Cone} = \sum_{(\function{f} : \prod_{(n : \mathbb{N})} \type{C} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{f}_{n+1} \equiv \function{f}_n\). (See figure)
  \end{lem}
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{X}_0 & \type{X}_1 \ar[l,"\function{\pi}_{(0)}"] & \cdots \ar[l,"\function{\pi}_{(1)}"] & \type{X}_n \ar[l,"\function{\pi}_{(n-1)}"] & \type{X}_{n + 1} \ar[l,"\function{\pi}_{(n)}"] & \cdots \ar[l,"\function{\pi}_{(n+1)}"] \\
      & & \type{C} \ar[ull,"\function{f}_0"] \ar[ul,"\function{f}_1"'] \ar[u,draw=none,"\cdots" description] \ar[ur,"\function{f}_n"] \ar[urr,"\function{f}_{n+1}"'] \ar[urrr,draw=none,"\cdots"'] & 
    \end{tikzcd}
    \caption{Cone}
    \label{fig:M-seq-cone}
  \end{figure}
\end{frame}

\begin{frame}<presentation:0>[noframenumbering] % proof frame hidden
  \frametitle{Helper Lemmas}
  \framesubtitle{Proof of Limit Collapse}
    \begin{proof}\setlengths
    We define the equality by the following isomorphism
    \begin{align}
      &\function{fun}_{\pathterm{\mathcal{L}collapse}}~(\term{x} , \pathterm{r}) = \term{x}_0 \\[-1mm]
      &\function{inv}_{\pathterm{\mathcal{L}collapse}}~\term{x}_0 = (\lambda\,n,~\function{\ell}^{(n)}~\term{x}_0)~,~(\lambda\,n,~\mathtt{refl}_{(\function{\ell}^{(n+1)}\,\term{x}_0)}) \\[-1mm]
      &\function{rinv}_{\pathterm{\mathcal{L}collapse}}~\term{x}_0 = \mathtt{refl}_{\term{x}_0}
    \end{align}
    where \(\function{\ell}^{(n)} = \function{\ell}_n \circ \function{\ell}_{n-1} \circ \dots \circ \function{\ell}_1 \circ \function{\ell}_0\). To define \(\function{linv}_{\pathterm{\mathcal{L}collapse}}~(\term{x} , \pathterm{r})\), we first define a fiber \((\type{X} , \term{z}, \function{\ell})\) over \(\mathbb{N}\) given some \(\term{z} : \type{X}_0\). Then any element of the type \(\sum_{\left(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_n\right)} \term{x}_{n + 1} \equiv \function{\ell}_n~\term{x}_n\) is equal to a section over the fiber we defined. This means \(\term{y}\) is equal to a section. Since the sections are defined over \(\mathbb{N}\), which is an initial algebra for the functor \(\functor{G}\type{Y} = \unit + \type{Y}\), we get the sections are contractible. This means \(\term{y} \equiv \function{inv}_{\pathterm{\mathcal{L}collapse}} (\function{fun}_{\pathterm{\mathcal{L}collapse}}~\term{y})\) by uniqueness argument, since both sides of the equality are equal to sections over \(\mathbb{N}\).
  \end{proof}
\end{frame}

\begin{frame}<presentation:0>[noframenumbering] % proof frame hidden
  \frametitle{Helper Lemmas}
  \framesubtitle{Proof of Cone and function to \texttt{M}-type equality}
  \begin{proof}\setlengths
    We show the equality between \(\type{C} \rightarrow \typeformer{M}_{\container{S}}\) and \(\typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\) as an isomorphism
    \begin{align}
      &\function{fun}_{\pathterm{collapse}}~\function{f} = (\lambda\,n\,\term{z},\pi_1~(\function{f}~\term{z})~n),(\lambda\,n~i~\term{a},~\pi_2~(\function{f}~\term{a})~n~i) \\
      &\function{inv}_{\pathterm{collapse}}~(\function{u},\function{q})~\term{z} = (\lambda\,n,~\function{u}~n~\term{z}),(\lambda\,n\,i,~\function{q}~n~i~\term{z}) \\
      &\function{rinv}_{\pathterm{collapse}}~(\function{u},\function{q}) = \mathtt{refl}_{(\function{u},\function{q})} \\
      &\function{linv}_{\pathterm{collapse}}~\function{f} = \mathtt{refl}_{\function{f}}
    \end{align}
  \end{proof}
\end{frame}

\subsubsection{Equality between \(\type{\mathcal{L}}\) and \(\functor{P}\,\type{\mathcal{L}}\)}
\begin{frame}
  \frametitle{Equality between \(\type{\mathcal{L}}\) and \(\functor{P}\,\type{\mathcal{L}}\)}
  \begin{thm}\setlengths
    Given a container \(\containerpair{\type{A}}{\typeformer{B}}\), we define a chain as the repeated application of \(\functor{P}\) to the unit element \(\type{X}_n = \functor{P}^n\,\unit\), and \(\function{\pi}_{(n)} = \functor{P}^n\,\constant{!}\) where \(\constant{!} : A \rightarrow \unit\) is the unique function into the unit type. Then there is an equality
    \begin{equation}
      \pathterm{shift} : \type{\mathcal{L}} \equiv \functor{P}\type{\mathcal{L}}
    \end{equation}
    where \(\type{\mathcal{L}}\) is the limit of this chain.
  \end{thm}
  \begin{block}{Proof structure}\setlengths
    The proof is done using the two helper lemmas
    \begin{align}
      \pathterm{\alpha} : \type{\mathcal{L}}^{\functor{P}} \equiv \functor{P}\,\type{\mathcal{L}} \\
      \pathterm{\mathcal{L}unique} : \type{\mathcal{L}} \equiv \type{\mathcal{L}}^{\functor{P}}
    \end{align}
    where \(\type{\mathcal{L}}^{\functor{P}}\) is the limit of the shifted chain defined as \(\type{X'}_n = \type{X}_{n+1}\) and \(\function{\pi'}_{(n)} = \function{\pi}_{(n+1)}\). With these two lemmas we get \(\pathterm{shift} = \pathterm{\alpha} \ct \pathterm{\mathcal{L}unique}\).
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Proof of uniqueness}
  \(\pathterm{\mathcal{L}unique}\) says the limit of a chain is unique.
  \begin{proof}\setlengths
  The proof of the equality \(\pathterm{\mathcal{L}unique}\) is given by the isomorphism
    \begin{align}
      \function{fun}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \natcases{\unitelem}{\function{a}} , \natcases{\mathtt{refl}_{\unitelem}}{\function{b}} \\
    \function{inv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \function{a} \circ \constructor{succ}~,~\function{b} \circ \constructor{succ} \\
    \function{rinv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})} \\
    \function{linv}_{\pathterm{\mathcal{L}unique}}~(\function{a} , \function{b}) &= \mathtt{refl}_{(\function{a},\function{b})}
    \end{align}
  \end{proof}
\end{frame}

\begin{frame}
  \frametitle{Proof of equality to shifted chain}
  \begin{proof}\setlengths
    The proof of \(\pathterm{\alpha}\) is given by the equalities
    \begin{align}
      \type{\mathcal{L}}^{\functor{P}} &\equiv \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \type{X}_{n+1})} \prod_{(n : \mathbb{N})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \\
      &\equiv \hspace{-6mm} \sum_{(\term{x} : \prod_{(n : \mathbb{N})} \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n+1)}~\term{x}_{n+1} \equiv \term{x}_{n} \label{eq:alpha-unfold}\\
      &\equiv \hspace{-10mm} \sum_{(\sum_{(\term{a} : \prod_{(n : \mathbb{N})} \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n)} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,\term{a}_n \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv_* \function{u}_n \label{eq:alpha-swap}\\
      &\equiv \sum_{(\term{a} : \type{A})} \sum_{(\function{u} : \prod_{(n : \mathbb{N})} \typeformer{B}\,a \rightarrow \type{X}_n)} \prod_{(n : \mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n \label{eq:alpha-limit-collapse} \\
      &\equiv \sum_{(\term{a} : \type{A})} \typeformer{B}\,\term{a} \rightarrow \type{\mathcal{L}} \label{eq:alpha-cone} \qquad \equiv \functor{P}\type{\mathcal{L}}
    \end{align}
    ~\\[-6mm]
  \end{proof}
  % TODO: Hints!
  % The equality from \eqref{eq:alpha-unfold} to \eqref{eq:alpha-swap} is rearranging terms, and adding a trivial point to the start of for the shifted chain. The equality from \eqref{eq:alpha-swap} and \eqref{eq:alpha-limit-collapse} is done with \lemref{limit-collapse} to collapse \(\sum_{(\term{a} : \mathbb{N} \rightarrow \type{A})} \prod_{(n : \mathbb{N})} \term{a}_{n+1} \equiv \term{a}_n\) to \(\type{A}\). For the equality between \eqref{eq:alpha-limit-collapse} and \eqref{eq:alpha-cone}, we use \lemref{function-to-M-type-is-cone}. The rest of the equalities are trivial.
\end{frame}

\begin{frame}
  \frametitle{In and Out of \texttt{M}-types}
  We define functions to construct and destruct \texttt{M}-types
  \begin{defn}\setlengths
    For the equality \(\pathterm{shift}\) we denote the functions back and forth as
    \begin{align}
      \function{out} &= \mathtt{transport}~\pathterm{shift} \\
      \function{in} &= \mathtt{transport}~\sym{\pathterm{shift}}.
    \end{align}
  \end{defn}
  This gives us the following diagram
  \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \functor{P}\,\typeformer{M}_{\container{S}} \ar[d,shift left,"\function{in}"] \\
      \typeformer{M}_{\container{S}} \ar[u,shift left,"\function{out}"]
    \end{tikzcd}
    \caption{\texttt{M}-type diagram}
  \end{figure}
\end{frame}

\subsubsection{Example: Streams}
\begin{frame}[fragile]
  \frametitle{Example: Streams}
  We can now define streams for a given type \(\type{A}\)
  \begin{defn}\setlengths
    We start with a container
    \begin{equation}
      \containerpair{\type{A}}{\unit}
    \end{equation}
    For which we get the polynomial functor
    \begin{equation}
      \functor{P}\,\type{X} = \type{A} \times \type{X}
    \end{equation}
    For which the we get the \texttt{M}-type for stream
    \begin{equation}
      \typeformer{Stream}~\type{A} = \type{A} \times \typeformer{Stream}~\type{A}
    \end{equation}
  \end{defn}
    \begin{figure}[h]
    \centering
    \begin{tikzcd}
      \type{A} \ar[dr,"\destructor{hd}"'] & \type{A} \times \typeformer{Stream}~\type{A} \ar[d,shift left,"\function{in}"] \ar[l,"\pi_1"'] \ar[r,"\pi_2"] & \typeformer{Stream}~\type{A} \ar[dl,"\destructor{tl}"] \\
      & \typeformer{Stream}~\type{A} \ar[u,shift left,"\function{out}"]
    \end{tikzcd}
    \caption{Streams}
  \end{figure}
\end{frame}

\subsubsection{\texttt{M}-types are final}
\begin{frame}
  \frametitle{\texttt{M}-types are final}
  \begin{thm}\setlengths
    The \texttt{M}-type \(\typeformer{M}_{\container{S}}\) is defined as the limit for a polynomial functor \(\functor{P}_{\container{S}}\). This definition fulfills the requirement that \(\typeformer{Final}_{\container{S}}~\type{\mathcal{L}}\).
  \end{thm}
  \begin{block}{Proof.}\setlengths
    By unfolding the definition, we need to show
    \begin{equation}
      \prod_{(\coalg{\type{C}}{\function{\gamma}} : \mathtt{Coalg}_{\container{S}})} \mathtt{isContr}~(\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}})
    \end{equation}
    We do this by showing \((\coalg{\type{C}}{\function{\gamma}} \Rightarrow \coalg{\type{\mathcal{L}}}{\function{out}}) \equiv \unit\). We get
    \begin{align}
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{out} \circ \function{f} \equiv \functor{P}\function{f} \circ \function{\gamma}) \\[-2mm]
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{in} \circ \function{out} \circ \function{f} \equiv \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}) \\[-2mm]
      &\equiv \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{in} \circ \functor{P}\function{f} \circ \function{\gamma})
    \end{align}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \begin{block}{Proof. (cont.)}\setlengths
    We now let \(\function{\psi} = \function{in} \circ \functor{P}\function{f} \circ \function{\gamma}\), which simplifies the expression to
    \begin{equation}
      \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{\psi}~\function{f})
    \end{equation}
    We then define \(\function{e}\) to be the function from right to left for the equality \(\type{C} \rightarrow \type{\mathcal{L}} \equiv \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}}\), this gives us the equality
    \begin{equation}
      \sum_{(\function{f} : \type{C} \rightarrow \type{\mathcal{L}})} (\function{f} \equiv \function{\psi}~\function{f}) \quad \equiv \quad \sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\function{e}~\term{c} \equiv \function{\psi}~(\function{e}~\term{c}))
    \end{equation}
    By defining a function \(\function{\phi}~(\function{u},\function{g}) = (\function{\phi}_0~\function{u},\function{\phi}_1~\function{u}~\function{g})\) where
    \begin{align}
      \function{\phi}_0~\function{u} &= \natcases{(\lambda\,\_, \unitelem)}{\functor{P}\function{f} \circ \function{\gamma} \circ \function{u}} \\
      \function{\phi}_1~\function{u}~\function{g} &= \natcases{\mathtt{funExt}~(\lambda\,\_, \mathtt{refl}_{\unitelem})}{\mathtt{ap}~(\functor{P}\function{f} \circ \function{\gamma}) \circ \function{g}}
    \end{align}
    we get the commuting square\vspace{-4.5mm}
    \begin{figure}
      \centering
      \begin{tikzcd}
        \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \ar[d,"\function{\phi}"] \ar[r,"\function{e}"] & (\type{C} \rightarrow \type{\mathcal{L}}) \ar[d,"\function{\psi}"] \\
        \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}} \ar[r,"\function{e}"] & (\type{C} \rightarrow \type{\mathcal{L}})
      \end{tikzcd}
    \end{figure}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Proof. (cont.)}\setlengths
    We can then simplify to
    \begin{equation}
      \sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\function{e}~\term{c} \equiv \function{e}~(\function{\phi}~\term{c}))
    \end{equation}
    We unfolding the definition of \(\function{\phi}\), to get the equalities
    \begin{align}
      &\quad~\sum_{(\term{c} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} (\term{c} \equiv \function{\phi}~\term{c}) \\
      &\equiv \sum_{(\term{(\function{u},\function{g})} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} ((\function{u},\function{g}) \equiv (\function{\phi}_0~\function{u},\function{\phi}_1~\function{u}~\function{g})) \\
      &\equiv \sum_{(\term{(\function{u},\function{g})} : \typeformer{Cone}_{\coalg{\type{C}}{\function{\gamma}}})} \sum_{(\pathterm{p} : \function{u} \equiv \function{\phi}_0\,\function{u})} \function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}
    \end{align}
    We rearrange the terms and unfold the definition of \(\typeformer{Cone}\) to get
    \begin{equation}
      \sum_{\big(\term{(\function{u},\pathterm{p})} : \sum_{(\function{u} : \prod_{(n:\mathbb{N})} \type{C} \rightarrow \type{X}_n)} \function{u} \equiv \function{\phi}_0\,\function{u}\big)} \sum_{(\function{g} : \prod_{(n:\mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n)}\function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}
    \end{equation}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Proof. (cont.)}
  We define the following two equalities as instances of the limit collapse equality \(\type{\mathcal{L}} \equiv \type{X}_0\).
    \begin{align}
      \unit &\equiv \left(\sum_{(\function{u} : \prod_{(n:\mathbb{N})} \type{C} \rightarrow \type{X}_n)} \function{u} \equiv \function{\phi}_0\,\function{u}\right)  \\
      \unit &\equiv_{*} \left(\sum_{(\function{g} : \prod_{(n:\mathbb{N})} \function{\pi}_{(n)} \circ \function{u}_{n+1} \equiv \function{u}_n)}\function{g} \equiv_{*} \function{\phi}_1~\function{u}~\function{g}\right)
    \end{align}
    Using these two equalities, the proof simplifies to
    \begin{equation}
      \sum_{(\unitelem : \unit)} \unit \equiv \unit
    \end{equation}
    which is trivial. \qed
  \end{block}
\end{frame}

\subsection{Coinduction Principle}
\begin{frame}[fragile]
  \frametitle{Bisimulation}
  \begin{defn}\setlengths
    A relation \(\relation{\mathcal{R}} : \type{C} \rightarrow \type{C} \rightarrow \universe{\mathcal{U}}\) for a coalgebra \(\coalg{\type{C}}{\function{\gamma}} : \typeformer{Coalg}_{\container{S}}\), is a (strong) bisimulation relation if the type \(\type{\overline{\mathcal{R}}} = \sum_{(\term{a} : \type{C})} \sum_{(\term{b} : \type{C})} \term{a}~\relation{\mathcal{R}}~\term{b}\) and the function \(\function{\alpha}_{\relation{\mathcal{R}}} : \type{\overline{\mathcal{R}}} \rightarrow \functor{P}_{\container{S}}\,\type{\overline{\mathcal{R}}}\) forms a \(\functor{P}_{\container{S}}\)-coalgebra \(\coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} : \mathtt{Coalg}_{\container{S}}\), making the diagram bellow commute (\(\Longrightarrow\) represents \(\functor{P}_{\container{S}}\)-coalgebra morphisms). That is
    \begin{equation}
      \function{\gamma} \circ \pi_1^{\type{\overline{\mathcal{R}}}} \equiv \functor{P}_{\container{S}}\,\pi_1^{\type{\overline{\mathcal{R}}}} \circ \function{\alpha}_{\relation{R}}
    \end{equation}
    and similarly for \(\pi_2^{\type{\overline{\mathcal{R}}}}\).
  \end{defn}
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=huge,column sep=huge]
      \coalg{\type{C}}{\function{\gamma}} & \coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\type{C}}{\function{\gamma}}
    \end{tikzcd}
  \end{figure}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Coinduction Principle}
  \begin{thm}[Coinduction principle]\setlengths
    Given a relation \(\relation{\mathcal{R}}\), that is a bisimulation for a \texttt{M}-type, then (strongly) bisimilar elements \(\term{x}~\relation{\mathcal{R}}~\term{y}\) are equal \(\term{x} \equiv \term{y}\).
  \end{thm}
  \begin{proof}\setlengths
    Given a relation \(\relation{\mathcal{R}}\) that is bisimulation relation over a final \(\functor{P}\)-coalgebra \(\coalg{\typeformer{M}}{\function{out}}:\mathtt{Coalg}_{\container{S}}\) we get the diagram
    \begin{figure}[h]
      \centering
      \begin{tikzcd}[row sep=huge,column sep=huge]
        \coalg{\typeformer{M}}{\function{out}} & \coalg{\type{\overline{\mathcal{R}}}}{\function{\alpha}_{\relation{\mathcal{R}}}} \ar[l,Rightarrow,"{\pi_1}^{\type{\overline{\mathcal{R}}}}"'] \ar[r,Rightarrow,"{\pi_2}^{\type{\overline{\mathcal{R}}}}"] & \coalg{\typeformer{M}}{\function{out}}
      \end{tikzcd}
    \end{figure}
    By the finality of \(\coalg{\typeformer{M}}{\function{out}}\), we get a function \(\constant{!}\) from \(\typeformer{M}\) to \(\type{\overline{R}}\), which is unique, meaning \(\pi_1^{\type{\overline{\mathcal{R}}}} \equiv ~\constant{!} \equiv \pi_2^{\type{\overline{\mathcal{R}}}}\). Now given \(\term{r} : \term{x}~\relation{\mathcal{R}}~\term{y}\), we can construct the equality
    \begin{equation}
      \term{x} \equiv \pi_1^{\type{\overline{\mathcal{R}}}} (\term{x}, \term{y}, \term{r}) \equiv \pi_2^{\type{\overline{\mathcal{R}}}} (\term{x}, \term{y}, \term{r}) \equiv \term{y},
    \end{equation}
    giving us the coinduction principle for \texttt{M}-types.
  \end{proof}  
\end{frame}

\subsection{Examples of \texttt{M}-types}
\begin{frame}[fragile]
  \frametitle{Example: Delay Monad}
  We define a container
  \begin{equation}
    \containerpair{\type{R} + \unit}{[\empt, \unit]}
  \end{equation}
  and a polynomial functor
  \begin{equation}
    \functor{P}\,\type{X} = \sum_{(\term{x} : \type{R} + \unit)} \begin{cases} \empt & \term{x} = \mathtt{inl}~\term{r} \\ \unit & \term{x} = \mathtt{inr}~\unitelem \end{cases} \rightarrow \type{X},
  \end{equation}
  which simplifies to
  \begin{equation}
    \functor{P}_{\container{S}}\,\type{X} = \type{R} + \type{X}
  \end{equation}
  such that we get the diagram
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{R} \ar[dr,"\constructor{now}"'] \ar[r,"\texttt{inl}"] & \type{R} + \typeformer{Delay}~\type{R} \ar[d,shift left,"\function{in}"] & \typeformer{Delay}~\type{R} \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{later}"] \\
      & \typeformer{Delay}~\type{R} \ar[u,shift left,"\function{out}"]
    \end{tikzcd}
  \end{figure}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: Event Trees}
  \begin{defn}\setlengths
    We define a container
    \begin{equation}
      \containerpair{\type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} \typeformer{E}\,\type{A}}{[\empt, \type{A}]}.
    \end{equation}
    and a polynomial functor which simplifies to
    \begin{equation}
      \functor{P}\,\type{X} = \type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \type{X}).
    \end{equation}
  \end{defn}
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=small]
      \type{R} \ar[dr,"\constructor{leaf}"'] \ar[r,"\texttt{inl}"] & \type{R} + \sum_{(\type{A} : \universe{U})} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{T}~\typeformer{E}~\type{R}) \ar[d,shift left,"\function{in}"]  & \sum_{(\type{A} : \universe{U})} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{T}~\typeformer{E}~\type{R}) \ar[l,"\texttt{inr}"'] \ar[dl,"\constructor{node}"] \\
      & \typeformer{T}~\typeformer{E}~\type{R} \ar[u,shift left,"\function{out}"]
    \end{tikzcd}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{Example: Interaction Trees (ITrees)}
  \begin{equation}
    \vcenter{\infer[\mathtt{I}_{\constructor{Ret}}]{\constructor{Ret}~\term{r} : \typeformer{itree}~\typeformer{E}\,\type{R}}{r : \type{R}}}
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{I}_{\constructor{Vis}}]{\constructor{Vis}~\term{a}~\term{f} : \typeformer{itree}~\typeformer{E}\,\type{R}}{\type{A} : \universe{\mathcal{U}} & \term{a} : \typeformer{E}\,\type{A} & \term{f} : \type{A} \rightarrow \typeformer{itree}~\typeformer{E}\,\type{R}}}.
  \end{equation}
  \begin{equation}
    \vcenter{\infer[\mathtt{E}_{\constructor{Tau}}]{\constructor{Tau}~\term{t} : \typeformer{itree}~\typeformer{E}\,\type{R}}{\term{t} : \typeformer{itree}~\typeformer{E}\,\type{R}}}.
  \end{equation}
  \begin{defn}\setlengths
    We define a container
    \begin{equation}
      \containerpair{\type{R}+\unit+\sum_{(\type{A}:\universe{\mathcal{U}})} (\typeformer{E}\,\type{A})}{[\empt , \unit , \type{A}]}.
    \end{equation}
    and a polynomial functor which simplifies to
    \begin{equation}
      \functor{P}\,\type{X} = \type{R} + \type{X} + \sum_{(\type{A} : \universe{\mathcal{U}})} (\typeformer{E}\,\type{A} \times (\type{A} \rightarrow \type{X}))
    \end{equation}
  \end{defn}
\end{frame}

\begin{frame}[shrink=36,fragile]
  \frametitle{Example: Interaction Trees (ITrees)}
  \vspace{35mm}
  \begin{figure}[h]
    \centering
    \begin{tikzcd}[row sep=large,column sep=large]
      \type{R} \ar[ddrr,"\constructor{Ret}"'] \ar[r,"\texttt{inl}\,\circ\,\texttt{inr}"] & \typeformer{IT}~\typeformer{E}~\type{R} + \type{R} + \sum_{(\type{A} : \universe{\mathcal{U}})} (\typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{IT}~\typeformer{E}~\type{R})) \ar[ddr,"\function{in}"] & & \sum_{(\type{A} : \universe{U})} \typeformer{E}\,\type{A} \times (\type{A} \rightarrow \typeformer{IT}~\typeformer{E}~\type{R}) \ar[ll,"\texttt{inr}"'] \ar[ddl,"\constructor{Vis}"] \\
      & & \typeformer{IT}~\typeformer{E}~\type{R} \ar[ul,"\texttt{inl}\,\circ\,\texttt{inl}"'] \ar[d,"\constructor{Tau}"'] \\
      & & \typeformer{IT}~\typeformer{E}~\type{R}
    \end{tikzcd}
  \end{figure}
\end{frame}

\subsection{Rules for Construction M-types}
\begin{frame}
  \frametitle{Rules for Constructing \texttt{M}-types}
  
\end{frame}

\section{Q\texttt{M}-types}

\begin{frame}
  \frametitle{Overview}
  \tableofcontents[currentsection,subsubsectionstyle=hide]
\end{frame}

\section{Conclusion}
\begin{frame}
  \frametitle{Conclusion}
\end{frame}

\begin{frame}
  \frametitle{Future Work}
\end{frame}

\end{document}
